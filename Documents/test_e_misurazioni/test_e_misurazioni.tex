% ATTENZIONE!!! 
% Per far funzionare i collegamenti ipertestuali si raccomanda di usare
%	\classname{nomedellaclasse}
% per le classi dello stesso package mentre invece 
%	\hyperref[nomedellaclasse]{\ttfamily{}nomequalificatodellaclasse}
% per le classi che non sono dello stesso package e che hanno il nome completo

% **************************************************
% Macro specifiche per il documento corrente
% **************************************************
% Nome
\newcommand{\docName}{Test e misurazioni}
% Nome file
\newcommand{\docFileName}{test\_e\_misurazioni.1.0.pdf}
% Versione
\newcommand{\docVers}{1.0}
% Data creazione
\newcommand{\creationDate}{2013-02-20}
% Data ultima modifica
\newcommand{\modificationDate}{ 2013-03-23}
% Stato in {Approvato, Non approvato}
\newcommand{\docState}{Non approvato}
% Uso in {Interno, Esterno}
\newcommand{\docUsage}{Esterno}
% Destinatari da specificare come nome1\\ &nome2\\ ecc.
\newcommand{\docDistributionList}{Prof. Tullio Vardanega\\&Prof. Riccardo Cardin\\&Dott. Gregorio Piccoli\\&Team SoftwareSynthesis}
% Redattori da specificare come nome1\\ &nome2\\ ecc.
\newcommand{\docAuthors}{Stefano Farronato}
% Approvato da
\newcommand{\approvedBy}{Andrea Rizzi}
% Verificatori
\newcommand{\verifiedBy}{Diego Beraldin}
% Perscorso (relativo o assoluto) che punta alla directory contenente shared/
% come sua sottodirectory (per comodità chiamiamola 'doc root').
\newcommand{\docRoot}{..}
% definire se si vuole l'indice delle tabelle
\def\INDICETABELLE{false}
% definire se si vuole l'indice delle figure
\def\INDICEFIGURE{false}

% importa il preambolo condiviso da tutti i documenti
\input{\docRoot/shared/preamble.tex}

% macro specifiche per il documento corrente
\newcommand{\classsection}[1]{\subsubsection{#1}\label{#1}}
\newcommand{\classname}[1]{\hyperref[#1]{\ttfamily#1}}

% Fine del preambolo e inizio del documento
\begin{document}

% Inclusione della prima pagina
\input{\docRoot/shared/firstpage.tex}

%---------------------------RUOLI----------------------------
%FASE 1:
%Programmatori: DIEGO, STEFANO, SCHIVO
%FASE 2:
%Programmatori: MENE, TRES, ELENA

%Verificatore: SCHIVO, STEFANO, RIZZI, DIEGO (dobbiamo fare un sacco di test)
%Responsabile finale supremo: RIZZI
%------------------------------------------------------------

% Storico delle modifiche
\section*{Storia delle modifiche}
\begin{center}
\begin{longtable}{lp{.32\textwidth}lll}
\toprule
Versione & Descrizione intervento & Membro & Ruolo & Data\\
\midrule % inserire qui il contenuto della tabella
1.0 & Approvazione documento& Andrea Rizzi & Responsabile & 2013-03-23\\
0.8 & correzione errori segnalati dal verificatore& Stefano Farronato & Verificatore & 2013-03-23\\
0.7 & verifica correttezza lessico ortografica e corrispondenza test con quanto descritto& Diego Beraldin & Verificatore & 2013-03-23\\
0.6 & aggiunti test su capitolo e test coverage& Stefano Farronato & Verificatore & 2013-03-22\\
0.5 & stesura capitoli sui test di sistema e di utilizzo, aggiunti test su capitolo 4.1& Stefano Farronato & Verificatore & 2013-03-22\\
0.4 & stesura capitolo relativo ai test sul \textit{presenter} & Stefano Farronato & Verificatore & 2013-03-21\\
0.3 & stesura capitolo relativo ai test sul \textit{model} & Stefano Farronato & Verificatore & 2013-03-21\\
0.2 & stesura introduzione con ``scopo dei test'' e preambolo su ``Metriche sul codice''& Stefano Farronato & Verificatore & 2013-03-20\\
0.1 & Creazione del documento e stesura delle sezioni ``Introduzione'' e ``Riferimenti''. & Stefano Farronato & Verificatore & 2013-03-20\\
\bottomrule
\end{longtable}
\end{center}
\newpage

% inclusione dell'indice
\input{\docRoot/shared/toc.tex}

% Alcuni aggiustamenti per le pagine
\pagenumbering{arabic}
\setcounter{page}{1}
\pagestyle{normal}

% Qui ha inizio il documento vero e proprio...
\newpage

\section{Introduzione}
\setcounter{table}{0}
\subsection{Scopo del prodotto}
\purpose

\subsection{Scopo del documento}
Il documento ha lo scopo di definire e riportare l'esito dei test effettuati sul codice prodotto, attraverso misurazioni quantitative valutate attraverso metriche definite al fine di assicurare che la qualità del prodotto risultante sia coerente con i requisiti redatti e rispetti quanto redatto nel documento \textit{piano\_di\_qualifica.3.0.pdf}.
I test predisposti saranno descritti esaustivamente sia nella forma che nei risultati ottenuti, al fine di renderne più chiara e oggettiva possibile la comprensione.

\subsection{Glossario}
\glossaryIntro
\clearpage

\section{Riferimenti}
\subsection{Normativi}
\begin{itemize}
\item[] \textit{piano\_di\_qualifica.3.0.pdf} allegato;
\item[] \textit{norme\_di\_progetto.3.0.pdf} allegato;
\item[] \textit{specifica\_tecnica.2.0.pdf} allegato;
\item[] \textit{definizione\_di\_prodotto.1.0.pdf} allegato.
\item[] \textit{analisi\_dei\_requsiti.3.0.pdf} allegato;
\end{itemize}

\subsection{Informativi}
\begin{itemize}
\item[] Capitolato d'appalto: \caName{}, v1.0, redatto e rilasciato dal proponente Zucchetti s.r.l. reperibile all'indirizzo \url{http://www.math.unipd.it/~tullio/IS-1/2012/Progetto/C1.pdf};
\item[] testo di consultazione: \textit{Software Engineering (8th edition) Ian Sommerville, Pearson Education | Addison Wesley};
\item[] \textit{glossario.3.0.pdf} allegato.
\end{itemize}
\clearpage

\subsection{Metriche sul codice}
Per la parte \textit{Model} prima di tutto sono state calcolate, al fine di quantificare la ``dimensione'' di una componente, due metriche: il \inglese{Number Of Classes} (NOC) e il \inglese{Number Of Method} (NOM).
NOC rappresenta il numero totale delle classi che sono rappresentate all'interno del package, mentre il NOM rappresenta il numero dei metodi conteggiati, sempre per package.

La tabella \ref{tab:metricheNOCNOM} riporta le misurazioni su tali metriche per i package del prodotto \caName{}, evidenziandone i più corposi dal punto di vista implementativo.


\begin{center}
\rowcolors{2}{lightblue}{llightblue}\begin{longtable}{p{.55\textwidth}ll}
\toprule Package & NOC  & NOM\\
org.softwaresynthesis.mytalk.server & 0 & 0\\
org.softwaresynthesis.mytalk.server.abook & 3 & 55\\
org.softwaresynthesis.mytalk.server.abook.servlet & XXXXX & XXXXX\\
org.softwaresynthesis.mytalk.authentication & 5 & 22\\
org.softwaresynthesis.mytalk.authentication.servlet & 3 & 10\\
org.softwaresynthesis.mytalk.connection & 2 & 10\\
org.softwaresynthesis.mytalk.dao & 4 & 18\\
\bottomrule
\caption{Misurazioni metriche NOC e NOM} \label{tab: metricheNOCNOM}
\end{longtable}

\end{center}


Spingendosi più nel dettaglio si è deciso di esporre il \inglese{Total Line Of Code} (TLOC) e il \inglese{Method Lines Of Code} (MLOC).
Come suggeriscono i nomi, TLOC rappresenta il numero totale di linee di codice (effettive, ovvero senza contare quelle commentate) all'interno di un'unità di compilazione, MLOC definisce invece il numero totale di linee di codice (sempre effettive) che definiscono i corpi dei metodi. 

Come per NOC e NOM riportiamo la tabella \ref{tab: metricheTLOCMLOCserver} con le misurazioni su tali metriche relative ai package di \caName{}.


\begin{center}
\rowcolors{2}{lightblue}{llightblue}\begin{longtable}{p{.55\textwidth}ll}
\toprule Package & TLOC  & MLOC\\
\midrule
org.softwaresynthesis.mytalk.server & 5 & 0\\
org.softwaresynthesis.mytalk.server.abook & 390 & 277\\
org.softwaresynthesis.mytalk.server.abook.servlet & XXXX & XXXX\\
org.softwaresynthesis.mytalk.authentication & 347 & 237\\
org.softwaresynthesis.mytalk.authentication.servlet & 225 & 185\\
org.softwaresynthesis.mytalk.connection & 132 & 102\\
org.softwaresynthesis.mytalk.dao & 632 & 138\\
\bottomrule
\caption{Misurazioni metriche TLOC e MLOC del server} \label{tab: metricheTLOCMLOCserver}
\end{longtable}
\end{center}


Coerentemente con le Norme di Progetto consultabili nel documento allegato\\ \textit{norme\_di\_progetto.3.0.pdf} si riporta l'indice di complessità ciclomatica (media) per ogni package. Tale misura è direttamente legata al numero di cammini linearmente indipendenti che compongono il grafo di controllo di flusso. Tale indice dovrebbe essere compreso tra 0 e 10 per definire il codice nella norma.
Infine il \inglese(Lack Of Cohesion Of Methods) (LCOM3) indica il liello (medio) di coesione dei metodi, più tale livello risulta basso migliore risulterà essere la progettazione della classe. I valori possono quindi variare tra lo 0, che indica la massima coesione possibile, e 2, che ne identifica il valore minimo.

\begin{center}
\rowcolors{2}{lightblue}{llightblue}\begin{longtable}{p{.55\textwidth}ll}
\toprule Package & CC  & LCOM3\\
org.softwaresynthesis.mytalk.server & 0 & 0\\
org.softwaresynthesis.mytalk.server.abook & 1,073 & 0,834\\
org.softwaresynthesis.mytalk.server.abook.servlet & XXXX & XXXX\\
org.softwaresynthesis.mytalk.authentication & 1,682 & 0,18\\
org.softwaresynthesis.mytalk.authentication.servlet & 1,8 & 0\\
org.softwaresynthesis.mytalk.connection & 1,769 & 0,25\\
org.softwaresynthesis.mytalk.dao & 3,895 & 0\\

\midrule
\bottomrule
\caption{Misurazioni metriche CC e LCOM3 del server} \label{tab: metricheCCLCOM3server}
\end{longtable}
\end{center}


Per la parte \textit{Presenter} vengono presentate due metriche già descritte per la parte \textit{model}: la complessità ciclomatica (media) e il TLOC, che ricordiamo essere il numero totale di linee di codice effettive, ovvero senza contare quelle non vuote o commentate.

\begin{center}
\rowcolors{2}{lightblue}{llightblue}\begin{longtable}{p{.55\textwidth}ll}
\toprule Package & CC  & TLOC\\
AccountSettingPannelPresenter.js & 2 & 170\\
AdressBookPanelPresenter.js & 2,95 & 467\\
CallHistoryPanelPresenter.js & 1,25 & 78\\
ComunicationPanelPresenter.js & 1,92 & 220\\
ContactPanelPresenter.js & 0,3 & 173\\
GroupPanelPresenter.js & 1,5 & 48\\
LoginPanelPresenter.js & 2 & 275\\
MainPanelPresenter.js & 1 & 15\\
MessagePanelPresenter.js & 1,25 & 125\\
PresenterMediator.js & 1,38 & 156\\
RegisterPanelPresenter.js & 3,08 & 246\\
SearchResultPanelPresenter.js & 2,25 & 67\\
ToolsPanelPresenter.js & 1,14 & 82\\
\midrule

\bottomrule
\caption{Misurazioni metriche TLOC e MLOC del presenter} \label{tab: metricheTLOCMLOCpresenter}

\end{longtable}
\end{center}
Portando quindi una complessità ciclomatica media di 1,69 con un massimo di 9 in \textit{RegisterPanelPresenter.register}.


\section{Scopo dei test}
I test riportati hanno lo scopo di dimostrare in modo oggettivo la bontà e la qualità di quanto prodotto a livello di codice. Tali test servono inoltre a rilevare \inglese{bug} non evidenziati (o non possibili da evidenziare) durante l'analisi statica del codice e vengono effettuati sui package relativi alla parte di \inglese{Model} e \inglese{Presenter} del modello MVP generale.
Le verifiche relative alla parte \inglese{View} saranno al contrario effettuati successivamente a quelli sui componenti sopracitati, in quanto sarà necessario avere la certezza che tali componenti risultino stabili e privi (per quanto possibile) di \inglese{bug}. 
Specifichiamo inoltre che tali verifiche saranno effettuati tramite i test di sistema specificati nel documento \textit{anilisi\_dei\_requisiti.3.0.pdf} allegato.

Il team ha seguito la seguente sequenza di passi per la realizzazione e l'utilizzo delle varie funzioni di test:
\begin{itemize}
\item individuazione preliminare delle funzionalità da testare;
\item analisi, progettazione e successiva implementazione delle funzioni di test per le funzionalità individuate, stabilendo i dati di input e specificati gli output attesi;
\item esecuzione delle funzioni di test create.
\item analisi dei risultati dei test, confrontato i risultati con quelli attesi ed effettuato la correzione di eventuali anomalie riscontrate, verificata infine la ripetibilità del test stesso;
\item registrati i risultati ottenuti.
\end{itemize}

I test per la parte \inglese{Model} sono stati predisposti ed eseguiti usufruendo della libreria JUnit, in quanto questa parte della struttura è implementata mediante codice \underline{Java}.
Per il componente \inglese{Presenter} si è deciso invece di usufruire di QUnit, coerentemente con il linguaggio scelto (\underline{JavaScript}) che lo implementa. Tale \underline{franework} risulta pratico in quanto permette di individuare facilmente quale metodo analizzato ha portato al fallimento del test, inoltre permette una netta separazione tra codice testato e i test effettivi.

\section{Model}
I test su questa parte del sistema mirano a verificare che la persistenza dei dati all'interno del \underline{server} sia gestita correttamente dal \underline{database}.
Per l'esecuzione di questi test si è usata, coerentemente con le norme di progetto, la libreria \textit{JUnit}.
Ogni test è inoltre stato eseguito più volte in modo da avere uno spettro più ampio di misurazioni e produrre una verifica più stabile e oggettiva possibile.
\subsection{Test effettuati}
\subsubsection{AESAlgorithmTest}
\textbf{Verifica la Classe:}\textit{AESAlgorithm}.\\
\textbf{Descrizione}:l'obbiettivo di questo test è assicurare che l'algrotimo di cittografia AES utilizzato dal sistema \caName risulti affidabile e riesca a codificare e decodificare una stringa passata.\\
Tale test si compone di un solo metodo:
\begin{itemize}
\item \textit{testEncodeAndDecode() } effettua la codifica di una stringa passata, effettua successivamente la decodifica della stessa e la controlla con l'originale per verificarne l'uguaglianza.
\end{itemize}
\textbf{Risultato del test:} non sono stati rilevati errori.

\begin{table}
\end{table}

\subsubsection{AdressBookEntryTest}
\textbf{Verifica la Classe:} \textit{AdressBookEntry}.\\
\textbf{Descrizione}:l'obbiettivo di questo test è verificare la corretta conversione di un istanza di \textit{AddressBookEntry}.\\
Tale test si compone di un solo metodo:
\begin{itemize}
\item \textit{testToJson() } tale metodo riceve una stringa in formato json di una 	\textit{entry} della rubrica e verifica che quest'ultima sia equivalente a quella ottenuta dalla chiamata al metodo \textit{ToJson} sull'istanza della classe \textit{AddressBookEntry};
\item{testEquals()} viene creato un oggetto \textit{AdressBookEntry} e viene confrontato con l'istanza dell'oggetto che ha invocato il metodo, restituendo \textit{true} se e solo se sono uguali.
\end{itemize}
\textbf{Risultato del test:} non sono stati rilevati errori.

\subsubsection{AuthenticationDataTest}
\textbf{Verifica la Classe:} \textit{AuthenticationData}.\\
\textbf{Descrizione}:l'obbiettivo di questo test è assicurare l'uguaglianza tra due oggetti che rappresentano le credenziali dell'utente inserite volutamente con gli stessi dati. Successivamente verrà effettuata anche una negazione di tale test per assicurarne l'efficacia.\\
Tale test si compone di due metodi:
\begin{itemize}
\item \textit{testEquals() } testa che due oggetti diversi contenenti gli stessi dati passati al metodo restituiscano \textit{true} solo se sono effettivamente uguali;
\item \textit{testDifferent()}testa che due oggetti diversi contenenti diversi dati passati al metodo restituiscano \textit{true} solo se sono effettivamente differenti.
\end{itemize}
\textbf{Risultato del test:} non sono stati rilevati errori.

\begin{table}
\end{table}

\subsubsection{AuthenticationModuleTest}
*Descrizione*
Tale test si compone di X metodi:
\begin{itemize}
\item \textit{testLogin() }
\item \textit{testLogout() }
\item \textit{testAbort() }
\end{itemize}
\textbf{Risultato del test:} non sono stati rilevati errori.

\begin{table}
\end{table}

\subsubsection{CredentialLoaderTest}
\textbf{Verifica la Classe:} \textit{CredentialLoarder}.\\
\textbf{Descrizione}:l'obbiettivo di questo test è assicurare che il vettore in cui celle contiente tutte le credenziali d'accesso dell'utente (coppia \textit{username-password}) venga popolato correttamente.\\
Tale test si compone di un solo metodo metodi:
\begin{itemize}
\item \textit{testLoarder() } tale metodo carica nel vettore i campi \textit{username} e \textit{password} e controlla che siano effettivamente stati inseriti e i dati siano coerenti (uguali) con quelli iniziali.
\end{itemize}
\textbf{Risultato del test:} non sono stati rilevati errori.

\subsubsection{GroupTest}
\textbf{Verifica la Classe:} \textit{Group}.\\
\textbf{Descrizione}:l'obbiettivo di questo test è verificare la corretta conversione di un istanza di \textit{Group}.\\
Tale test si compone di un solo metodo:
\begin{itemize}
\item \textit{testToJson() } tale metodo riceve una stringa in formato json di una 	\textit{entry} della rubrica e verifica che quest'ultima sia equivalente a quella ottenuta dalla chiamata al metodo \textit{ToJson} sull'istanza della classe \textit{Group};
\item \textit{testId() } verifica l'effettivo inserimento del campo \textit{id} mediante il metodo \textit{getId()};
\item \textit{testName() } verifica l'effettivo inserimento del campo \textit{name} mediante il metodo \textit{getName()}; %TODO DA DESCRIVERE
\item{testEquals()} viene creato un oggetto \textit{AdressBookEntry} e viene confrontato con l'istanza dell'oggetto che ha invocato il metodo, restituendo \textit{true} se e solo se sono uguali.
\end{itemize}
\textbf{Risultato del test:} non sono stati rilevati errori.

\subsubsection{HybernateUtilTest}
\textbf{Verifica la Classe:} \textit{HybernateUtil}.\\
\textbf{Descrizione}:l'obbiettivo di questo test è assicurare la corretta esecuzione dei metodi della classe \textit{HibernateUtil}. \\
Tale test si compone di due metodi:
\begin{itemize}
\item \textit{testIstance() } l'obbiettivo di questo test è testare l'effettiva presenza di un unica istanza della classe textit{HibernateUtil} mediante la creazione di due istanze e verificando che entrambi puntino alla stessa istanza dell'oggetto;
\item \textit{testGetFactory()} ha lo scopo di verifcare la presenza di una \textit{sessionFactory} configurata correttamente per la comunicazione con il database.
\end{itemize}
\textbf{Risultato del test:} non sono stati rilevati errori.

\subsubsection{UserDataDAOTest}
\textbf{Verifica la Classe:} \textit{UserDataDAO}.\\
\textbf{Descrizione}:l'obbiettivo di questo test è assicurare la corretta esecuzione delle operazioni CRUD (\textit{Create, Read, Update, Delete}) per gli oggetti di tipo \textit{UserData} verso il database. \\
Tale test si compone di 5 metodi:
\begin{itemize}
\item \textit{testInsert()} tale metodo ha lo scopo di verificare il corretto inserimento di uno \textit{userdata} all'interno del database;
\item \textit{testGetByEmail()} ha lo scopo di verificare il prelevamento dal database di uno \textit{userdata} tramite l'indirizzo mail con cui si è registrato nel sistema;
\item \textit{testUpdate() } verifica se le modifiche ad un oggetto \textit{userdata} siano effettive nel database;
\item \textit{testDelete() } verifica l'effettiva cancellazione di uno \textit{userdata} dal database;
\item \textit{testSearchGeneric()} verifica che sia presente uno \textit{userdata} nel database mediante la ricerca fatta cercando un parametro di input che ha una corrispondenza con uno o più campi tra \textit{nome, cognome, email}.
\end{itemize}
\textbf{Risultato del test:} non sono stati rilevati errori.

\subsubsection{UserDataTest}
\textbf{Verifica la Classe:} \textit{UserData}.\\
\textbf{Descrizione}:l'obbiettivo di questo test è verificare la corretta conversione di un istanza di \textit{DataTest}. La classe inizializza inoltre un istanza di tale classe, impostandone i campi membro attraverso i metodi \textit{set}. Successivamente mediante i metodi \textit{get} vengono verificati gli effettivi inserimenti.\\
Tale test si compone di otto metodi:
\begin{itemize}
\item \textit{testToJson() } tale metodo riceve una stringa in formato json di una 	\textit{entry} della rubrica e verifica che quest'ultima sia equivalente a quella ottenuta dalla chiamata al metodo \textit{ToJson} sull'istanza della classe \textit{DataTest};
\item \textit{testId() } verifica l'effettivo inserimento del campo \textit{id} mediante il metodo \textit{getId()};
\item \textit{testEmail() } verifica l'effettivo inserimento del campo \textit{email} mediante il metodo \textit{getEmail()};
\item \textit{testPassword() } verifica l'effettivo inserimento del campo \textit{password} mediante il metodo \textit{getPassword()};
\item \textit{testQuestion() } verifica l'effettivo inserimento del campo \textit{question} mediante il metodo \textit{getQuestion()};
\item \textit{testAnswer() } verifica l'effettivo inserimento del campo \textit{answer} mediante il metodo \textit{getAnswer()};
\item \textit{testName() } verifica l'effettivo inserimento del campo \textit{name} mediante il metodo \textit{getName()};
\item \textit{testSurname() } verifica l'effettivo inserimento del campo \textit{surname} mediante il metodo \textit{getSurname()};
\item \textit{testPicturePath() } verifica l'effettivo inserimento del campo \textit{picturePath} mediante il metodo \textit{getPicturePath()};
\item{\textit{testEquals()}} verranno creati due oggetti \textit{UserData} contenenti gli stessi dati, tale metodo restituirà \textit{true} se e solo se sono effettivamente uguali.
\end{itemize}
\textbf{Risultato del test:} non sono stati rilevati errori.

\subsubsection{}
\textbf{Verifica la Classe:} \textit{}.\\
\textbf{Descrizione}:\\
Tale test si compone di X metodi:
\begin{itemize}
\item \textit{() } %TODO DA DESCRIVERE
\end{itemize}
\textbf{Risultato del test:} non sono stati rilevati errori.


\section{Presenter}
I test sul \textit{presenter} sono mirati a verificare che le classi di tale componente rispettino il comportamento atteso, interagendo i dati tramite l'interazione con il \textit{model}, componente testato nella sezione precedente.

Questa serie di test, come anticipato nelle prime pagine del documento, è stata eseguita mediante il \underline{\textit{framework}} \textit{Qunit}. Tali verifiche sono state implementate allo scopo di non testare soltanto il comportamento della specifica funzione, ma anche verificare lo stato di avanzamento del prodotto e il numero di bug evidenziati ancora esistenti.
Ovviamente al termine di tali verifiche il risultato dovrà risultare positivo, ovvero i test dovranno essere \textit{tutti} superati.


\subsection{Test effettuati}
\subsubsection{AccountSettingsPanelPresenterTest}
\textbf{Verifica l'oggetto:} \textit{AccountSettingsPanelPresenter}.\\
\textbf{Descrizione}: verifica la corretta inizializzazione di \textit{AccountSettingPanel}, ovvero che l'albero sia stato costruito correttamente, e che il contenuto dei vari nodi sia stato inserito coerentemente. Verifica inoltre la corretta inizializazione del \inglese{\underline{form}} per la modifica dei dati personali e l'invio dei dati in forma corretta al server.
Tale verifica è composta da 4 test:
\begin{itemize}
\item \textit{testCreatePanel()} crea l'elemento \textit{AccountSettingPanel}, estrae la lista dei suoi figli, ne controlla il numero (deve essere \textit{tre}) e che il primo sia un immagine, il secondo una lista e il terzo un \inglese{button}.
Successivamente controlla che gli elementi della lista vengano visualizzati correttamente presentando quindi il contenuto corrispondente ai dati memorizzati nello \inglese{stub} di \texttt{CommunicationCenter}.
\item \textit{testBuildQueryString()} controlla che venga creata la stringa di interrogazione da inviare alla servlet sulla base dei dati memorizzati nell'array associativo passato in ingresso come parametro al metodo \texttt{buildQueryString} del presenter.
\item \textit{testHasSomethingChanged()} verifica che sia rilevato correttamente un cambiamento (nel nome, nel cognome o nel percorso dell'immagine) tra l'array associativo passato in ingresso e quanto memorizzato in uno \inglese{stub} di \texttt{CommunicationCenter}.
\item \textit{testOnChangeButtonPressed()} controlla il comportamento del presenter nel momento in cui si verifica l'evento nell'interfaccia grafica di pressione del pulsante per la modifica dei dati. In particolare, il test verifica che il pannello sia trasformato in un \inglese{form} con i tre campi di inserimento necessari corredati dalle relative etichette.
\end{itemize}
\textbf{Risultato del test:} non sono stati rilevati errori.

\subsubsection{AddressBookPanelPresenterTest}
\textbf{Verifica l'oggetto:} \textit{AdressBookPanelPresenter}.\\
\textbf{Descrizione}: l'obiettivo di questo test è la verifica della correttezza di tutte le funzionalità offerte da \textit{AddressBookPanel}.\\
Tale verifica è composta da 16 test:
\begin{itemize}
\item \textit{testDeleteGroup() } il test controlla che avvenga la corretta eliminazione di un gruppo dalla rubrica, tramite l'uso di uno \inglese{stub}. Il test verifica anche l'effettivo sollevamento di un'eccezione quando si tenta di eliminare un gruppo non presente nella rubrica.
\item \textit{testInitialize()} controlla che la rubrica venga costruita correttamente. Verifica in particolare che la rubrica sia composta di cinque figli dove il primo è un \textit{<h1>} e gli altri quattro sono \textit{<div>}. Controlla poi che ognuno dei cinque figli sia costruito correttamente. 
\item \textit{testSetup()} controlla il corretto funzionamento di \textit{setup()} ovvero che avvenga correttamente il popolamento della rubrica con i contatti, che vengono scaricati da uno \inglese{stub} che simula la presenza di una \inglese{servlet} lato server. 
Il test avviene tramite la creazione di uno \inglese{stub} che emula i contatti dell'utente presenti nella sua rubrica. 
Il test consiste nel controllo che avvenga l'inserimento dei contatti nella lista contenuta nella struttura dell'\textit{AdressBookPanel}. In particolare, oltre a controllare che il numero di contatti sia giusto (devono essere due), si verifica che sia corretto il loro nome, il loro cognome.
\item \textit{testHide()} verifica il comportamento del presenter nel momento in cui il pannello deve essere nascosto, vale a dire impostando correttamente le proprietà di visualizzazione dell'elemento grafico associato.
\item \textit{testAddContact() } il test verifica che avvenga il corretto inserimento di un contatto nella rubrica, tramite l'uso di uno \inglese{stub}. Il test verifica anche l'effettivo sollevamento di un'eccezione quando si tenta di inserire un contatto già presente nella rubrica.
\item \textit{testRemoveContact()} il test verifica che avvenga la corretta eliminazione di un contatto, tramite l'uso di \inglese{stub}. Il test verifica anche l'effettivo sollevamento di un'eccezione quando si tenta di eliminare un contatto non presente nella rubrica.
\item \textit{testApplyFilterByString() } verifica il funzionamento del filtro per i contatti. Il test controlla che data in input una stringa vengano restituiti i contatti che contengono la stringa nel nome, nel cognome o nella mail. Il test controlla il funzionamento per ogni possibile parametro (nome, cognome, mail). Viene inoltre verificato che il risultato del filtraggio sia nullo qualora la stringa inserita non sia presente in nessuno dei campi di nessun contatto della rubrica.
\item \textit{testApplyFilterByString()} verifica il funzionamento del filtro per i contatti. Il test controlla che data in input una stringa vengano restituiti i contatti che contengono la stringa nel nome, nel cognome o nella mail. Il test controlla il funzionamento per ogni possibile parametro (nome, cognome, mail). Viene inoltre verificato che il risultato del filtraggio sia nullo qualora la stringa inserita non sia presente in nessuno dei campi di nessun contatto della rubrica.
\item \textit{testAddGroup()} il test verifica che avvenga il corretto inserimento di un gruppo nella rubrica, tramite l'uso di uno \inglese{stub}. Il test verifica anche l'effettivo sollevamento di un'eccezione quando si tenta di inserire un gruppo già presente nella rubrica.
\item \textit{testBlockUser()} il test controlla che il controlla il corretto funzionamento del blocco di un contatto tramite l'uso di uno \inglese{stub} per la \inglese{servlet} coivolta nell'operazione. Viene inoltre controllato l'effettivo sollevamento di un'eccezione nel caso in cui l'utente che si desidera bloccare sia già bloccato.
\item \textit{testUnlockUser()} il test controlla che il controlla il corretto funzionamento dello sblocco di un contatto viene effettuato il blocco di un contatto tramite l'uso di uno \inglese{stub}. Il test controlla anche l'effettivo sollevamento di un'eccezione nel caso in cui l'utente che si desidera sbloccare risulta essere già sbloccato.
\item \textit{testApplyFilterByGroup() } verifica il funzionamento del filtro per i gruppi. Il test controlla che data in input il nome del gruppo vengano restituiti i contatti appartenenti a quel gruppo. 
\item \textit{testAddContactInGroup()} il test verifica che avvenga il corretto inserimento di un contatto all'interno gruppo, tramite l'uso di uno \inglese{stub}. Il test controlla anche l'effettivo sollevamento di un'eccezione quando si tenta di inserire un contatto già presente nel gruppo in cui si tenta di aggiungerlo.
\item \textit{testDeleteContactFromGroup()} il test verifica che avvenga la corretta eliminazione di un contatto da un gruppo, tramite l'uso di uno \inglese{stub}. Il test controlla anche l'effettivo sollevamento di un'eccezione quando si tenta di eliminare dal gruppo un contatto che non gli appartiene.
\item \textit{testGetGroupsWhereContactsIs()} verifica che il nome del gruppo in cui l'utente \textit{stub} è inserito sia corrispondente con quello in cui è effettivamente presente.
\item \textit{showFiltered()} il test controlla la corretta restituzione dei contatti filtrati. In particolare verifica che il numero di contatti restituiti sia corretto.
\item \textit{testContactAlreadyPresent()} verifica la presenza di un utente nella lista dei contatti presenti nella rubrica dell'utente garantendone la presenza effettiva.
item \textit{testRemoveContactFromGroup()} il test verifica che avvenga la corretta eliminazione di un contatto da un gruppo, tramite l'uso di uno \inglese{stub}. Il test controlla anche l'effettivo sollevamento di un'eccezione quando si tenta di eliminare dal gruppo un contatto che non gli appartiene.
\end{itemize}
\textbf{Risultato del test:} non sono stati rilevati errori.

\subsubsection{CallHistoryPanelPresenterTest}
\textbf{Verifica l'oggetto:} \textit{CallHistoryPanelPresenter}.\\
\textbf{Descrizione}: l'obiettivo di questo test è verificare la corretta creazione del sotto-albero che ha radice nell'elemento \textit{CallHistoryPanel}.\\
Tale verifica è composta da un solo test:
\begin{itemize}
\item \textit{testCreatePanel() } controlla che CallHistoryPanel abbia un unico figlio e che quest'ultimo sia effettivamente una lista (che corrisponde allo storico delle chiamate).
\end{itemize}
\textbf{Risultato del test:} non sono stati rilevati errori.

\subsubsection{CommunicationPanelPresenterTest}
\textbf{Verifica l'oggetto:} \textit{CommunicationPanelPresenter}.\\
\textbf{Descrizione}: l'obiettivo di questo test è verificare la corretta creazione del sotto-albero che ha radice nell'elemento \textit{CommunicationPanel}.\\
Tale verifica è composta da un solo test:
\begin{itemize}
\item \textit{testCreatePanel()} controlla che il numero dei figli del \textit{CommunicationPanel} siano esattamente due, che entrambi siano \texttt{<div>} e che il valore dell'attributo \texttt{id} del primo figlio sia ``divCall'' mentre del secondo ``divChat''. Verifica i figli dell'elemento per la visualizzazione delle chiamate (due elementi \texttt{<video>} e un ulteriore elemento \texttt{<div>} per la visualizzazione delle statistiche) e i figli dell'elemento per la visualizzazione delle chat.
\item \textit{testUpdateTimer()} verifica che sia correttamente visualizzata la stringa passata come parametro in ingresso al metodo \texttt{updateTimer}. A tal fine è utilizzato uno \inglese{stub} per simulare per la vista, che espone verso il presenter la medesima interfaccia del pannello vero.
\item \textit{testGetMyVideo()} verifica l'accesso alla parte di interfaccia grafica incaricata di visualizzare l'input proveniente dalla webcam dell'utente, utilizzando ancora uno \inglese{stub} per la vista mancante.
\item \textit{testGetOtherVideo()} verifica l'accesso alla parte di interfaccia grafica incaricata di visualizzare l'input proveniente dal client con cui si è instaurata una comunicazione.
\item \textit{testUpdateStarts()} verifica la corretta visualizzazione delle statistiche di comunicazione, tanto per i dati in ingresso che per i dati in uscita. A tal fine è utilizzato uno \inglese{stub} per simulare la presenza della vista durante l'esecuzione del test.
\end{itemize}
\textbf{Risultato del test:} non sono stati rilevati errori.

\subsubsection{ContactPanelPresenterTest}
\textbf{Verifica l'oggetto:} \textit{ContactPanelPresenter}.\\
\textbf{Descrizione}: l'obiettivo di questo test è verificare la corretta creazione del sotto-albero che ha radice nell'elemento \textit{ContactPanel}.\\
Tale verifica è composta da un solo test:
\begin{itemize}
\item \textit{testCreatePanel()} crea l'elemento \textit{ContactPanel}, estrae la lista dei suoi figli e controlla per ogni figlio che le informazioni siano coerenti con quelle inserite in input.
\item \textit{testDisplay()} controlla la modifica dell'interfaccia grafica nel momento in cui deve essere visualizzato il \textit{ContactPanel} contenente i dati di un contatto selezionato. In particolare, il test controlla la visualizzazione dei dati (nome, cognome, indirizzo email) e la corretta impostazione dell'attributo \texttt{src} dell'elemento immagine presente nel pannello.
\end{itemize}
\textbf{Risultato del test:} non sono stati rilevati errori.

\subsubsection{GroupPanelPresenterTest}
\textbf{Verifica l'oggetto:} \textit{GroupPanelPresenter}.\\
\textbf{Descrizione}: l'obiettivo di questo test è verificare la corretta istanziazione del \textit{GroupPanel}, verificandone pertanto la corretta esecuzione della \inglese{form}.\\
Tale verifica è composta da un solo test:
\begin{itemize}
\item \textit{testCreatePanel()} verifica la corretta visualizzazione iniziale del pannello, in particolare, verificando che sia creata la lista dei gruppi presenti nella rubrica dell'utente associato al client.
\item \textit{testDisplayContactList()} verifica la corretta visualizzazione dell'elenco dei gruppi della rubrica nel pannello dell'interfaccia utente, inserendo per ogni gruppo una voce che ne riporta il nome e che è corredata dai pulsanti di amministrazione (per l'eliminazione di un gruppo).
\end{itemize}
\textbf{Risultato del test:} non sono stati rilevati errori.

\subsubsection{LoginPanelPresenterTest}
\textbf{Verifica l'oggetto:} \textit{LoginPanelPresenter}.\\
\textbf{Descrizione}: l'obiettivo di questo test è verificare la corretta istanziazione del \textit{LoginPanel} popolato con dei dati coerenti rispetto allo scopo della \inglese{form}.
Tale verifica è composta da quattro test:
\begin{itemize} 
\item \textit{testInitialize()} mediante diverse asserzioni \texttt{equal} controlla l'effettiva correttezza della \inglese{form} creata, sia nella forma che nel funzionamento.
\item \textit{testLogin() } effettua una prova di login, mediante l'inserimento di uno \textit{username} e una \textit{password} corretti, verificando che tali dati siano accettati correttamente.
\item \textit{testGetUsername()} verifica che, dato uno \textit{username} in input corretto generato come \inglese{stub}, sia possibile recuperarlo correttamente. Se lo \textit{username} non è una mail valida, o non è inserito nella \inglese{form}, il test verifica che venga sollevata un'eccezione.
\item \textit{testGetPassword() } verifica che, data una \textit{password} in input corretta generata come \inglese{stub}, sia possibile recuperarla correttamente.Se la \textit{password} non è inserita nella \inglese{form}, il test verifica che venga sollevata un'eccezione.
\item \textit{testHide()} controlla che venga correttamente nascosto il \inglese{form} di \textit{login} dopo l'effettiva autenticazione o di richiesta di registrazione.
\item \textit{testBuildRetrivePasswordForm()} tale test verifica la corretta creazione della form richiamata per il recupero della password tramite risposta segreta, successivamente controlla che venga richiamata la domanda correttamente impostata a cui rispondere.
\item \textit{testHasAnsweredCorrectly()} tale test verifica la corretta ricezione della risposta segreta (e la correttezza della risposta stessa) associata per il recupero password. Viene inoltre effettuato un test di negazione della stessa.
\end{itemize}
\textbf{Risultato del test:} non sono stati rilevati errori.

\subsubsection{MainPanelPresenterTest}
\textbf{Verifica l'oggetto:} \textit{MainPanelPresenter}.\\
\textbf{Descrizione}:l'obbiettivo di questo test è verificare la corretta creazione del sotto-albero che ha radice nell'elemento \textit{MainPanel} e che il contenuto dei vari nodi sia stato inserito coerentemente, infine deve consentire la corretta visualizzazione dei sotto-pannelli.\\\\
Tale verifica è composta da tre test:
\begin{itemize}
\item \textit{testInitialize() } mediante diversi metodi \textit{equal} controlla l'effettiva correttezza della \inglese{form} creata, sia nella forma che nel funzionamento.
\item \textit{testDisplayChildPanel() } verifica la corretta visualizzazione di un elemento interno al pannello principale.
\item \textit{testHide() } controlla che venga correttamente nascosto il \inglese{form} principale prima dell'autenticazione.
\end{itemize}

\subsubsection{MessagePanelPresenterTest}
\textbf{Verifica l'oggetto:} \textit{MessagePanelPresenter}.\\
\textbf{Descrizione}: l'obbiettivo di questo test è verificare la corretta creazione del sotto-albero che ha radice nell'elemento \textit{MessagePanel} e che il contenuto dei vari nodi sia stato inserito coerentemente.\\
Tale verifica è composta da un solo test:
\begin{itemize}
\item \textit{testCreatePanel()} crea l'elemento \textit{MessagePanel} e estrae la lista dei figli del pannello verificando che contenga due figli:il primo dev'essere di tipo \textit{video} mentre il secondo di tipo \textit{div}.
Successivamente estraggo la lista dei figli del primo figlio (il suo figlio deve essere \textit{source}) e del secondo figlio (il cui figlio deve essere \textit{ul}).
\end{itemize}
\textbf{Risultato del test:} non sono stati rilevati errori.

\subsubsection{RegisterPanelPresenterTest}
\textbf{Verifica l'oggetto:} \textit{RegisterPanelPresenter}.\\
\textbf{Descrizione}:l'obbiettivo di questo test è verificare la corretta creazione del sotto-albero che ha radice nell'elemento \textit{RegisterPanel}, la possibilità di nascondere correttamente l'elemento \textit{RegisterPanel}, il corretto recupero dei dati inseriti nella \inglese{form} d'iscrizione e infine i test relativi al recupero delle singole informazioni passate in fase di registrazione.\\
Tale verifica è composta da dieci test:
\begin{itemize}
\item \textit{testInitialize() } mediante diversi metodi \texttt{equal} controlla l'effettiva correttezza della \inglese{form} creata, sia nella forma che nel funzionamento.
\item \textit{testHide() } controlla che venga correttamente nascosto il \inglese{form} di registrazione.
\item \textit{testRegister() } mediante diversi metodi \texttt{equal} controlla l'effettiva registrazione dei dati inseriti nella \inglese{form}, confrontandoli con quelli passati in ingresso.
\item \textit{testGetPicturePath()} crea una \inglese{form} compilata correttamente con l'immagine utente da inserire, successivamente prova a recuperarla mediante \texttt{getPicturePath}, verificando se è stata inserita correttamente (o meno).
\item \textit{testGetUsername() } crea una \inglese{form} compilata correttamente con lo \textit{username}, e prova a recuperarlo mediante \texttt{getUsername}, verificando se è stato inserito correttamente (o meno).
\item \textit{testGetPassword()} crea una \inglese{form} compilata correttamente con il campo \textit{password}, e prova a recuperarlo mediante \texttt{getPassword}, verificando se è stata inserita correttamente (o meno). Il test verifica anche il sollevamento di un'eccezione nel momento in cui non sia stata inserito alcun valore in questo campo.
\item \textit{testGetQuestion()}  crea una \inglese{form} compilata correttamente con il campo \textit{question}, e prova a recuperarlo mediante \texttt{getQuestion}, verificando se è stata inserita correttamente (o meno). Dal momento che si tratta di un dato obbligatorio, il test verifica anche che sia sollevata un'eccezione nel caso in cui non sia fornito alcun valore.
\item \textit{testGetAnswer() } crea una \inglese{form} compilata correttamente con il campo \textit{answer}, e prova a recuperarlo mediante \texttt{getAnswer}, verificando se è stata inserita correttamente (o meno). Dal momento che si tratta di un dato obbligatorio, il test verifica anche che sia sollevata un'eccezione nel caso in cui questo valore non sia fornito.
\item \textit{testGetName() }  crea una \inglese{form} compilata correttamente con il campo \textit{name}, e prova a recuperarlo mediante \texttt{getName}, verificando se è stato inserito correttamente (o meno).
\item \textit{testGetSurname() }  crea una \inglese{form} compilata correttamente con il campo \textit{surname}, e prova a recuperarlo mediante \texttt{getSurname}, verificando se è stata inserita correttamente (o meno).

\end{itemize}
\textbf{Risultato del test:} non sono stati rilevati errori.

\subsubsection{SearchResultPanelPresenterTest}
\textbf{Verifica l'oggetto:} \textit{SearchResultPanelPresenter}.\\
\textbf{Descrizione}: l'obiettivo di questo test è verificare che sia correttamente creato l'elemento grafico \textit{SearchResultPanel} e il comportamento del presenter nel momento in cui tale pannello deve essere aggiornato. Tale verifica è composta da 2 test:
\begin{itemize}
\item \textit{testCreatePanel() } verifica che il pannello sia costruito e visualizzato in accordo con le specifiche della progettazione e, in particolare, che sia presente la lista dei contatti che corrispondono ai risultati della ricerca.
\item \textit{testDisplayContactList()} verifica che sia visualizzata la lista dei contatti passata come parametro in ingresso al metodo \texttt{displayContactList} del presenter.
\end{itemize}

\subsubsection{ToolsPanelPresenterTest}
\textbf{Verifica l'oggetto:} \textit{ToolsPanelPresenter}.\\
\textbf{Descrizione}: l'obiettivo di tale test è verificare che sia correttamente creato il pannello degli strumenti dell'interfaccia grafica, nonché il comportamento del presenter nel momento in cui dalla vista è invocato il metodo che corrisponde all'uscita dal sistema.
Tale verifica è composta da 3 test:
\begin{itemize}
\item \textit{testInitialize() } mediante diversi metodi \textit{equal} controlla l'effettiva correttezza della \inglese{form} creata, sia nella forma che nel funzionamento;
\item \textit{testHide() } controlla che venga correttamente nascosto il \inglese{form} degli strumenti;
\item \textit{testLogout() } controlla l'effettivo \inglese{logout} dell'utente autenticato al sistema.
\end{itemize}
\clearpage

\section{Test Coverage}
Tale test è stato effettuato mediante il \underline{\inglese{plugin}} per Eclipse \textit{eclemma} per la parte Java (quindi nel \textit{Model}) e con \textit{JSCoverage} per la parte \textit{JavaScript} (per il \textit{Presenter}) definendo quindi le percentuali di codice che è stato sottoposto a test per i singoli componenti dell'applicazione.\\\\

\begin{center}
\rowcolors{2}{lightblue}{llightblue}\begin{longtable}{p{.30\textwidth}ll}
\toprule Componente & Copertura\\
\midrule
Model & X\%\\
Presenter & 53,72\% \\
\bottomrule
\end{longtable}
\end{center}

La percentuale di copertura rilevata è relativamente bassa nella parte \textit{Model}, tale risultato si giustifica dal numero elevato di metodi \textit{getter} e \textit{setter} che non sono stati tutti analizzati tramite test di unità (ma prelevati e verificati a campione), ma solo tramite analisi statica del codice. Per la parte \textit{Presenter} al contrario si può ricondurre il risultato alle numerose funzioni anonime impossibili da testare e invocate soltanto durante l'effettivo funzionamento dell'applicazione.

\section{Test di Sistema}
Nell'attività di validazione che verrà affrontata nella successiva (e ultima) fase del progetto, saranno effettuati i test per accertare le effettive funzionalità offerte dal prodotto \caName.\\ Tali verifiche sono state definite e pianificate già durante l'attività di analisi dei requisiti e sono reperibili nel documento relativo allegato (\textit{analisi\_dei\_requisiti.3.0.pdf}) in cui sono elencati in una pratica tabella che ne descrive (per ognuno) le modalità di verifica e i requisiti ad essi associati. In questo modo verrà assicurato il tracciamento tra requisiti e test, pertanto tutti i requisiti soddisfatti saranno verificati mediante un test specifico.

\section{Test di Utilizzo}
Al fine di verificare che l'interfaccia del prodotto sia più intuitiva e \inglese{user-friendly} possibile, sono stati predisposte delle simulazioni da proporre ad un campione di utenza selezionata (cinque persone con conoscenze informatiche medio-basse).
Essendo test non oggettivi non verranno catalogati come vere e proprie verifiche, ma saranno semplici \inglese{feedback} su come migliorare o confermare la parte visiva di \caName in base ai comportamenti assunti dai \inglese{tester} durante la prova.
\end{document}