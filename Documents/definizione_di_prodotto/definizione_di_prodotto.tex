% ATTENZIONE!!! 
% Per far funzionare i collegamenti ipertestuali si raccomanda di usare
%	\classname{nomedellaclasse}
% per le classi dello stesso package mentre invece 
%	\hyperref[nomedellaclasse]{\ttfamily{}nomequalificatodellaclasse}
% per le classi che non sono dello stesso package e che hanno il nome completo

% **************************************************
% Macro specifiche per il documento corrente
% **************************************************
% Nome
\newcommand{\docName}{Definizione di prodotto}
% Nome file
\newcommand{\docFileName}{definizione\_di\_prodotto.2.0.pdf}
% Versione
\newcommand{\docVers}{2.0}
% Data creazione
\newcommand{\creationDate}{2013-03-04}
% Data ultima modifica
\newcommand{\modificationDate}{2013-03-19}
% Stato in {Approvato, Non approvato}
\newcommand{\docState}{Approvato}
% Uso in {Interno, Esterno}
\newcommand{\docUsage}{Esterno}
% Destinatari da specificare come nome1\\ &nome2\\ ecc.
\newcommand{\docDistributionList}{Prof. Tullio Vardanega\\&Prof. Riccardo Cardin\\&Dott. Gregorio Piccoli\\&Team SoftwareSynthesis}
% Redattori da specificare come nome1\\ &nome2\\ ecc.
\newcommand{\docAuthors}{Andrea Rizzi\\&Elena Zecchinato\\&Marco Schivo \\&Stefano Farronato}
% Approvato da
\newcommand{\approvedBy}{Marco Schivo}
% Verificatori
\newcommand{\verifiedBy}{Andrea Meneghinello}
% Perscorso (relativo o assoluto) che punta alla directory contenente shared/
% come sua sottodirectory (per comodità chiamiamola 'doc root').
\newcommand{\docRoot}{..}
% definire se si vuole l'indice delle tabelle
\def\INDICETABELLE{false}
% definire se si vuole l'indice delle figure
\def\INDICEFIGURE{false}

% importa il preambolo condiviso da tutti i documenti
\input{\docRoot/shared/preamble.tex}

% macro specifiche per il documento corrente
\newcommand{\classsection}[1]{\subsubsection{#1}\label{#1}}
\newcommand{\classname}[1]{\hyperref[#1]{\ttfamily#1}}

% Fine del preambolo e inizio del documento
\begin{document}

% Inclusione della prima pagina
\input{\docRoot/shared/firstpage.tex}

%---------------------------RUOLI----------------------------
%FASE 1:
%Progettisti: STEFANO,RIZZI,SCHIVO,ELENA

%VerificatorI: MENE,TRES
%Responsabile finale supremo: DIEGO
%------------------------------------------------------------

% Storico delle modifiche
\section*{Storia delle modifiche}
\begin{center}
\begin{longtable}{lp{.32\textwidth}lll}
\toprule
Versione & Descrizione intervento & Membro & Ruolo & Data\\
\midrule % inserire qui il contenuto della tabella
1.0 & Approvazione documento &Diego Beraldin &Responsabile  & 2013-03-09\\
0.10 & Correzioni errori rilevati da verificatori &Schivo Marco  &  Progettista& 2013-03-08\\
0.9 & Verifica totale documento &Andrea Meneghinello & Verificatore & 2013-03-08\\
0.8 & Descritto classi di abook.authentication, server.authentication.servlet, server.connection & Elena Zecchinato &  Progettista& 2013-03-07\\
0.7 & Descritto PresenterMediator, CallHistoryPanelPresenter, SearchResultPanelPresenter, ToolsPanelPresenter, AccountSettingsPanelPresenter &Schivo Marco &  Progettista& 2013-03-07\\
0.7 & Descritto AddressBookPanelPresenter, GroupPanelPresenter, LoginPanelPresenter &Schivo Marco &  Progettista& 2013-03-06\\
0.6 & Descritto classi di server.abook.servlet, server.call, server.message &Elena Zecchinato &  Progettista& 2013-03-06\\
0.5 & Descritto RegisterPanelPresenter, CommunicationPanelPresenter, ContactPanelPresenter, MainPanelPresenter &Stefano Farronato &  Progettista& 2013-03-05\\
0.4 & Descritte classi package server.dao e server.abook &Andrea Rizzi &  Progettista& 2013-03-05\\
0.3 & Inizio descrizione parte clientpresenter &Stefano Farronato &  Progettista& 2013-03-04\\
0.2 & Stesura sezione ``Standard di progetto'' ed inizio descrizione server &Andrea Rizzi &  Progettista& 2013-03-04\\
0.1 & Creazione del documento e stesura delle sezioni ``Introduzione'' e ``Riferimenti'' &Elena Zecchinato &Progettista  & 2013-03-04\\
\bottomrule
\end{longtable}
\end{center}
\newpage

% inclusione dell'indice
\input{\docRoot/shared/toc.tex}

% Alcuni aggiustamenti per le pagine
\pagenumbering{arabic}
\setcounter{page}{1}
\pagestyle{normal}

% Qui ha inizio il documento vero e proprio...
\newpage

\section{Introduzione}
\subsection{Scopo del prodotto}
\purpose

\subsection{Scopo del documento}
Il presente documento presenta una descrizione dettagliata dell'architettura del sistema software destinata alla realizzazione del prodotto \caName{} coerentemente con la progettazione ad alto livello descritta nell'allegato \textit{specifica\_tecnica.2.0.pdf}.

A tal fine si riporta per ognuno dei componenti definiti nel documento di specifica tecnica una descrizione delle classi in termini di operazioni disponibili, proprietà, responsabilità e collaborazioni. Il contenuto del presente documento ha inoltre valore vincolante per i programmatori, pertanto avranno l'obbligo di attenersi alle disposizioni in esso contenute senza alcuna possibilità di deroga.

\subsection{Glossario}
\glossaryIntro

\subsection{Convenzioni di scrittura}
% vedere issue #56 al riguardo
Al fine di rendere quanto più agevole possibile la consultazione del documento da parte dei programmatori e del committente, è stata adottata una serie di accorgimenti sia a livello di riferimenti sulla nomenclatura delle classi sia a livello cromatico per campi dati e metodi. 
Tali norme possono essere consultate in dettaglio nel documento \textit{norme\_di\_progetto.3.0.pdf} allegato.
\clearpage

\section{Riferimenti}
\subsection{Normativi}
\begin{itemize}
\item[] \textit{piano\_di\_qualifica.3.0.pdf} allegato.
\item[] \textit{norme\_di\_progetto.3.0.pdf} allegato.
\item[] \textit{specifica\_tecnica.2.0.pdf} allegato
\end{itemize}

\subsection{Informativi}
\begin{itemize}
\item[] Capitolato d'appalto: \caName{}, v1.0, redatto e rilasciato dal proponente Zucchetti s.r.l. reperibile all'indirizzo \url{http://www.math.unipd.it/~tullio/IS-1/2012/Progetto/C1.pdf};
\item[] testo di consultazione: \textit{Software Engineering (8th edition) Ian Sommerville, Pearson Education | Addison Wesley};
\item[] manuale all'utilizzo dei design pattens: \textit{Design Patterns, Elementi per il riuso di software a oggetti -- (1/Ed. italiana) Eric Gamma, Richard Helm, Ralph Johnson, John Vlissides, Pearson Education};
\item[] \textit{glossario.3.0.pdf} allegato.
\end{itemize}
\clearpage

\section{Standard di progetto}

\subsection{Standard di progettazione architetturale}
Lo sviluppo del progetto ha seguito le regole architetturali specificate nel documento  \textit{norme\_di\_progetto.3.0.pdf} allegato.

\subsection{Standard di documentazione del codice}
Le regole che definiscono la documentazione del codice relativo al funzionamento del prodotto sono specificate nel documento \textit{norme\_di\_progetto.3.0.pdf} allegato.

\subsection{Standard di denominazione di entità e relazioni}
Le convenzioni relative alla denominazione delle entità e le relative relazioni sono specificate nel documento \textit{norme\_di\_progetto.3.0.pdf} allegato.

\subsection{Standard di programmazione}
Le regole relative agli standard di programmazione sono enunciate nel documento \textit{norme\_di\_progetto.3.0.pdf} allegato.

\subsection{Strumenti di lavoro}
Gli strumenti utilizzati per la stesura e lo sviluppo sono specificati nei documenti \textit{norme\_di\_progetto.3.0.pdf} e \textit{piano\_di\_qualifica.3.0.pdf} allegati.

\clearpage

\section{Specifica sotto-architettura sever}\label{sec:serverarchitecture}

\subsection{Package org.softwaresynthesis.mytalk.server}\label{sec:server}

\classsection{IMyTalkObject}

\subsubsection*{Funzione}
Interfaccia usata per rappresentare un \texttt{transfer object} mappato mediante \texttt{Hibernate}.

\subsubsection*{Relazioni d'uso}

Nessuna relazione evidenziata

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Metodi}
\begin{description}
	\item{\method{\underline{+ getId(): Long}}}\\
	Restituisce l'identificativo dell'oggetto.
	\item{\method{\underline{+ setId(id: Long): void}}}\\
	Imposta l'identificativo dell'oggetto.
\end{description}

\classsection{IController}

\subsubsection*{Funzione}
Interfaccia rappresentante il comportamento di un generico \inglese{controller}.

\subsubsection*{Relazioni d'uso}

Nessuna relazione evidenziata

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Metodi}
\begin{description}
	\item{\method{-- execute(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Metodo usato per l'esecuzione del comando associato al \inglese{controller}.
\end{description}

\classsection{AbstractController}

\subsubsection*{Funzione}
Implementazione di \classname{IController}. Classe astratta che rappresenta un generico controller. Richiede la ridefinizione del metodo \method{doAction()} da parte delle classi figlie.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dal metodo\method{doAction()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doAction()}. Usata per scrivere l'output della \inglese{servlet}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doAction()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \classname{authentication.security.ISecurityStrategy}: usata per la criptazione dei dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

\begin{itemize}
	\item \classname{IController}: interfaccia d'implementazione.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato

\subsubsection*{Metodi}

\begin{description}
	\item{\method{-- check(request: HttpServletRequest): boolean}}\\
	Metodo usato per verificare se l'utente che richiede l'esecuzione di un operazione, è autenticato nel sistema. Il metodo definisce inizialmente una variabile booleana result, usata per ritornare una segnalazione della buona riuscita del metodo. result è impostata di \inglese{default} a \inglese{true}. Quindi si procede controllando se la mail dell'utente (\memberdata{userMail}) corrisponde a quella presente nel campo username della sessione corrente (session.getAttribute(''username'')). se il \inglese{match} è negativo, result viene impostata a \inglese{false}. Il metodo termina ritornando il contenuto di result.
	\item{\method{-- execute(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Il metodo inizia definendo un oggetto \texttt{PrintWriter} writer. Quindi viene effettuato un controllo sul richiedente mediante il richiamo del metodo \method{check()}. Se tale metodo ritorna \inglese{true} allora il flusso principale prosegue richiamando il metodo \method{doAction}. In caso contrario il metodo termina salvando nel \texttt{writer} il valore ''null''.
\end{description}

\classsection{ControllerManager}

\subsubsection*{Funzione}
Estensione di \texttt{org.apache.catalina.websocket.WebSocketServlet} ed implementazione di \inglese{servlet}. ControllerManager rappresenta l'implementazione del pattern \texttt{front controller}. Esso fornisce un unico punto d'accesso al sistema. Tale implementazione avviene definendo la classe come una \inglese{servlet} il cui compito sarà quello di delegare al controller corretto la richiesta inoltrata dal client.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione sollevabile in seguito ad un errato input utente;
	\item \texttt{java.util.Enumeration}: usata per definire gli attributi usati dalla classe;
	\item \texttt{java.util.HashMap}: usata per definire gli attributi usati dalla classe;
	\item \texttt{java.util.Hashtable}: usata per definire gli attributi usati dalla classe;
	\item \texttt{java.util.Map}: usata per definire gli attributi usati dalla classe;
	\item \texttt{java.util.ResourceBundle}: usata per definire gli attributi usati dalla classe;
	\item \texttt{javax.servlet.ServletConfig}: usata per eseguire delle operazioni di configurazione della \inglese{servlet};
	\item \texttt{javax.servlet.ServletException}: eccezione che può essere sollevata in seguito all'esecuzione del metodo \method{doPost()} della classe;
	\item \texttt{javax.servlet.annotation.WebServlet}: classe necessaria per il corretto funzionamento della \inglese{servlet};
	\item \texttt{javax.servlet.http.HttpServletRequest}: usata per le richieste ajax inoltrate dal client alla \inglese{servlet};
	\item \texttt{javax.servlet.http.HttpServletResponse}: usata per le richieste ajax inoltrate dal client alla \inglese{servlet};
	\item \texttt{org.apache.catalina.websocket.StreamInbound}: classe generica che definisce un canale di comunicazione client-client;
	\item \texttt{org.softwaresynthesis.mytalk.server.connection.PushInbound}: specializzazione della classe \texttt{org.apache.catalina.websocket.StreamInbound};
	\item \texttt{org.softwaresynthesis.mytalk.server.connection.PushInbound.State}: classe atta a definire lo stato di un canale di comunicazione, usata per gestire lo stato dell'utente connesso.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

\begin{itemize}
	\item \classname{javax.servlet.Servlet}: interfaccia d'implementazione.
	\item \classname{org.apache.catalina.websocket.WebSocketServlet}: classe estesa.
\end{itemize}

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{\underline{-- serialVersionUID: long}}}\\
	Attributo usato per definire un id univoco alla \inglese{servlet}.
	\item{\memberdata{-- clients: Map<Long, PushInbound>}}\\
	Map usata per definire un associazione tra gli utenti connessi (riconosciuti mediante ID) e i \classname{PushInbound} a loro associati.
	\item{\memberdata{-- controllers: Hashtable<String, String>}}\\
	Hashtablet usata per mappare le associazioni funzionalità-controller associato.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ ControllerManager(): void}}\\
	Costruttore pubblico della \inglese{servlet}. Inizializza \memberdata{controllers}.
	
	\item{\method{+ getControllers(): Hashtable<String, String>}}\\
	Metodo usato per ottenere il contenuto del campo \memberdata{controllers}. Il metodo restituisce \memberdata{controllers}.
	
	\item{\method{+ createController(classPath: string): IController}}\\
	Metodo usato per creare una nuova istanza di uno specifico controller a partire dal nome \texttt{classPath}. A tale scopo lo sviluppatore dovrà usare il metodo forName di \texttt{Class}, passando per l'appunto il nome della classe. Successivamente a partire da tale classe, sarà creata un istanza di \classname{IController}. Il metodo termina restituendo l'istanza di \classname{IController}. Si osservi che la firma del metodo dovrà specificare la possibilità che vengano invocate le seguenti eccezioni:
	\begin{itemize}
		\item \texttt{ClassNotFoundException}: se la classe non viene trovata dal class loader;
		\item \texttt{IllegalAccessException}: se non si hanno i privilegi di accesso a tale classe;
		\item \texttt{InstantiationException}: se non si riesce ad instanziare un oggetto di tale classe;
	\end{itemize}
	
	Tali eccezioni possono essere invocate a causa di un errato utilizzo di \texttt{Class}.
	
	\item{\method{+ init(configuration: ServletConfiguration): void}}\\
	Metodo usato per inizializzare la \inglese{servlet} caricando in memoria la lista dei controller. Il metodo inizia richiamando l'init di super. Quindi crea un istanza di \texttt{ResourceBundler} a partire da una chiamata a metodo \texttt{ResorceBundler.getBundler()} (passando come parametro la stringa: ''org.softwaresynthesis.mytalk.server.controllerList''). Il passo successivo consiste nel creare un oggetto di tipo \texttt{Enumeration<String>} (nominato keys), in cui salvare ciò che viene restituito da una chiamata a getKeys() (chiamato a partire dall'istanza di \texttt{ResorceBundler}). A questo punto si attuerà, all'interno di un ciclo \verb|while(keys.hasMoreElements())|, una procedura atta a salvare in controllers le coppie chiave-valore contenute in keys.
	
	\item{\method{+ destroy(): void}}\\
	Metodo usato per eliminare il contenuto di \memberdata{controllers}. Si dovrà usare il metodo \texttt{clear()} di \memberdata{controllers}.
	
	\item{\method{\# createWebSocketInbound(): StreamInbound}}\\
	Metodo usato per creare un canale di comunicazione di tipo \classname{PushInbound}. Il metodo dovrà impostare mediante setState, lo stato del canale al valore \verb|State.AVAILABLE|. Il metodo ritorna il canale di comunicazione cosi creato.
	
	\item{\method{+ putClient(n: Long, c: PushInBound): void}}\\
	Metodo usato per aggiungere in \memberdata{clients} la coppia idUtente (n) - canale PushInBound di comunicazione (c). Il metodo è composto dall'unica istruzione \verb|clients.put(n,c)|.
	
	\item{\method{+ removeClient(c: PushInbound): void}}\\
	Metodo usato per rimuovere un client dall'attributo \memberdata{clients}. Il metodo scorre il contenuto dell'attributo verificando con un costrutto if, la presenza del canale \texttt{PushInbound} c. Se lo trova, rimuove il client associato a c da \memberdata{clients}.
	
	\item{\method{\underline{+ getState(identifier: Long): String}}}\\
	Il metodo definisce una \texttt{String} result da restituire alla fine del metodo stesso. Dopo la creazione, il metodo cerca di ottenere da \memberdata{clients}, il cliente avente id uguale ad identifier. Quindi se tale client esiste realmente, il metodo procede ottenendo lo stato in cui si trova il client (client.getState()) e richiamando il suo metodo \texttt{toString()}, salva il suo valore in result. Se l'utente con id identifier non esiste in \memberdata{clients}, result = ''offline''. Il metodo termina restituendo result;
	
	\item{\method{\# doPost(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Metodo doPost() della servlet. Tale metodo è l'unico invocato direttamente dall'esterno da parte di un client, mediante un richiasta \texttt{HttpServletRequest}. Il metodo definisce localmente un \classname{IController} in cui memorizzare il controller a cui delegare l'operazione richiesta dal client (che per l'appunto ha invocato il ControllerManager). All'interno di un costrutto try-catch (nel blocco try), si memorizza l'operazione contenuta in request mediante un getParameter(''operation''). Tale sintassi è obbligatoria. Quindi se l'operazione impostata è diversa da \inglese{null}, si procede ricercando in \memberdata{controllers} il controller avente come chiave il valore di tipo String specificato come operazione richiesta dall'utente. A questo punto si crea il controller giusto (usando il metodo \method{createController(controllerName)}) e si richiama il suo metodo \texttt{execute()} passando come parametri request e response. I catch del blocco try-catch, atti a definire del blocchi per catturare le eccezioni: 
	\begin{itemize}
		\item \texttt{ClassNotFoundException};
		\item \texttt{IllegalAccessException};
		\item \texttt{InstantiationException};
	\end{itemize}
	
	hanno al loro interno delle procedure per scrivere l'ora e il nome dell'errore (inteso come nome dell'eccezione sollevata) in un file di log. Non sono fatte ulteriori segnalazioni di errore al client, poiché al fine sarà la chiamata controller.execute() (fatta in precedenza e eventuale causa del sollevamento delle eccezioni), a restituire al client una segnalazione dell'errore riscontrato. Il metodo termina distruggendo l'oggetto \classname{IController} creato per la gestione della richiesta.
	
\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.dao}\label{sec:dao}

\classsection{ISessionManager}

\subsubsection*{Funzione}
Interfaccia rappresentante il comportamento di un generico classe adibita alla creazione e alla gestione delle sessioni \texttt{Hibernate}.

\subsubsection*{Relazioni d'uso}

Nessuna relazione evidenziata

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.


\subsubsection*{Metodi}
\begin{description}
	\item{\method{\underline{+ getInstance(): ISessionManager}}}\\
	Metodo d'implementazione del pattern \texttt{Singleton}. Usato per restituire l'unica istanza creabile.
	\item{\method{\underline{+ getSessionFactory(): SessionFactory}}}\\
	Metodo usato per ottenere una sessione verso il database gestito mediante \texttt{Hibernate}.
\end{description}

\classsection{SessionManager}

\subsubsection*{Funzione}
Implementazione di \classname{ISessionManager}. Inizializza un'unica \inglese{factory} per le sessioni, utilizzate da \textit{Hibernate}, per comunicare con il database.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \classname{org.hibernate.SessionFactory}: necessaria per interrogare il database.
	\item \classname{org.hibernate.cfg.Configuration}: definisce i parametri necessari per la connessione con il database. Inoltre definisce i \textit{mapping} necessari tra le classi \inglese{transfer object} e le relative tabelle nel database.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

\begin{itemize}
	\item \classname{dao.ISessionManager}: interfaccia d'implementazione del package \textit{dao} usata per definire il comportamento di un generico gestore Hibernate. Con gestore Hibernate intendiamo una classe in grado di creare delle sessioni con il database.
\end{itemize}

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{\underline{-- instance: ISessionManager}}}\\
	Attributo usato per implementare il \inglese{pattern} singleton. Tale istanza verrà inizializzata tramite il metodo statico \method{getIstance()}, assicurando che l'attributo non sia già stato inizializzato in precedenza.
	\item{\memberdata{-- sessionFactory: SessionFactory}}\\
	Attributo contenente la \inglese{factory} delle sessioni verso il database.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{-- SessionManager()}}\\
	Costruttore privato della classe, definito \inglese{private} in correlazione all'applicazione del \inglese{pattern} singleton.
	\item{\method{\underline{+ getInstance(): SessionManager}}}\\
	Metodo pubblico che ritorna l'istanza \memberdata{istance}. Il metodo controlla se \memberdata{istance} è già stata inizializzata, nel caso in cui non lo sia il metodo dovrà generare un istanza di SessionManager richiamando il costruttore privato \method{SessionManager()} e assegnare il valore ritornato all'attributo \memberdata{istance}. Il programma termina restituendo \memberdata{istance}.
	\item{\method{\underline{+ getSessionFactory(): SessionFactory}}}\\
	Metodo che ritorna l'attributo \memberdata{sessionFactory}.
\end{description}

\classsection{DataPersistanceManager}

\subsubsection*{Funzione}
Classe che rappresenta un punto d'accesso al database del sistema. Implementata mediante le funzionalità di \texttt{Hibernate}, la classe permette di attuare operazioni \texttt{CRUD} sulle tabelle della base di dati.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{org.softwaresynthesis.mytalk.server.IMyTalkObject};
	\item \texttt{org.softwaresynthesis.mytalk.server.abook.IGroup};
	\item \texttt{org.softwaresynthesis.mytalk.server.abook.IUserData};
	\item \texttt{org.softwaresynthesis.mytalk.server.dao.util.GetUtil};
	\item \texttt{org.softwaresynthesis.mytalk.server.dao.util.ModifyUtil};
	\item \texttt{org.softwaresynthesis.mytalk.server.dao.util.UtilFactory};
	\item \texttt{org.softwaresynthesis.mytalk.server.message.IMessage};
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{-- manager: ISessionManager}}\\
	Attributo usato per mantenere un riferimento alla singola istanza di SessionManagaer (estensione di \classname{ISessionManagaer}.
	\item{\memberdata{-- factory: UtilFactory}}\\
	Attributo usato per mantenere un riferimento ad un'istanza di UtilFactory, usata per l'esecuzione delle operazioni relative alla manipolazione dei dati.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ DataPersistanceManager()}}\\
	Costruttore pubblico della classe. Richiama il costruttore \method{DataPersistanceManager(ISessionManager manager, UtilFactory factory} passando come parametri \texttt{SessionMAnager.getIstance()} e una nuova istanza di \classname{UtilFactory}.
	
	\item{\method{\# DataPersistanceManager(manager: ISessionManager, factory: UtilFactory)}}\\
	Costruttore protetto della classe. Inizializza gli attributi della classe con i parametri d'ingresso.
	
	\item{\method{+ delete(object: IMyTalkObject): boolean}}\\
	Metodo per la manipolazione dei dati. Nello specifico permette di eseguire un operazione di eliminazione in una delle tabelle del database (tabella corrispondente all'oggetto object: IMyTalkObject). Il metodo definisce una variabile result di tipo \texttt{boolean} usata per evidenziare la buona riuscita o meno dell'operazione. Di default result è impostata a \inglese{false}. Il metodo crea un istanza di \classname{ModifyUtil} a partire da una chiamata \verb|this.factory.getDeleteUtil(this.manager)|. Quindi si salva in result il valore ritornato dall'operazione \verb|execute(object)| (dove object, parametro d'ingresso del metodo, rappresenta la tabella su cui eseguire l'operazione). \verb|execute(object)| è richiamata a partire dall'istanza \classname{ModifyUtil} creata in precedenza). Il metodo deve terminare ritornando il valore di result.
	
	
	\item{\method{+ insert(object: IMyTalkObject): boolean}}\\
	Metodo per la manipolazione dei dati. Nello specifico permette di eseguire un operazione di inserimento in una delle tabelle del database (tabella corrispondente all'oggetto object: IMyTalkObject). Il metodo definisce una variabile result di tipo \texttt{boolean} usata per evidenziare la buona riuscita o meno dell'operazione. Di default result è impostata a \inglese{false}. Il metodo crea un istanza di \classname{ModifyUtil} a partire da una chiamata \verb|this.factory.getInsertUtil(this.manager)|. Quindi si salva in result il valore ritornato dall'operazione \verb|execute(object)| (dove object, parametro d'ingresso del metodo, rappresenta la tabella su cui eseguire l'operazione). \verb|execute(object)| è richiamata a partire dall'istanza \classname{ModifyUtil} creata in precedenza). Il metodo deve terminare ritornando il valore di result.
	
	\item{\method{+ update(object: IMyTalkObject): boolean}}\\
	Metodo per la manipolazione dei dati. Nello specifico permette di eseguire un operazione di modifica dei campi dati di una delle tabelle del database (tabella corrispondente all'oggetto object: IMyTalkObject). Il metodo definisce una variabile result di tipo \texttt{boolean} usata per evidenziare la buona riuscita o meno dell'operazione. Di default result è impostata a \inglese{false}. Il metodo crea un istanza di \classname{ModifyUtil} a partire da una chiamata \verb|this.factory.getUpdateUtil(this.manager)|. Quindi si salva in result il valore ritornato dall'operazione \verb|execute(object)| (dove object, parametro d'ingresso del metodo, rappresenta la tabella su cui eseguire l'operazione). \verb|execute(object)| è richiamata a partire dall'istanza \classname{ModifyUtil} creata in precedenza). Il metodo deve terminare ritornando il valore di result.
	
	\item{\method{+ getGroup(id: Long): IGroup}}\\
	Metodo usato per l'esecuzione di una query SQL atta ad garantire la restituzione dei dati inerenti il gruppo avente come primary key il valore contenuto in id. Il metodo definisce un istanza di \classname{GetUtil} mediante una chiamata \verb|this.factory.getGroupUtil(this.manager)|. Quindi definisce un oggetto \classname{IGroup} denominato result. Successivamente si definisce una lista \texttt{List<IMyTalkObject>}, da usare per memorizzare temporaneamente i dati ottenuti dall'esecuzione della query:\\
	
	\verb|from Groups as g where g.id = VALORE_id|\\
	
	Tale operazione si ottiene con l'istruzione \verb|select.execute(query)|. Quindi si controlla se la lista cosi popolata contiene almeno un elemento (che per come è stata progettata la query, ossia un interrogazione su chiave primaria, deve essere al più uno). Nel caso si imposta result con una chiamata a metodo get() richiamato dalla lista usata. Il metodo termina restituendo result.
	
		\item{\method{+ getGroup(owner: IUserData): List<IGroup>}}\\
	Metodo usato per l'esecuzione di una query SQL atta ad garantire la restituzione dei gruppi aventi come possessore l'utente owner. Il metodo definisce un istanza di \classname{GetUtil} mediante una chiamata \verb|this.factory.getGroupUtil(this.manager)|. Quindi definisce un oggetto \classname{IGroup} denominato result. Successivamente si definisce una lista \texttt{List<IMyTalkObject>}, da usare per memorizzare temporaneamente i dati ottenuti dall'esecuzione della query:\\
	
	\verb|from Groups as g where g.owner = VALORE_owner|\\
	
	Tale operazione si ottiene con l'istruzione \verb|select.execute(query)|. Quindi si controlla se la lista cosi popolata contiene almeno un elemento. Nel caso si imposta result uguale alla lista usata. Il metodo termina restituendo result.
	
	\item{\method{+ getMessageNewKey(): Long}}\\
	Metodo usato per l'esecuzione di una query SQL atta ad garantire la restituzione della più alta chiave primaria usata nella tabella \texttt{message}. Il metodo restituirà tale valore maggiorato di 1. Il metodo definisce un istanza di \classname{GetUtil} mediante una chiamata \verb|this.factory.getGroupUtil(this.manager)|. Quindi definisce un oggetto \classname{Long} denominato result. Successivamente si definisce un long nominato id, da usare per memorizzare temporaneamente il dato ottenuto dall'esecuzione della query:\\
	
	\verb|max(id) from Messages|\\
	
	Tale operazione si ottiene con l'istruzione \verb|select.execute(query)|. Quindi si controlla se la variabile id contiene alemno un elemento. Nel caso si imposta result uguale alla uguale al contenuto di id + 1. Il metodo termina restituendo result.
	
	\item{\method{+ getMessage(id: Long): IMessage}}\\
	Metodo usato per l'esecuzione di una query SQL atta a garantire la restituzione dei dati inerenti il messaggio avente come primary key il valore contenuto in id. Il metodo definisce un istanza di \classname{GetUtil} mediante una chiamata \verb|this.factory.getGenericUtil(this.manager)|. Quindi definisce un oggetto \classname{IGroup} denominato result. Successivamente si definisce una lista \texttt{List<IMyTalkObject>}, da usare per memorizzare temporaneamente i dati ottenuti dall'esecuzione della query:\\
	
	\verb|from Messages as m where m.id = VALORE_id|\\
	
	Tale operazione si ottiene con l'istruzione \verb|select.execute(query)|. Quindi si controlla se la lista cosi popolata contiene almeno un elemento (che per come è stata progettata la query, ossia un interrogazione su chiave primaria, deve essere al più uno). Nel caso si imposta result con una chiamata a metodo get() richiamato dalla lista usata. Il metodo termina restituendo result.
	
		\item{\method{+ getMessages(receiver: IUserData): List<IMessages>}}\\
	Metodo usato per l'esecuzione di una query SQL atta ad garantire la restituzione dei messaggi aventi come ricevente l'utente receiver. Il metodo definisce un istanza di \classname{GetUtil} mediante una chiamata \verb|this.factory.getGenericUtil(this.manager)|. Quindi definisce un oggetto \classname{IMessages} denominato result. Successivamente si definisce una lista \texttt{List<IMyTalkObject>}, da usare per memorizzare temporaneamente i dati ottenuti dall'esecuzione della query:\\
	
	\verb|from Messages as m where m.receiver = VALORE_receiver|\\
	
	Tale operazione si ottiene con l'istruzione \verb|select.execute(query)|. Quindi si controlla se la lista cosi popolata contiene almeno un elemento. Nel caso si imposta result uguale alla lista usata. Il metodo termina restituendo result.	
	
	\item{\method{+ getUserData(mail: String): IUserData}}\\
	Metodo usato per l'esecuzione di una query SQL atta a garantire la restituzione dei dati inerenti l'utente avente come indirizzo mail il valore contenuto in mail. Il metodo definisce un istanza di \classname{GetUtil} mediante una chiamata \verb|this.factory.getUserDataUtil(this.manager)|. Quindi definisce un oggetto \classname{IUserData} denominato result. Successivamente si definisce una lista \texttt{List<IMyTalkObject>}, da usare per memorizzare temporaneamente i dati ottenuti dall'esecuzione della query:\\
	
	\verb|from UserData as u where u.mail = VALORE_mail|\\
	
	Tale operazione si ottiene con l'istruzione \verb|select.execute(query)|. Quindi si controlla se la lista cosi popolata contiene almeno un elemento (che per come è stata progettata la query, ossia un interrogazione su chiave primaria, deve essere al più uno). Nel caso si imposta result con una chiamata a metodo get() richiamato dalla lista usata. Il metodo termina restituendo result.	
	
	\item{\method{+ getUserData(id: Long): IUserData}}\\
	Metodo usato per l'esecuzione di una query SQL atta a garantire la restituzione dei dati inerenti l'utente avente come chiave primaria il valore contenuto in id. Il metodo definisce un istanza di \classname{GetUtil} mediante una chiamata \verb|this.factory.getUserDataUtil(this.manager)|. Quindi definisce un oggetto \classname{IUserData} denominato result. Successivamente si definisce una lista \texttt{List<IMyTalkObject>}, da usare per memorizzare temporaneamente i dati ottenuti dall'esecuzione della query:\\
	
	\verb|from UserData as u where u.id = VALORE_id|\\
	
	Tale operazione si ottiene con l'istruzione \verb|select.execute(query)|. Quindi si controlla se la lista cosi popolata contiene almeno un elemento (che per come è stata progettata la query, ossia un interrogazione su chiave primaria, deve essere al più uno). Nel caso si imposta result con una chiamata a metodo get() richiamato dalla lista usata. Il metodo termina restituendo result.
	
	\item{\method{+ getUserDatas(mail: String, name: String, surname: String): List<IUserData>}}\\
	Metodo usato per l'esecuzione di una query SQL atta ad garantire la restituzione degli utenti aventi come valore dei campi omonimi ai parametri del metodo, il valore di quest'ultimi. Il metodo definisce un istanza di \classname{GetUtil} mediante una chiamata \\ \verb|this.factory.getUserDataUtil(this.manager)|. Quindi definisce un oggetto \classname{IUserData} denominato result. Successivamente si definisce una lista \texttt{List<IMyTalkObject>}, da usare per memorizzare temporaneamente i dati ottenuti dall'esecuzione della query:\\
	
	\verb|from UserData as u where u.mail like VALORE_receiver|\\
	\verb|or u.name like VALORE_name or u.surname like VALORE_surname|\\
	
	Tale operazione si ottiene con l'istruzione \verb|select.execute(query)|. Quindi si controlla se la lista cosi popolata contiene almeno un elemento. Nel caso si imposta result uguale alla lista usata. Il metodo termina restituendo result.
	
\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.dao.util}\label{sec:daoUtil}

\classsection{UtilFactory}

\subsubsection*{Funzione}
Classe usata per la creazione delle classi di manipolazione del database.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
		\item{org.softwaresynthesis.mytalk.server.dao.ISessionManager}: usata per definire un riferimento con il sistema centrale per la gestione del database.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}

Nessun attributo evidenziare.

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ getDeleteUtil(manager: ISessionManager): ModifyUtil}}\\
	Metodo usato per ritornare un \inglese{utility} per la cancellazione di un record. Il metodo ritorna \verb|new DeleteUtil(manager)|.
	
	\item{\method{+ getInsertUtil(manager: ISessionManager): ModifyUtil}}\\
	Metodo usato per ritornare una \inglese{utility} per l'inserimento di un record. Il metodo ritorna \verb|new InsertUtil(manager)|.
	
	\item{\method{+ getUpdateUtil(manager: ISessionManager): ModifyUtil}}\\
	Metodo usato per ritornare una \inglese{utility} per l'aggiornamento di un record. Il metodo ritorna \verb|new UpdateUtil(manager)|.
	
	\item{\method{+ getCallUtil(manager: ISessionManager): GetUtil}}\\
	Metodo usato per ritornare una \inglese{utility} per inizializzare correttamente oggetti rappresentanti una chiamata. Il metodo ritorna \verb|new GetCallUtil(manager)|.	
	
	\item{\method{+ getGroupUtil(manager: ISessionManager): GetUtil}}
		Metodo usato per ritornare una \inglese{utility} per inizializzare correttamente oggetti rappresentanti gruppi di utenti. Il metodo ritorna \verb|new GetGroupUtil(manager)|.	
	
	\item{\method{+ getUserDataUtil(manager: ISessionManager): GetUtil}}\\
		Metodo usato per ritornare una \inglese{utility} per inizializzare correttamente oggetti rappresentanti utenti del sistema. Il metodo ritorna \verb|new GetUserDataUtil(manager)|.	

	\item{\method{+ getGenericUtil(manager: ISessionManager): GetUtil}}\\
		Metodo usato per ritornare una \inglese{utility} per estrarre dal database oggetti che non contengono campi dati di tipo ''collezione'' che devono essere inizializzate. Il metodo ritorna \verb|new NotInitialize(manager)|.	
		
\end{description}		

\classsection{ModifyUtil}

\subsubsection*{Funzione}
Classe astratta per definire il comportamento generico di una classe per la manipolazione del database. La classe costituisce un implementazione del \textit{template method}, poiché definisce un iter per l'esecuzione di un algoritmo di modifica, lasciando alle classi figlie il compito di ridefinire il metodo \method{doAction()}.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
		\item \texttt{org.hibernate.Session};
		\item \texttt{org.hibernate.SessionFactory};
		\item \texttt{org.hibernate.Transaction};
		\item \texttt{org.softwaresynthesis.mytalk.server.IMyTalkObject};
		\item \texttt{org.softwaresynthesis.mytalk.server.dao.ISessionManager};
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{\underline{-- manager: ISessionManager}}}\\
	Attributo usato per comunicare con la classe rappresentate il ''cuore'' del sistema di gestione del database.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ ModifyUtil(manager: ISessionManager)}}\\
	Costruttore pubblico della classe, usato per inizializzare \memberdata{manager} con il parametro d'ingresso del metodo.
	
	\item{\method{+ execute(object: IMyTalkObject): boolean}}\\
	Metodo che definisce l'iter per l'esecuzione dell'operazione di manipolazione del database. Il metodo definisce quelle procedure comuni a tutte le operazioni di modifica. Inizialmente il metodo definisce i seguenti oggetti:
	\begin{itemize}
		\item boolean result = false;
		\item Session session = null;
		\item SessionFactory factory = null;
		\item Transaction transaction = null;
	\end{itemize}
	
Quindi viene definito un blocco try-catch. Nel blocco try, si salva in factory un riferimento a \classname{SessionManager}. Quindi in session si riporta la sessione ottenuta da una chiamata \verb|factory.openSession()|. Si definisce l'apertura di una transizione transaction mediante una chiamata \verb|session.beginTransaction()|. Il metodo procede eseguendo il metodo \method{doAction()} passando come parametro d'ingresso session e object. Si esegue il commit sulla transizione e si imposta result a \inglese{true}. Nel blocco catch si esegue un'operazione di rollback e si imposta result a \inglese{false}.

Il metodo termina chiudendo la sessione e ritornando il contenuto di result.

	\item{\method{+ \{abstract\} doAction(session: ISessionManager, object: IMyTalkObject): void}}\\
	Metodo astratto non definito in questa classe. Le classi figlie di \classname{ModifyUtil} ridefiniranno questo metodo.

\end{description}

\classsection{InsertUtil}

\subsubsection*{Funzione}
Classe figlia di \classname{ModifyUtil}. Ridefinisce il metodo \method{doAction} per eseguire un operazione di insert in una tabella del database.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
		\item \texttt{org.hibernate.Session};
		\item \texttt{org.softwaresynthesis.mytalk.server.IMyTalkObject};
		\item \texttt{org.softwaresynthesis.mytalk.server.dao.ISessionManager};
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

\begin{itemize}
	\item \classname{dao.util.ModifyUtil}: classe astratta estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato.

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ InsertUtil(manager: ISessionManager)}}\\
	Costruttore pubblico della classe, usato per inizializzare \memberdata{manager} con il parametro d'ingresso del metodo. Per farlo richiama il costruttore della classe padre.

	\item{\method{+ \{final\} doAction(session: ISessionManager, object: IMyTalkObject): void}}\\
	Metodo usato per eseguire un operazione di insert nel database. Il metodo esegue l'unica operazione \verb|session.save(object)|.

\end{description}

\classsection{DeleteUtil}

\subsubsection*{Funzione}
Classe figlia di \classname{ModifyUtil}. Ridefinisce il metodo \method{doAction} per eseguire un operazione di delete in una tabella del database.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
		\item \texttt{org.hibernate.Session};
		\item \texttt{org.softwaresynthesis.mytalk.server.IMyTalkObject};
		\item \texttt{org.softwaresynthesis.mytalk.server.dao.ISessionManager};
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

\begin{itemize}
	\item \classname{dao.util.ModifyUtil}: classe astratta estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato.

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ DeleteUtil(manager: ISessionManager)}}\\
	Costruttore pubblico della classe, usato per inizializzare \memberdata{manager} con il parametro d'ingresso del metodo. Per farlo richiama il costruttore della classe padre.

	\item{\method{+ \{final\} doAction(session: ISessionManager, object: IMyTalkObject): void}}\\
	Metodo usato per eseguire un operazione di delete nel database. Il metodo esegue l'unica operazione \verb|session.delete(object)|.

\end{description}

\classsection{UpdateUtil}

\subsubsection*{Funzione}
Classe figlia di \classname{ModifyUtil}. Ridefinisce il metodo \method{doAction} per eseguire un operazione di aggiornamento (intesa come modifica del valore di alcuni campi dati) in una tabella del database.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
		\item \texttt{org.hibernate.Session};
		\item \texttt{org.softwaresynthesis.mytalk.server.IMyTalkObject};
		\item \texttt{org.softwaresynthesis.mytalk.server.dao.ISessionManager};
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

\begin{itemize}
	\item \classname{dao.util.ModifyUtil}: classe astratta estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato.

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ UpdateUtil(manager: ISessionManager)}}\\
	Costruttore pubblico della classe, usato per inizializzare \memberdata{manager} con il parametro d'ingresso del metodo. Per farlo richiama il costruttore della classe padre.

	\item{\method{+ \{final\} doAction(session: ISessionManager, object: IMyTalkObject): void}}\\
	Metodo usato per eseguire un operazione di update nel database. Il metodo esegue l'unica operazione \verb|session.update(object)|.

\end{description}

\classsection{GetUtil}

\subsubsection*{Funzione}
Classe astratta per definire il comportamento generico di una classe per l'esecuzione di ''interrogazioni'' (query di tipo \texttt{select}) al database. La classe costituisce un implementazione del \textit{template method}, poiché definisce un iter per l'esecuzione di un algoritmo, lasciando alle classi figlie il compito di ridefinire il metodo \method{doInitialize()}.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
		\item \texttt{java.util.List};
		\item \texttt{org.hibernate.Query};
		\item \texttt{org.hibernate.Session};
		\item \texttt{org.hibernate.SessionFactory};
		\item \texttt{org.hibernate.Transaction};
		\item \texttt{org.softwaresynthesis.mytalk.server.IMyTalkObject};
		\item \texttt{org.softwaresynthesis.mytalk.server.dao.ISessionManager};
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{\underline{-- manager: ISessionManager}}}\\
	Attributo usato per comunicare con la classe rappresentate il ''cuore'' del sistema di gestione del database.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ GetUtil(manager: ISessionManager)}}\\
	Costruttore pubblico della classe, usato per inizializzare \memberdata{manager} con il parametro d'ingresso del metodo.
	
	\item{\method{+ execute(query: String): List<IMyTalkObject>}}\\
	Metodo che definisce l'iter per l'esecuzione dell'operazione d'interrogazione del database. Il metodo definisce quelle procedure comuni a tutte le operazioni di lettura dei dati. Inizialmente il metodo definisce i seguenti oggetti:
	\begin{itemize}
		\item Query hqlQuery = null;
		\item List<IMyTalkObject> collection = null;
		\item Session session = null;
		\item SessionFactory factory = null;
		\item Transaction transaction = null;
	\end{itemize}
	
Quindi viene definito un blocco try-catch. Nel blocco try, si salva in factory un riferimento a \classname{SessionManager}. Quindi in session si riporta la sessione ottenuta da una chiamata \verb|factory.openSession()|. Si definisce la query d'interrogazione mediante una chiamata \verb|session.createQuery(query)|. Si definisce l'apertura di una transizione transaction mediante una chiamata \verb|session.beginTransaction()|. Il metodo procede prima impostando collection a \verb|(List<IMyTalkObject>)hqlQuery.list();|, e poi eseguendo il metodo \method{doInitialize()} passando come parametro d'ingresso collection. Si esegue il commit sulla transizione e si imposta result a \inglese{true}. Nel blocco catch si esegue un'operazione di rollback e si imposta collection a \inglese{null}.

Il metodo termina chiudendo la sessione e ritornando il contenuto di collection.

	\item{\method{+ uniqueResult(query: String): Long}}\\
	Metodo che definisce l'iter per l'esecuzione dell'operazione d'interrogazione del database (quelle che prevedono un unico risultato). Il metodo definisce quelle procedure comuni a tutte le operazioni di lettura dei dati. Inizialmente il metodo definisce i seguenti oggetti:
	\begin{itemize}
		\item Query hqlQuery = null;
		\item Long result = null;
		\item Session session = null;
		\item SessionFactory factory = null;
		\item Transaction transaction = null;
	\end{itemize}
	
Quindi viene definito un blocco try-catch. Nel blocco try, si salva in factory un riferimento a \classname{SessionManager}. Quindi in session si riporta la sessione ottenuta da una chiamata \verb|factory.openSession()|. Si definisce la query d'interrogazione mediante una chiamata \verb|session.createQuery(query)|. Si definisce l'apertura di una transizione transaction mediante una chiamata \verb|session.beginTransaction()|. Il metodo procede prima impostando result a \verb|(Long)hqlQuery.uniqueResult()|, e poi eseguendo l'operazione di commit a partire dall'oggetto transaction. Nel blocco catch si esegue un'operazione di rollback e si imposta result a \inglese{null}.

Il metodo termina chiudendo la sessione e ritornando il contenuto di result.

	\item{\method{+ \{abstract\} doInitialize(collection: List<IMyTalkObject>): void}}\\
	Metodo astratto non definito in questa classe. Le classi figlie di \classname{GetUtil} ridefiniranno questo metodo.

\end{description}

\classsection{GetCallUtil}

\subsubsection*{Funzione}
Classe figlia di \classname{GetUtil}. Rappresenta l'operazione necessaria per ottenere le chiamate registrate nel database.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
		\item \texttt{java.util.Iterator};
		\item \texttt{import java.util.List};
		\item \texttt{import org.hibernate.Hibernate};
		\item \texttt{org.hibernate.Session};
		\item \texttt{org.softwaresynthesis.mytalk.server.IMyTalkObject};
		\item \texttt{org.softwaresynthesis.mytalk.server.dao.ISessionManager};
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

\begin{itemize}
	\item \classname{dao.util.GetUtil}: classe astratta estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato.

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ GetCallUtil(manager: ISessionManager)}}\\
	Costruttore pubblico della classe, usato per inizializzare \memberdata{manager} con il parametro d'ingresso del metodo. Per farlo richiama il costruttore della classe padre.

	\item{\method{+ \{final\} doInitialize(collection: List<IMyTalkObject>): void}}\\
	Il metodo definisce un istanza di \classname{ICall} call inizializzandola a null. Quindi procede definendo un iteratore Iterator<IMyTalkObject> a partire da collection. All'interno di un ciclo while che itera per ogni elemento dell'iteratore, si sovrascrive il contenuto di call con quanto estratto dall'iteratore (uso del metodo \texttt{next()}), e poi deve essere eseguita l'istruzione:\\
	
	\verb|Hibernate.initialize(call.getCalls());|

\end{description}

\classsection{GetGroupUtil}

\subsubsection*{Funzione}
Classe figlia di \classname{GetUtil}. Rappresenta l'operazione necessaria per ottenere i gruppi presenti nel database.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
		\item \texttt{java.util.Iterator};
		\item \texttt{import java.util.List};
		\item \texttt{import org.hibernate.Hibernate};
		\item \texttt{org.hibernate.Session};
		\item \texttt{org.softwaresynthesis.mytalk.server.IMyTalkObject};
		\item \texttt{org.softwaresynthesis.mytalk.server.dao.ISessionManager};
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

\begin{itemize}
	\item \classname{dao.util.GetUtil}: classe astratta estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato.

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ GetGroupUtil(manager: ISessionManager)}}\\
	Costruttore pubblico della classe, usato per inizializzare \memberdata{manager} con il parametro d'ingresso del metodo. Per farlo richiama il costruttore della classe padre.

	\item{\method{+ \{final\} doInitialize(collection: List<IMyTalkObject>): void}}\\
	Il metodo definisce un istanza di \classname{IGroup} group inizializzandola a null. Quindi procede definendo un iteratore Iterator<IMyTalkObject> a partire da collection. All'interno di un ciclo while che itera per ogni elemento dell'iteratore, si sovrascrive il contenuto di group con quanto estratto dall'iteratore (uso del metodo \texttt{next()}), e poi deve essere eseguita l'istruzione:\\
	
	\verb|Hibernate.initialize(group.getAddressBook());|

\end{description}

\classsection{GetUserDataUtil}

\subsubsection*{Funzione}
Classe figlia di \classname{GetUtil}. Rappresenta l'operazione necessaria per ottenere gli utenti presenti nel database.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
		\item \texttt{java.util.Iterator};
		\item \texttt{import java.util.List};
		\item \texttt{import org.hibernate.Hibernate};
		\item \texttt{org.hibernate.Session};
		\item \texttt{org.softwaresynthesis.mytalk.server.IMyTalkObject};
		\item \texttt{org.softwaresynthesis.mytalk.server.dao.ISessionManager};
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

\begin{itemize}
	\item \classname{dao.util.GetUtil}: classe astratta estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato.

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ GetUserDataUtil(manager: ISessionManager)}}\\
	Costruttore pubblico della classe, usato per inizializzare \memberdata{manager} con il parametro d'ingresso del metodo. Per farlo richiama il costruttore della classe padre.

	\item{\method{+ \{final\} doInitialize(collection: List<IMyTalkObject>): void}}\\
	Il metodo definisce un istanza di \classname{IUserData} user inizializzandola a null. Quindi procede definendo un iteratore Iterator<IMyTalkObject> a partire da collection. All'interno di un ciclo while che itera per ogni elemento dell'iteratore, si sovrascrive il contenuto di user con quanto estratto dall'iteratore (uso del metodo \texttt{next()}), e poi devono essere eseguite le istruzioni:\\
	
	\verb|Hibernate.initialize(user.getAddressBook());|\\
	\verb|Hibernate.initialize(user.getMessages());|\\
	\verb|Hibernate.initialize(user.getCalls());|

\end{description}

\classsection{NotInitialize}

\subsubsection*{Funzione}
Classe figlia di \classname{GetUtil}.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
		\item \texttt{org.hibernate.Session};
		\item \texttt{org.softwaresynthesis.mytalk.server.IMyTalkObject};
		\item \texttt{org.softwaresynthesis.mytalk.server.dao.ISessionManager};
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

\begin{itemize}
	\item \classname{dao.util.GetUtil}: classe astratta estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato.

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ DeleteUtil(manager: ISessionManager)}}\\
	Costruttore pubblico della classe, usato per inizializzare \memberdata{manager} con il parametro d'ingresso del metodo. Per farlo richiama il costruttore della classe padre.

	\item{\method{+ \{final\} doInitialize(collection: List<IMyTalkObject>): void}}\\
	Metodo dal corpo vuoto.

\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.abook}\label{sec:abook}

\classsection{IUserData}

\subsubsection*{Funzione}
Interfaccia rappresentante il comportamento di un generico utente del sistema. L'interfaccia dovrà definire dei metodi di tipo \textit{get} e \textit{set} per i dati d'interesse.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \classname{AddressBookEntry}: l'interfaccia definisce dei metodi per la manipolazione di dati \classname{AddressBookEntry}.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{org.softwaresynthesis.mytalk.server.IMyTalkObject}: interfaccia da estendere. Ogni oggetto che implementerà l'interfaccia \classname{IUserData} dovrà essere in grado di convertire il proprio contenuto informativo in formato \textit{Json}.
\end{itemize}


\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce l'identificatore univoco di uno \classname{IUserData}.
	\item{\method{+ getEmail(): String}}\\
	Restituisce l'indirizzo e-mail con cui uno \classname{IUserData} si è registrato nel sistema \caName.
	\item{\method{+ setEmail(mail: String): void}}\\ 
	Imposta l'indirizzo e-mail con cui si registra nel sistema \caName uno \classname{IUserData}.
	\item{\method{+ getPassword(): String}}\\
	Restituisce la password di accesso al sistema \caName di uno \classname{IUserData}.
	\item{\method{+ setPassword(password: String): void}}\\
	Imposta la password di accesso al sistema di uno \classname{IUserData}.
	\item{\method{+ getQuestion(): String}}\\
	Restituisce la domanda segreta, scelta da uno \classname{IUserData}, per il recupero della \textit{password} smarrita di accesso al sistema \caName.
	\item{\method{+ setQuestion(question: String): void}}\\
	Imposta la domanda segreta, scelta da uno \classname{IUserData}, per il recupero della \textit{password} smarrita di accesso al sistema \caName.
	\item{\method{+ getAnswer(): String}}\\
	Restituisce la risposta alla domanda per il recupero della \textit{password} smarrita di accesso al sistema \caName.
	\item{\method{+ setAnswer(answer: String): void}}\\
	Imposta la risposta alla domanda segreta per il recupero della \textit{password} di accesso al sistema \caName.
	\item{\method{+ getName(): String}}\\
	Restituisce il nome di uno \classname{IUserData}.
	\item{\method{+ setName(name: String): void}}\\
	Imposta il nome di uno \classname{IUserData}.
	\item{\method{+ getSurname(): String}}\\
	Restituisce il cognome di uno \classname{IUserData}.
	\item{\method{+ setSurname(surname: String): void}}\\
	Imposta il cognome di uno \classname{IUserData}.
	\item{\method{+ getPicturePath(): String}}\\
	Restituisce una stringa con il percorso dell'immagine del profilo di uno \classname{IUserData}.
	\item{\method{+ setPicturePath(path: String): void}}\\
	Imposta il percorso dell'immagine profilo di uno \classname{IUserData}.
	\item{\method{+ getAddressBook(): Set<AddressBookEntry>}}\\
	Metodo che ritorna il la rubrica dell'utente sotto forma d'insieme di \classname{AddressBookEntry}.
	\item{\method{+ addAddressBookEntry(entry: AddressBookEntry): void}}\\
	Metodo usato per aggiungere una nuova \classname{AddressBookEntry} all'insieme di \inglese{entry} che costituisce la rubrica utente.
\end{description}

\classsection{IGroup}

\subsubsection*{Funzione}
Interfaccia rappresentante un gruppo di una rubrica utente del sistema \caName.

\subsubsection*{Relazioni d'uso}

Nessuna relazione evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
		\item \texttt{org.softwaresynthesis.mytalk.server.IMyTalkObject}: interfaccia da estendere. Ogni oggetto che implementerà l'interfaccia \classname{IGroup} dovrà essere in grado di convertire il proprio contenuto informativo in formato \textit{Json}.
\end{itemize}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce l'identificativo univoco di uno gruppo di una rubrica utente.
	\item{\method{+ getName(): String}}\\
	Restituisce il nome di un gruppo di una rubrica utente.
	\item{\method{+ setName(name: String): void}}\\
	Imposta il nome di un gruppo di una rubrica utente.
\end{description}

\classsection{IAddressBookEntry}

\subsubsection*{Funzione}
Interfaccia rappresentante una \textit{entry} di una rubrica utente del sistema mytalk.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \classname{IUserData}: l'interfaccia \classname{IAddressBookEntry} definisce più metodi che restituiscono oggetti aventi tipo di ritorno \classname{IUserData}, essi sono i metodi \inglese{get} per ottenere il ``proprietario'' della rubrica e per ottenere l'utente registrato nella rubrica. Analogamente \classname{IUserData} viene usato come parametro d'ingresso per i metodi \inglese{set} collegati ai metodi già citati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
		\item \texttt{org.softwaresynthesis.mytalk.server.IMyTalkObject}: interfaccia da estendere. Ogni oggetto che implementerà l'interfaccia \classname{IAddressBookEntry} dovrà essere in grado di convertire il proprio contenuto informativo in formato \textit{Json}.
\end{itemize}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce l'identificativo univoco di una \inglese{entry} di una rubrica utente del sistema \caName.
	\item{\method{+ getEntry(): IUserData}}\\
	Restituisce un istanza di un oggetto avente tipo \classname{IUserData} rappresentante un contatto della rubrica.
	\item{\method{+ setEntry(contact: IUserData): void}}\\
	Imposta l'utente \classname{IUserData} (passato come parametro d'ingresso) come contatto della rubrica.
	\item{\method{+ getGroup(): IGroup}}\\
	Restituisce il gruppo a cui appartiene lo \classname{IUserData} registrato nella rubrica.
	\item{\method{+ setGroup(group: IGroup): void}}\\
	Imposta il gruppo di appartenenza dello \classname{IUserData} registrato nella rubrica.
	\item{\method{+ getOwner(): IUserData}}\\
	Restituisce lo \classname{IUserData} possessore dell'\inglese{entry} corrente della rubrica
	\item{\method{+ setOwner(owner: IUserData ): void}}\\
	Imposta l'utente \classname{IUserData} possessore della \inglese{entry} della rubrica.
\end{description}

\classsection{UserData}

\subsubsection*{Funzione}
Implementazione dell'interfaccia \classname{IUserData}. Un istanza della classe dovrà rappresentare un generico utente del sistema definendone gli attributi e i metodi per impostare ed ottenere il contenuto dei medesimi.

\subsubsection*{Relazioni d'uso}

Nessuna relazione evidenziata

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
		\item{IUserData}: interfaccia da implementare.
\end{itemize}

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{-- id: long}}
	Attributo che definisce il codice identificativo con il quale l'utente è registrato nel database del sistema.
	\item{\memberdata{-- mail: String}}
	Attributo che definisce l'indirizzo e-mail con il quale l'utente si è registrato nel sistema.
	\item{\memberdata{-- password: String}}
	Attributo che definisce la password per il \inglese{login} dell'utente nel sistema.
	\item{\memberdata{-- question: String}}
	Attributo che definisce la domanda segreta usata dall'utente in caso di smarrimento della password.
	\item{\memberdata{-- answer: String}}
	Attributo che definisce la risposta alla domanda segreta definita nell'attributo \memberdata{question}.
	\item{\memberdata{-- name: String}}
	Attributo che definisce il nome dell'utente.
	\item{\memberdata{-- surname: String}}
	Attributo che definisce il cognome dell'utente.
	\item{\memberdata{-- path: String}}
	Attributo che definisce il percorso (sul server) in cui è memorizzata l'immagine del profilo dell'utente.
	\item{\memberdata{-- addressBook: Set<AddressBookEntry>}}
	Attributo che definisce l'insieme di \classname{AddressBookEntry} che costituiscono la rubrica dell'utente.
	
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce l'identificatore univoco di un utente, ritornando l'attributo \memberdata{id}.
	\item{\method{\# setId(id: long): void}}\\
	Imposta l'indirizzo \textit{id} con cui l'utente si registra nel sistema \caName. Il metodo sovrascrive il contenuto dell'attributo \memberdata{id} con il valore tipo \texttt{long} ricevuto come parametro d'ingresso. ritornando l'attributo \memberdata{id}.
	\item{\method{+ getEmail(): String}}\\
	Restituisce l'indirizzo e-mail con cui uno l'utente si è registrato nel sistema \caName, ritornando il contenuto dell'attributo \memberdata{mail}.
	\item{\method{+ setEmail(mail: String): void}}\\ 
	Imposta l'indirizzo e-mail con cui l'utente si registra nel sistema \caName. Il metodo non fa altro che sovrascrivere il contenuto dell'attributo \memberdata{mail} con il valore tipo \texttt{String} ricevuto come parametro d'ingresso.
	\item{\method{+ getPassword(): String}}\\
	Restituisce la password dell'utente, ritornando il valore contenuto nell'attributo \memberdata{password}.
	\item{\method{+ setPassword(password: String): void}}\\
	Imposta la password di accesso al sistema, sovrascrivendo il contenuto dell'attributo \memberdata{password} con il valore di tipo \texttt{String} ricevuto come parametro d'ingresso.
	\item{\method{+ getQuestion(): String}}\\
	Restituisce la domanda segreta, scelta dall'utente, per il recupero della password di accesso al sistema \caName. Nello specifico il metodo restituisce il contenuto dell'attributo \memberdata{question}.
	\item{\method{+ setQuestion(question: String): void}}\\
	Imposta la domanda segreta da inserire in caso di smarrimento della password. Il metodo sovrascrive il contenuto dell'attributo \memberdata{question} con il valore tipo \texttt{String} ricevuto come parametro d'ingresso
	\item{\method{+ getAnswer(): String}}\\
	Restituisce la risposta alla domanda per il recupero della password (smarrita) di accesso al sistema \caName. Il metodo ritorna il contenuto dell'attributo \memberdata{answer}.
	\item{\method{+ setAnswer(answer: String): void}}\\
	Imposta la risposta alla domanda segreta per il recupero della password. Il metodo sovrascrive il contenuto dell'attributo \memberdata{answer} con il valore tipo \texttt{String} passato come parametro d'ingresso.
	\item{\method{+ getName(): String}}\\
	Restituisce il nome dell'utente ritornando il contenuto dell'attributo \memberdata{name}.
	\item{\method{+ setName(name: String): void}}\\
	Imposta il nome dell'utente sovrascrivendo il contenuto dell'attributo \memberdata{name} con il valore tipo \texttt{String} passato al metodo come parametro d'ingresso.
	\item{\method{+ getSurname(): String}}\\
	Restituisce il cognome dell'utente restituendo il contenuto dell'attributo \memberdata{surname}.
	\item{\method{+ setSurname(surname: String): void}}\\
	Imposta il cognome dell'utente sovrascrivendo il contenuto dell'attributo \memberdata{surnamename} con il valore tipo \texttt{String} passato al metodo come parametro d'ingresso.
	\item{\method{+ getPicturePath(): String}}\\
	Restituisce una stringa con il percorso dell'immagine del profilo dell'utente, restituendo il contenuto dell'attributo \memberdata{path}.
	\item{\method{+ setPicturePath(path: String): void}}\\
	Imposta il percorso dell'immagine profilo di un utente, sovrascrivendo il contenuto dell'attributo \memberdata{path} con il valore tipo \texttt{String} passato al metodo come parametro d'ingresso.
	\item{\method{+ getState(): State}}\\
	Restituisce lo stato in cui si trova l'utente, ritornando il contenuto dell'attributo \memberdata{state}.
	\item{\method{+ setState(state: State): void}}\\
	Imposta lo stato in cui si trova l'utente, sovrascrivendo il contenuto dell'attributo \memberdata{state} con il valore ricevuto come parametro d'ingresso.
	\item{\method{+ getAddressBook(): Set<AddressBookEntry>}}\\
	Metodo che ritorna il contenuto di \memberdata{addressBook}.
	\item{\method{+ addAddressBookEntry(entry: AddressBookEntry): void}}\\
	Metodo usato per aggiungere ad \memberdata{addressBook} una nuova \classname{AddressBookEntry} passata come parametro d'ingresso.
	\item{\method{+ toJson(): String}}\\
	Metodo usato per ritornare il contenuto di un istanza di \classname{UserData} sotto forma di stringa formattata in \textit{Json}. La stringa ritornata deve corrispondere al seguente formato:\\\\
	\verb|{name:"mio_nome",surname:"mio_cognome",email:"mia_mail"|\\\verb|,picturePath:"mia_immagine",id:"mio_id"}|\\
	
	dove i valori tra virgolette rappresentano il contenuto dei rispettivi campi dati contenuti nella classe.
\end{description}

\classsection{Group}

\subsubsection*{Funzione}
Implementazione dell'interfaccia \classname{IGroup}.

\subsubsection*{Relazioni d'uso}

Nessuna relazione evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \classname{IGroup}: interfaccia d'implementazione.
\end{itemize}


\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{-- id: long}}
	Attributo del codice identificativo del gruppo.
	\item{\memberdata{-- name: String}}:
	Attributo del nome del gruppo.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce l'identificativo univoco di uno gruppo di una rubrica utente.
	\item{\method{+ getName(): String}}\\
	Restituisce il nome di un gruppo di una rubrica utente.
	\item{\method{+ setName(name: String): void}}\\
	Imposta il nome di un gruppo di una rubrica utente.
	\item{\method{+ toJson(): String}}\\
	Metodo usato per ritornare il contenuto di un istanza di \classname{Group} sotto forma di stringa formattata in \textit{Json}. La stringa ritornata deve corrispondere al seguente formato:\\\\
	\verb|{id:"mio_id",name:"mio_nome"}|\\
	
	dove i valori tra virgolette rappresentano il contenuto dei rispettivi campi dati contenuti nella classe.
\end{description}

\classsection{AddressBookEntry}

\subsubsection*{Funzione}
Implementazione dell'interfaccia IAddressBookEntry.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \classname{IUserData}: usata per definire gli attributi destinati a identificare il possessore dell'istanza di \classname{AddressBookEntry} e il relativo contatto in essa registrato.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \classname{IAddressBookEntry}: interfaccia d'implementazione della classe.
\end{itemize}

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{-- id: long}}
	Attributo del codice identificativo della classe.
	\item{\memberdata{-- group: IGroup}}
	Attributo destinato a identificare il gruppo a cui appartiene il contatto \classname{IUserName} registrato nella classe. Si ricorda che il contatto può anche non appartenere ad alcun gruppo.
	\item{\memberdata{-- contact: IUserData}}
	Attributo destinato ad identificare il contatto registrato nell'istanza di \classname{AddressBookEntry}.
	\item{\memberdata{-- owner: IUserData}}:
	Attributo destinato ad identificare il possessore dell'istanza di \classname{AddressBookEntry}.
	\item{\memberdata{-- blocked: boolean}}
	Attributo booleano necessario per bloccare il contatto. Tale blocco avviene impostando l'attributo a \textit{true}.
\end{itemize}


\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce l'identificativo univoco della \inglese{entry} di una rubrica utente del sistema \caName, nello specifico il contenuto dell'attributo \memberdata{id}.
	\item{\method{+ getEntry(): IUserData}}\\
	Restituisce il contenuto dell'attributo \memberdata{contact}.
	\item{\method{+ setEntry(contact: IUserData): void}}\\
	Imposta l'utente \classname{IUserData} (passato come parametro d'ingresso) come contatto della rubrica, nello specifico il contenuto dell'attributo \memberdata{contact}.
	\item{\method{+ getGroup(): IGroup}}\\
	Restituisce il gruppo a cui appartiene lo \classname{IUserData} registrato nella rubrica, nello specifico il contenuto dell'attributo \memberdata{group}.
	\item{\method{+ setGroup(group: IGroup): void}}\\
	Imposta il gruppo di appartenenza dello \classname{IUserData} registrato nella rubrica, nello specifico il contenuto dell'attributo \memberdata{group}.
	\item{\method{+ getOwner(): IUserData}}\\
	Restituisce lo \classname{IUserData} possesore di questa \inglese{entry} della rubrica, nello specifico il contenuto dell'attributo \memberdata{owner}.
	\item{\method{+ setOwner(owner: IUserData ): void}}\\
	Imposta l'utente \classname{IUserData} possessore della \textit{entry} della rubrica, nello specifico il contenuto dell'attributo \memberdata{owner}.
	\item{\method{+ toJson(): String}}\\
	Metodo usato per ritornare il contenuto di un istanza di \classname{AddressBookEntry} sotto forma di stringa formattata in \textit{Json}. La stringa ritornata deve corrispondere al seguente formato:\\\\
	\verb|{id:"mio_id",contact:"mio_contatto",group:"mia_gruppo",blocked:"bloccato"}|\\
	
	dove i valori tra virgolette rappresentano il contenuto dei rispettivi campi dati contenuti nella classe.

\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.abook.controller}\label{sec:call}

%TODO da verificare

\classsection{AddContactController}

\subsubsection*{Funzione}
\textit{Controller} che ha il compito di aggiungere alla rubrica un nuovo contatto.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dal metodo \method{doAction()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doAction()}. Usata per scrivere l'output del \inglese{controller}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doAction()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \classname{org.softwaresynthesis.mytalk.server.dao.DataPersistenceManager}: classe usata per comunicare tramite Hibernate con la tabella UserData della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{server.AbstractController}: classe estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato

\subsubsection*{Metodi}
\begin{description}
	\item{\method{\# doAction(request HttpServletRequest, response HttpServletResponse): void}}\\	
	Metodo usato per eseguire la richiesta di aggiungere un nuovo contatto all'interno della rubrica. Il flusso principale inizia  con la creazione di un oggetto \classname{dao.DataPersistanceManager} avente nome UserDAO. Quindi viene aperto un blocco try catch in cui si salva in un istanza di tipo \texttt{HttpSession}, l'oggetto ritornato da una chiamata \verb|request.getSession(false)|. I passi successivi sono (nell'ordine):
	\begin{itemize}
		\item salvare in attributo di tipo long, contactID, l'id dell'utente. Tale id dovrà essere ottenuto con una chiamata:\\
		\verb|request.getParameter("contactId")|;\\
		
		\item si crea un istanza di tipo \classname{IUserData} a partire da una chiamata a metodo:\\
		\verb|session.getAttribute("user")|;
		
		\item si crea un istanza di tipo \classname{IUserData} che conterrà ``l'utente'' che dovrà essere registrato nella rubrica del chiamante. L'oggetto dovrà essere istanziato in seguito ad una chiamata:\\
		\verb|userDAO.getByID(contactId)|;
	\end{itemize}
	Quindi se il contatto (che dovrò andare a registrare) è stato correttamente istanziato (contatto != null) allora il flusso principale procede creando e impostando un istanza di \classname{AddressBookEntry}. Il metodo termina ``scrivendo'' \inglese{true} all'interno di un istanza di \texttt{PrintWriter} creata a partire da \texttt{response.getWriter()} ed eseguendo il metodo \method{addAddressBookEntry()} (passando l'entry creata in precedenza) a partire dall'istanza che rappresenta l'utente richiedente.
	
	Se invece si è osservato che l'oggetto contenente il contatto da aggiungere, ha valore uguale a null, allora il metodo termina scrivendo \inglese{false} all'intero della dello stesso \texttt{PrintWriter} già citato.
\end{description}

%TODO da verificare

\classsection{DeleteContactsController}

\subsubsection*{Funzione}
\inglese{Controller} richiamata dal \textit{front controller} per eseguire l'eliminazione di un contatto presente nella propria rubrica.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
		\item \texttt{java.io.IOException}: eccezione richiamabile dal metodo \method{doAction()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doAction()}. Usata per scrivere l'output del \inglese{controller}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doAction()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client. 
	\item \classname{org.softwaresynthesis.mytalk.server.dao.DataPersistanceManager}: classe usata per comunicare tramite Hibernate con la tabella UserData della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{server.AbstractController}: classe estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato

\subsubsection*{Metodi}
\begin{description}
	\item{\method{\# doAction(request HttpServletRequest, response HttpServletResponse): void}}\\	
	Metodo usato per eseguire la richiesta di eliminazione di un contatto presente all'interno della rubrica. Tale metodo deve creare un istanza di \texttt{AddressBookEntry} con i dati relativi alla \textit{entry} da eliminare, quindi richiamerà il metodo \method{removeAddressBookEntry()} a partire dalle due istanze di \texttt{IUserData} (quella che rappresenta l'utente richiedete e quella che rappresenta l'utente da eliminare) passando come parametro l'\textit{entry} definita in precedenza. Più nello specifico Il flusso principale inizia  con la creazione di un oggetto \classname{dao.DataPersistanceManager} avente nome UserDAO, quindi viene aperto un blocco \textit{try-catch} in cui si salva in un istanza di tipo \texttt{HttpSession}, l'oggetto ritornato da una chiamata \verb|request.getSession(false)|. I passi successivi sono (nell'ordine):
	\begin{itemize}
		\item salvare in attributo di tipo long, contactID, l'id dell'utente. Tale id dovrà essere ottenuto con una chiamata:\\
		\verb|request.getParameter("contactId")|;\\
		
		\item si crea un istanza di tipo \classname{IUserData} a partire da una chiamata a metodo:\\
		\verb|session.getAttribute("user")|;
		
		\item si crea un istanza di tipo \classname{IUserData} che conterrà ``l'utente'' che dovrà essere eliminato dalla rubrica del chiamante. L'oggetto dovrà essere istanziato in seguito ad una chiamata:\\
		\verb|userDAO.getByID(contactId)|;
	\end{itemize}
	Quindi se il contatto (che dovrò andare a cancellare dalla lista) è stato correttamente istanziato (\texttt{contatto != null}) allora il flusso principale procede creando e impostando un istanza di \classname{AddressBookEntry}. Quindi a partire dall'oggetto che rappresenta l'utente richiedente, viene richiamato il metodo \method{removeAddressBookEntry()}. Il metodo termina ``scrivendo'' \inglese{true} all'interno di un istanza di \texttt{PrintWriter} creata a partire da \texttt{response.getWriter()}.
	
	Se invece si è osservato che l'oggetto contenente il contatto da rimuovere, ha valore uguale a \textit{null}, allora il metodo termina impostando \inglese{false} all'intero della dello stesso \texttt{PrintWriter} già citato.
\end{description}

%TODO da verificare

\classsection{AddGroupController}

\subsubsection*{Funzione}
\inglese{Controller} richiamata dal \textit{front controller} per creare un nuovo gruppo nella propria rubrica.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dal metodo \method{doAction()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doAction()}. Usata per scrivere l'output del \inglese{controller}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doAction()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \classname{org.softwaresynthesis.mytalk.server.dao.DataPersistanceManager}: classe usata per comunicare tramite Hibernate con la tabella UserData della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{server.AbstractController}: classe estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato

\subsubsection*{Metodi}
\begin{description}
	\item{\method{\# doAction(request HttpServletRequest, response HttpServletResponse): void}}\\	
	Metodo usato per eseguire la richiesta di creazione di un gruppo. Nell'ordine proposto, devono essere eseguite le seguenti operazioni:
	\begin{itemize}
		\item creazione di un oggetto \classname{dao.DataPersistanceManager} avente nome groupDAO;
		\item creazione di un oggetto \texttt{HttpSession} avente nome session;
		\item creazione di un oggetto \classname{abook.IGroup} avente nome group;
		\item creazione di un oggetto \classname{abook.IUserData} avente nome user;
		\item creazione di un oggetto \texttt{PrinterWriter} avente nome writer;
		\item creazione di due stringhe, name e result;
	\end{itemize}
	A questo punto viene creato un blocco \textit{try-catch}. Il blocco \textit{catch} imposta la stringa \textit{result} a \inglese{false}, il blocco \textit{try} dovrà invece seguire il seguente iter:
	\begin{itemize}
		\item si imposta \textit{session} con il valore ritornato da una chiamata:\\
		\verb|request.getSession(false)|;
		\item si imposta la variabile user con il valore presente nell'attributo \textit{user} di sessione (usare l'istruzione \verb|session.getAttribute("user")|;
		\item impostare name con il contenuto del parametro \textit{groupName} presente nell'oggetto request;
		\item verificare se \inglese{name} è \textit{null} o vuoto. Nel caso procedere impostando \textit{result} a \textit{false} e uscendo dal blocco \textit{try}.
		\item altrimenti, se \inglese{name} contiene un nome valido si crea un nuovo gruppo (salvandolo nella variabile group), e impostando il nome e l'utente proprietario.
		\item richiamare \method{insert()} a partire dall'istanza groupDAO, passando come parametro group (che ora conterrà in gruppo da inserire nel database). Viene impostato \textit{result} a \inglese{true},
	il metodo termina scrivendo su \inglese{write} (usando l'omonimo metodo) il valore contenuto in \textit{result}. 		
	\end{itemize}
	
\end{description}

%TODO da verificare

\classsection{DeleteGroupController}

\subsubsection*{Funzione}
\inglese{Controller} richiamata dal \textit{front controller} per eliminare un gruppo da una rubrica.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
\item \texttt{java.io.IOException}: eccezione richiamabile dal metodo \method{doAction()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doAction()}. Usata per scrivere l'output del \inglese{controller}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doAction()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \classname{org.softwaresynthesis.mytalk.server.dao.DataPersistanceManager}: classe usata per comunicare tramite Hibernate con la tabella UserData della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{server.AbstractController}: classe estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato

\subsubsection*{Metodi}
\begin{description}
	\item{\method{\# doAction(request HttpServletRequest, response HttpServletResponse): void}}\\	
	Metodo usato per eseguire la richiesta di eliminazione di un gruppo. Nell'ordine proposto, devono essere eseguite le seguenti operazioni:
	\begin{itemize}
		\item creazione di un'istanza di \classname{dao.AddressBookEntryDAO} denominata entryDAO;
		\item creazione di un \classname{dao.DataPersistanceManager} denominata groupDAO.
		\item creazione di un'istanza di \classname{abook.IGroup} denominata group;
		\item creazione di un istanza di \classname{abook.IAddressBookEntry} denominata entry;
		\item creazione di un istanza di \texttt{Iterator<IAddressBookEntry>} denominata iterator;
		\item creazione di un istanza di \texttt{PrintWriter} denominata writer;
		\item creazione di un \texttt{Set<IAddressBookEntry>} denominato entrys;
		\item creazione di una stringa denominata result (utilizzata per registrare il messaggio da stampare sul writer);
	\end{itemize} 
	A questo punto deve essere definito un blocco \textit{try-catch}. Dentro il blocco \textit{catch} si  imposta \textit{result} con il valore \inglese{false}. Per quanto riguarda il blocco \textit{try}, il programmatore dovrà definire il seguente iter:
	\begin{itemize}
		\item salvare in group il valore ritornato da una chiamata \method{getByID} a cui passo l'identificativo del gruppo (\texttt{request.getParameter("groupId")}) a partire dall'oggetto groupDAO.
		\item quindi si esegue una verifica sul contenuto di group. Se \texttt{group == null} allora si imposta \textit{result} a \inglese{false}. Altrimenti si carica in \textit{entry} l'oggetto ritornato da una chiamata \method{getAddressBook()} a partire da group.
		\item a tal punto (sempre dentro al costrutto condizionale \texttt{if(group != null))} si crea un iteratore tramite \texttt{entrys.iterator()} e ciclando con tale iteratore si va a modificare la voce ``gruppo'' di tutti i contati che nella mia rubrica appartengono a tale gruppo (cosi facendo l'eliminazione del gruppo non porterà all'eliminazione dei contatti presenti in tale gruppo).
		\item dunque si esegue la chiamata:
		\verb|groupDAO.delete(group)|\\
		e si imposta \textit{result} a \inglese{true}.
	\end{itemize}
	Il metodo termina scrivendo su \textit{writer} il contenuto di \textit{result}.
	
\end{description}

%TODO da verificare

\classsection{AddInGroupController}

\subsubsection*{Funzione}
\inglese{Controller} richiamata dal \textit{front controller} per inserire un utente nella propria rubrica, all'interno di un gruppo ben determinato.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dal metodo \method{doAction()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doAction()}. Usata per scrivere l'output del \inglese{controller}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doAction()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \classname{abook.IAddressBookEntry}:Interfaccia che definisce il comportamento di una generica \inglese{entry} della rubrica utente. La classe che verrà descritta crea istanze di tipo \classname{abook.IAddressBookEntry}.
	\item \classname{abook.IGroup}:
Interfaccia che definisce il comportamento di un gruppo generico. La classe che qui si descrive crea istanze di tipo \classname{abook.IGroup}.
	\item \classname{abook.IUserData}:Interfaccia che definisce il comportamento di un utente generico. La classe che qui si descrive crea istanze di tipo \classname{abook.IUserData}.
	\item \classname{abook.AddressBookEntry}: classe usata per comunicare tramite \textit{Hibernate} con la tabella AddressBookEntry della base di dati.
	\item \classname{dao.DataPersistanceManager}: classe usata per comunicare tramite \textit{Hibernate} con la tabella Group della base di dati.
	\item \classname{dao.DataPersistanceManager}: classe usata per comunicare tramite \textit{Hibernate} con la tabella UserData della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{server.AbstractController}: classe estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato

\subsubsection*{Metodi}

\begin{description}
	\item{\method{\# doAction(request HttpServletRequest, response HttpServletResponse): void}}\\	
	Metodo usato per eseguire la richiesta di aggiungere un contatto in un gruppo. Nell'ordine proposto, devono essere eseguite le seguenti operazioni:
	\begin{itemize}
		\item creazione di un istanza di \classname{DataPersistanceManager} denominata groupDAO;
		\item creazione di una sessione \texttt{HttpSession} avente nome session;
		\item creazione degli oggetti rappresentanti la realtà della rubrica su cui opero: un \texttt{IAddressBookEntry} entry, \texttt{IGroup} group, \texttt{IUserData} user e \texttt{IUserData} friend;
		\item creazione di due identificativi di tipo long: contactId e groupId.
		\item creazione di un \texttt{PrintWriter} denominato \textit{writer} e di una stringa \textit{result} usata con lo scopo di memorizzare il contenuto testuale da scrivere sul writer come messaggio di notifica della \inglese{servlet};
		\item creazione di un istanza \texttt{DataPersistanceManager} userDAO.
	\end{itemize}
	Dopo questa fase di creazione delle variabili il metodo deve definire un costrutto \textit{try-catch}. All'interno del blocco catch dovrà essere predisposta la memorizzazione della parola ``\inglese{false}''. Passando invece alla definizione del blocco \textit{try}, al suo interno si dovranno predisporre le seguenti istruzioni:
	\begin{itemize}
		\item inizializzazione di session al valore ottenuto da una chiamata:\\
		\verb|request.getSession(false)|
		\item istanziazione di user a partire dal valore contenuto nella \textit{request}. Per la precisione si dovrà usare un istruzione del tipo:\\
		\verb|session.getAttribute("user")|
		\item con una procedura analoga alla precedente definisco il contenuto di contactID. Usare \verb|getParameter("contactId")| a partire dall'oggetto \textit{request};
		\item istruzione analoga alla precedente usata per istanziare il contenuto di groupId (nome del parametro da ottenere: groupId);
		\item inizializzare friend con una chiamata \method{getById} passando come parametro contactId.
		\item inizializzare group con una chiamata \method{getById} passando come parametro groupId.
		\item il metodo controlla se \texttt{group!=null}. Nel caso il flusso principale prosegue come segue: inizializzazione di \textit{entry} e modifica dei dati stessi di \textit{entry} mediante le chiamate a metodo dei vari ``set'' che la costituiscono. Nello specifico si intende impostare l'istanza in modo che definisca un contatto in rubrica non bloccato e registrato nel gruppo \textit{group}. Il possessore sarà user e il contatto registrato friend. Quindi viene eseguito l'\inglese{update} tramite una chiamata:\\
		\verb|userDAO.update(user)|
		result viene impostato a \textit{true} e il programma esce dal costrutto condizionale.
		\item se \textit{group} non era diverso da \textit{null} allora si entra nel ramo else del costrutto condizionale già citato. Result viene impostato a false e il metodo esce dal ramo else.
	\end{itemize}
	Il metodo termina scrivendo su \textit{writer} il contenuto di \textit{result}.
	
\end{description}

%TODO da verificare

\classsection{DeleteFromGroupController}

\subsubsection*{Funzione}
\inglese{Controller} richiamata dal \textit{front controller} per inserire un utente nella propria rubrica, all'interno di un gruppo ben determinato.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dal metodo \method{doAction()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doAction()}. Usata per scrivere l'output del \inglese{controller}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doAction()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client. \classname{abook.IAddressBookEntry}.
	\item \classname{abook.IGroup}:
Interfaccia che definisce il comportamento di un gruppo generico. La classe che verrà descritta crea istanze di tipo \classname{abook.IGroup}.
	\item \classname{abook.IUserData}:Interfaccia che definisce il comportamento di un utente generico. La classe che verrà descritta crea istanze di tipo \classname{abook.IUserData}.
	\item \classname{abook.AddressBookEntry}: classe usata per comunicare tramite \textit{Hibernate} con la tabella AddressBookEntry della base di dati.
	\item \classname{dao.DataPersistanceManager}: classe usata per comunicare tramite \textit{Hibernate} con la tabella Group e UserData della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{server.AbstractController}: classe estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato


\subsubsection*{Metodi}

\begin{description}
	\item{\method{\# doAction(request HttpServletRequest, response HttpServletResponse): void}}\\	
	Metodo usato per eseguire la richiesta di rimuovere un contatto da un gruppo. Nell'ordine proposto, devono essere eseguite le seguenti operazioni:
	\begin{itemize}
		\item creazione degli oggetti necessari al completamento dell'operazione:
		\begin{itemize}
			\item \classname{DataPersistanceManager} groupDAO;
			\item \texttt{HttpSession} session;
			\item \classname{IAddressBookEntry} entry;
			\item \classname{IGroup} group;
			\item \classname{IUserData} friend;
			\item \classname{IUserData} user;
			Long contactIdl;
			Long groupId;
			\item \classname{PrintWriter} writer;
			String result;
			\item \classname{DataPersistanceManager} userDAO;
		\end{itemize}
		
		\item quindi il metodo procede definendo un blocco \textit{try-catch}. Nel ramo \textit{catch} si imposta \textit{result} a \inglese{false}. Passando invece alla definizione del ramo \textit{try}, in esso devono essere definiti i seguenti punti:
		\begin{itemize}
			\item session viene impostato mediante una chiamata a metodo:
			\verb|request.getSession(false)|;
			\item user e groupID vengono impostate ottenendo l'omonimo attributo da \textit{request} (usare il metodo \texttt{getParameter(nome\_parametro)};
			\item impostare friend e group a partire dai relativi tipi di istanze DAO e facendosi restituire i dati presenti nel database tramite una chiamata a metodo \method{getByID} a cui passa i relativi id (contactId e groupid);
			\item avvia un costrutto condizionale dotato di ramo \textit{else}, se \texttt{group!=null} allora il metodo procede nel ramo \textit{if} andando ad impostare \textit{entry} con i relativi parametri, in modo da ricreare l'istanza \classname{IAddressBookEntry} da rimuovere dal database per mezzo del metodo \method{removeAddressBookEntry()} a cui passa \textit{entry}. 
			\item altrimenti, se \texttt{group == null} allora entra nel ramo else del costrutto condizionale e procede impostando \textit{result} a \inglese{false}.
		\end{itemize}
	\end{itemize}
	Il metodo termina scrivendo su \textit{writer} il contenuto di \textit{result}.
	
\end{description}

%TODO da verificare

\classsection{BlockContactController}

\subsubsection*{Funzione}
\inglese{Controller} richiamata dal \textit{front controller} per bloccare un contatto presente nella propria rubrica.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dal metodo \method{doAction()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doAction()}. Usata per scrivere l'output del \inglese{controller}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doAction()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \classname{abook.IAddressBookEntry}:Interfaccia che definisce il comportamento di una generica \inglese{entry} della rubrica utente. La classe che verrà descritta crea istanze di tipo \classname{abook.IAddressBookEntry}.
	\item \classname{abook.IUserData}:Interfaccia che definisce il comportamento di un utente generico. La classe che verrà descritta crea istanze di tipo \classname{abook.IUserData}.
	\item \classname{dao.DataPersistanceManager}: classe usata per comunicare tramite \textit{Hibernate} con la tabella UserData della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{server.AbstractController}: classe estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato


\subsubsection*{Metodi}

\begin{description}
	\item{\method{\# doAction(request HttpServletRequest, response HttpServletResponse): void}}\\	
	Metodo usato per eseguire la richiesta di bloccare un contatto presente in una rubrica utente. Nell'ordine proposto, devono essere eseguite le seguenti operazioni:
	\begin{itemize}
		\item creazione degli oggetti necessari al completamento dell'operazione:
		\begin{itemize}
			\item \classname{DataPersistanceManager} groupDAO;
			\item \texttt{HttpSession} session;
			\item \classname{IAddressBookEntry} entry;
			\item \classname{IUserData} friend;
			\item \classname{IUserData} user;
			Long contactIdl;
			\item \texttt{Iterator<IAddressBookEntry>} iterator;
			\item \texttt{Set<IAddressBookEntry>} entrys;
			\item \classname{PrintWriter} writer;
			String result;
			\item \classname{DataPersistanceManager} userDAO;
		\end{itemize}
		
		\item quindi il metodo procede definendo un blocco \textit{try-catch}. Nel ramo \textit{catch} si imposta \textit{result} a \inglese{false}. Passando invece alla definizione del ramo \textit{try} devono essere definiti i seguenti punti:
		\begin{itemize}
			\item \textit{session} viene impostato mediante una chiamata a metodo:
			\verb|request.getSession(false)|;
			\item \textit{user} viene impostato ottenendo l'omonimo attributo da \textit{request} (usare il metodo \texttt{getParameter(``user'')};
			\item impostare \textit{friend} a partire dal relativo tipo di istanza DAO e facendo restituire i dati presenti nel database tramite una chiamata a metodo \method{getByID} a cui passa il parametro \textit{contactId};
			\item avvia un costrutto condizionale dotato di ramo else. Se \texttt{friend!=null} il metodo procede nel ramo \textit{if} andando a scaricare l'elenco delle \textit{entry} a partire da \textit{user}. Quindi utilizzando l'iteratore \textit{iterator} va a scorrere tale set di \textit{entry} e quando verifica la presenza del contatto \textit{friend} all'interno, modifica l'\textit{entry} attualmente selezionata richiamando il metodo \method{setBlocked(true)}. Quindi prima di uscire dal costrutto \textit{if}, viene eseguita un operazione di \textit{update} a partire da user e si memorizza nella variabile \textit{result} il valore \inglese{true}.
			\item altrimenti, se \texttt{friend == null} allora entra nel ramo else del costrutto condizionale e procede impostando \textit{result} a \inglese{false}.
		\end{itemize}
	\end{itemize}
	Il metodo termina scrivendo su \textit{writer} il contenuto di \textit{result}.
	
\end{description}

%TODO da verificare

\classsection{UnblockContactController}

\subsubsection*{Funzione}
\inglese{Controller} richiamata dal \textit{front controller} per sbloccare un contatto presente nella propria rubrica.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dal metodo \method{doAction()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doAction()}. Usata per scrivere l'output del \inglese{controller}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doAction()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \classname{abook.IAddressBookEntry}:Interfaccia che definisce il comportamento di una generica \inglese{entry} della rubrica utente. La classe che verrà descritta crea istanze di tipo \classname{abook.IAddressBookEntry}.
	\item \classname{abook.IUserData}:Interfaccia che definisce il comportamento di un utente generico. La classe che verrà descritta crea istanze di tipo \classname{abook.IUserData}.
	\item \classname{dao.DataPersistanceManager}: classe usata per comunicare tramite \textit{Hibernate} con la tabella UserData della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{server.AbstractController}: classe estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato

\subsubsection*{Metodi}

\begin{description}
	\item{\method{\# doAction(request HttpServletRequest, response HttpServletResponse): void}}\\	
	Metodo usato per eseguire la richiesta di sbloccare un contatto presente in una rubrica utente. Nell'ordine proposto, devono essere eseguite le seguenti operazioni:
	\begin{itemize}
		\item creazione degli oggetti necessari al completamento dell'operazione:
		\begin{itemize}
			\item \classname{DataPersistanceManager} groupDAO;
			\item \texttt{HttpSession} session;
			\item \classname{IAddressBookEntry} entry;
			\item \classname{IUserData} friend;
			\item \classname{IUserData} user;
			Long contactIdl;
			\item \texttt{Iterator<IAddressBookEntry>} iterator;
			\item \texttt{Set<IAddressBookEntry>} entrys;
			\item \classname{PrintWriter} writer;
			String result;
			\item \classname{DataPersistanceManager} userDAO;
		\end{itemize}
		
		\item quindi il metodo procede definendo un blocco \textit{try-catch}. Nel ramo \textit{catch} si imposta \textit{result} a \inglese{false}. Passando invece alla definizione del ramo \textit{try}, in esso devono essere definiti i seguenti punti:
		\begin{itemize}
			\item \textit{session} viene impostato mediante una chiamata a metodo:
			\verb|request.getSession(false)|;
			\item user viene impostata ottenendo l'omonimo attributo da \textit{request} (usare il metodo \texttt{getParameter(``user'')};
			\item impostare\textit{friend} a partire dal relativo tipo di istanza DAO e facendo restituire i dati presenti nel database tramite una chiamata a metodo \method{getByID} a cui passa il parametro \textit{contactId};
			\item avvia un costrutto condizionale dotato di ramo else. Se \texttt{friend!=null} il metodo procede nel ramo \textit{if} andando a scaricare l'elenco delle \textit{entry} a partire da \textit{user}. Quindi utilizzando l'iteratore \textit{iterator} va a scorrere tale set di \textit{entry} e quando verifica la presenza del contatto \textit{friend\textit} all'interno, modifica l'\textit{entry} attualmente selezionata richiamando il metodo \method{setBlocked(false)}. Quindi prima di uscire dal costrutto \textit{if}, viene eseguita un operazione di \textit{update} a partire da \textit{user} e si memorizza nella variabile \textit{result} il valore \inglese{true}.
			\item altrimenti, se \texttt{friend == null} allora entra nel ramo else del costrutto condizionale e procede impostando \textit{result} a \inglese{false}.
		\end{itemize}
	\end{itemize}
	Il metodo termina scrivendo su \textit{writer} il contenuto di \textit{result}.
	
\end{description}

%TODO da verificare

\classsection{SearchController}

\subsubsection*{Funzione}
\inglese{Controller} richiamata dal \textit{front controller} per effettuare una ricerca sulla propria rubrica. La ricerca consiste nell'individuare tutti i contatti che contengono nei campi \textit{name}, \textit{surname} o \textit{email} la parola ricercata. Per eseguire questa procedura di ricerca ci si avvale del metodo \method{searchGeneric(nome\_parametro)} della classe \classname{DataPersistanceManager}.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dal metodo \method{doAction()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doAction()}. Usata per scrivere l'output del \inglese{controller}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doAction()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \classname{abook.IUserData}:Interfaccia che definisce il comportamento di un utente generico. La classe che verrà descritta crea istanze di tipo \classname{abook.IUserData}.
	\item \classname{dao.DataPersistanceManager}: classe usata per comunicare tramite \textit{Hibernate} con la tabella UserData della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{server.AbstractController}: classe estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato

\subsubsection*{Metodi}

\begin{description}
	\item{\method{\# doAction(request HttpServletRequest, response HttpServletResponse): void}}\\	
	Metodo usato per eseguire una ricerca generica sui contatti presenti nella rubrica del \textit{client}. Nell'ordine proposto, devono essere eseguite le seguenti operazioni:
	\begin{itemize}
		\item creazione degli oggetti necessari al completamento dell'operazione:
		\begin{itemize}
			\item \classname{IUserData} entry;
			\item \texttt{List<IUserData>} users;
			\item \texttt{Iterator<IUserData>} iterator;
			\item \texttt{Set<IAddressBookEntry>} entrys;
			\item \classname{PrintWriter} writer;
			\item String result e String parameter;
			\item \classname{DataPersistanceManager} userDAO;
		\end{itemize}
		
		\item quindi il metodo procede definendo un blocco \textit{try-catch}. Nel ramo \textit{catch} si imposta \textit{result} a \inglese{false}. Passando invece alla definizione del ramo \textit{try}, in esso devono essere definiti i seguenti punti:
		\begin{itemize}
			\item parameter viene impostato con il valore del parametro da ricercare. Tale operazione è da eseguirsi con l'istruzione:\\
			\verb|request.getParameter("param")|;
			\item quindi il metodo procede effettuando la ricerca del parametro. Tale operazione si svolge sfruttando le specifiche della classe \classname{DataPersistanceManager}. Nello specifico deve essere eseguita l'istruzione:\\
			\verb|users = userDAO.searchGeneric(parameter)|;
			\item a questo punto si dovrà predisporre un iteratore per scorrere la lista \textit{users};
			\item si imposta \textit{result} al valore ``{'' e si entra in un ciclo \inglese{while} che potrà terminare solo quando l'iteratore già citato avrà raggiunto l'ultimo elemento ispezionabile;
			\item dentro al ciclo \inglese{while} si procederà con la formattazione della stringa \textit{result} al fine di restituire al \textit{client} un formato sul quale possa operare. Nello specifico la stringa \textit{result} dovrà contenere (per ogni istanza di IUserData presente in \textit{users}):\\
			
			\verb|\"ID_della_entry":{"name":"NOME_UTENTE",|\\
			\verb|"surname":"COGNOME_UTENTE,"email":EMAIL_UTENTE",|\\
			\verb|"id":"ID_UTENTE","picturePath":"PATH_IMG",|\\
			\verb|"state":"STATO","block":"BLOCCATO/SBLOCCATO"},|\\
			
			Si osservi che in quanto è riportato in precedenza, ciò che è scritto in maiuscolo corrisponde al valore effettivo di quel parametro, quindi per esempio la parola NOME\_UTENTE sarà di fatto sostituita dall'effettivo nome dell'istanza \classname{IUserData} attualmente sotto esame. Per ottenere tali valori ricorrerà ai metodi: \texttt{getName()}, \texttt{getSurname()}, \texttt{getMail()}, \texttt{getId()}, \texttt{getPath()} richiamabili a partire dall'\textit{entry} attualmente sotto esame.
			\item al termine di tale procedura la stringa \textit{result} è pronta per essere restituita al \textit{client}, quindi si aggiunge a \textit{result} il valore ``}'', usato come carattere di terminazione.
		\end{itemize}
	\end{itemize}
	Il metodo termina scrivendo su \textit{writer} il contenuto di \textit{result}.
	
\end{description}

%TODO da verificare

\classsection{GetContactsController}

\subsubsection*{Funzione}
\inglese{Controller} richiamata dal \textit{front controller} per scaricare la lista dei contatti presenti nella propria rubrica.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dal metodo \method{doAction()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doAction()}. Usata per scrivere l'output del \inglese{controller}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doAction()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \classname{abook.IAddressBookEntry}:Interfaccia che definisce il comportamento di una \inglese{entry} della rubrica utente.
	\item \classname{abook.IUserData}:Interfaccia che definisce il comportamento di un utente generico. La classe che verrà descritta crea istanze di tipo \classname{abook.IUserData}.
	\item \classname{dao.DataPersistanceManager}: classe usata per comunicare tramite Hibernate con la tabella UserData della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{server.AbstractController}: classe estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato

\subsubsection*{Metodi}

\begin{description}
	\item{\method{\# doAction(request HttpServletRequest, response HttpServletResponse): void}}\\	
	Metodo usato per eseguire la richiesta di download della lista dei contatti. Nell'ordine proposto, devono essere eseguite le seguenti operazioni:
	\begin{itemize}
		\item creazione degli oggetti necessari al completamento dell'operazione:
		\begin{itemize}
			\item \texttt{HttpSession} session;
			\item \classname{IUserData} user;
			\item \classname{IUserData} friend;
			\item \texttt{Iterator<IAddressBookEntry>} iterator;
			\item \texttt{Set<IAddressBookEntry>} entrys;
			\item \classname{PrintWriter} writer;
			\item String result;
			\item \classname{IAddressBookEntry} entry;
		\end{itemize}
		
		\item quindi il metodo procede definendo un blocco \textit{try-catch}. Nel ramo \textit{catch} si imposta \textit{result} a \inglese{null}. Passando invece alla definizione del ramo \textit{try}, devono essere definiti i seguenti punti:
		\begin{itemize}
			\item session viene impostata tramite una chiamata a metodo del tipo:\\
			\verb|session = request.getSession(false)|;
			\item quindi il metodo procede impostando user a partire dalla sessione precedentemente creata. Tale operazione richiede l'uso del metodo \method{getAttribute(``user''};
			\item viene inizializzato l'insieme \textit{contacts} tramite una chiamata \method{getAddressBook()} richiamata a partire dalla variabile \textit{user};
			\item a questo punto si dovrà predisporre un iteratore per scorrere l'insieme \textit{contacts};
			\item si imposta \textit{result} al valore ``{'' e si entra in un ciclo \inglese{while} che potrà terminare solo quando l'iteratore già citato avrà raggiunto l'ultimo elemento ispezionabile;
			\item dentro al ciclo \inglese{while}, dopo aver impostato \textit{entry} al valore \texttt{next()} dell'iteratore, viene salvato in friend il contatto ritornato da una chiamata a \textit{entry}.\method{getContact()}. Si procederà  poi con la formattazione della stringa result al fine di restituire al \textit{client} un formato sul quale possa operare. Nello specifico la stringa result dovrà contenere (per ogni istanza di IUserData presente in users):\\
			
			\verb|\"ID_della_entry":{"name":"NOME_UTENTE",|\\
			\verb|"surname":"COGNOME_UTENTE,"email":EMAIL_UTENTE",|\\
			\verb|"id":"ID_UTENTE","picturePath":"PATH_IMG",|\\
			\verb|"state":"STATO","block":"BLOCCATO/SBLOCCATO"},|\\
			
			Si osservi che in quanto è riportato in precedenza, ciò che è scritto in maiuscolo corrisponde al valore effettivo di quel parametro. Quindi per esempio la parola NOME\_UTENTE sarà di fatto sostituita dall'effettivo nome dell'istanza \classname{IUserData} attualmente sotto esame. Per ottenere tali valori si ricorre ai metodi: \texttt{getName()}, \texttt{getSurname()}, \texttt{getMail()}, \texttt{getId()}, \texttt{getPath()} richiamabili a partire da friend.
			\item al termine di tale procedura la stringa \textit{result} è pronta per essere restituita al \textit{client}. Quindi si aggiunge a \textit{result} il valore ``}'', usato come carattere di terminazione.
		\end{itemize}
	\end{itemize}
	Il metodo termina scrivendo su \textit{writer} il contenuto di \textit{result}.
	
\end{description}

%TODO da verificare

\classsection{GetGroupsController}

\subsubsection*{Funzione}
\inglese{Controller} richiamata dal \textit{front controller} per scaricare la propria rubrica, provvista di gruppi e contatti in essi presenti.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dal metodo \method{doAction()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doAction()}. Usata per scrivere l'output del \inglese{controller}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doAction()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \classname{abook.IAddressBookEntry}:Interfaccia che definisce il comportamento di una \inglese{entry} della rubrica utente.
	\item \classname{abook.IUserData}:Interfaccia che definisce il comportamento di un utente generico. La classe che verrà descritta crea istanze di tipo \classname{abook.IUserData}.
		\item \classname{abook.IGroup}:Interfaccia che definisce il comportamento di un gruppo generico. La classe che verrà descritta crea istanze di tipo \classname{abook.IGroup}.
	\item \classname{dao.DataPersistanceManager}: classe usata per comunicare tramite \textit{Hibernate} con la tabella Group della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{server.AbstractController}: classe estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato

\subsubsection*{Metodi}

\begin{description}
\item{\method{\# doAction(request HttpServletRequest, response HttpServletResponse): void}}\\	
	Metodo usato per eseguire la richiesta di download della lista dei contatti utente). Nell'ordine proposto, devono essere eseguite le seguenti operazioni:
	\begin{itemize}
		\item creazione degli oggetti necessari al completamento dell'operazione:
		\begin{itemize}
			\item \texttt{HttpSession} session;
			\item \classname{DataPersistanceManager} groupDAO;
			\item \classname{IAddressBookEntry} entry;
			\item \classname{IGroup} group;
			\item \classname{IUserData} user;
			\item \texttt{Iterator<IAddressBookEntry>} entryIter;
			\item \texttt{Iterator<IGroup>} groupIter;
			\item \texttt{Set<IAddressBookEntry>} addentrys;
			\item \classname{PrintWriter} writer;
			\item String result;
		\end{itemize}
		
		\item quindi il metodo procede definendo un blocco \textit{try-catch}. Nel ramo catch si imposta \textit{result} a \inglese{false}. Passando invece alla definizione del ramo \textit{try}, in esso devono essere definiti i seguenti punti:
		\begin{itemize}
			\item session viene impostata tramite una chiamata a metodo del tipo:\\
			\verb|session = request.getSession(false)|;
			\item quindi il metodo procede impostando user a partire dalla sessione precedentemente creata. Tale operazione richiede l'uso del metodo \method{getAttribute(``user'')};
			\item viene inizializzato l'oggetto groupDAO;
			\item si inizializza la lista groups dei gruppi. Tale operazione deve essere eseguita mediante l'istruzione:\\
			\verb|groupDAO.getByOwner(user.getId())|
			\item il metodo definisce un costrutto condizionale \textit{if-else} basato sulla condizione \texttt{groups != null}. Nel ramo \textit{else} il metodo non fa altro che impostare \textit{result} a \inglese{false}. Nel ramo \textit{if} saranno definite le seguenti istruzioni:	
			\begin{itemize}
				\item predisporre un iteratore per scorrere l'insieme groups (inizializzazione di groupIter);
				\item si imposta \textit{result} al valore ``\{'' e si entra in un ciclo \inglese{while} che potrà terminare solo quando l'iteratore già citato avrà raggiunto l'ultimo elemento ispezionabile;
				\item all'interno del ciclo si estrae dall'iteratore il gruppo attualmente in esame e si salva sull'oggetto group;
				\item a partire da group, tramite una chiamata \method{getAddressBook()}, si ottiene la lista di entry di quel gruppo e la si slava in addEntry;
				\item si definisce un nuovo iteratore addEntry.\method{iterator()} e lo si memorizza in entryIter;
				\item si ``scrive'' dentro a \textit{result}, i dati inerenti il gruppo in esame (name, id) e si aggiunge la stringa ``contacts:['';
				\item si entra in un nuovo ciclo \inglese{while} che cicla sulle \textit{entry} dell'iteratore entryIter. All'interno di tale ciclo si estraggono le \textit{entry} che costituiscono i contatti del gruppo in esame e si riporta in result l'id di tali contatti (usare metodo \method{getId()});
				\item all'uscita del ciclo \inglese{while} più interno si concatena al contenuto di \textit{result} la stringa ``]\}'';
				\item all'uscita del ciclo \inglese{while} più esterno si concatena al contenuto di \textit{result} la stringa ``\}'';
			\end{itemize}
		\end{itemize}
	\end{itemize}
	Il metodo termina scrivendo su \textit{writer} il contenuto di \textit{result}.	
	
\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.call}\label{sec:call}

\classsection{ICall}

\subsubsection*{Funzione}
Interfaccia che rappresenta una chiamata effettuata dal sistema \caName. Gli oggetti che implementano tale interfaccia vengono usati per rappresentare lo storico delle chiamate di un utente.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.util.Date}: tipo utilizzato per definire la data d'inizio e fine di una chiamata.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

\begin{itemize}
	\item \texttt{org.softwaresynthesis.mytalk.server.IMyTalkObject}: interfaccia estesa. Utilizzata per dire che la classe è da considerarsi come un \texttt{transfer object} gestito da \texttt{Hibernate}.
\end{itemize}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce l'identificativo univoco della chiamata.
	\item{\method{+ getStart(): Date}}\\
	Restituisce un istanza di \texttt{java.util.Date} di avvio della chiamata.
	\item{\method{+ setStart(startDate: Date): void}}\\
	Imposta la data di avvio della chiamata.
	\item{\method{+ getEnd(): Date}}\\
	Restituisce la data in cui termina la chiamata
	\item{\method{+ setEnd(endDate: Date): void}}\\
	Imposta la data in cui termina la chiamata.
	\item{\method{+ getCall(): Set<ICallList>}}\\
	Metodo usato per ottenere la lista dei partecipanti alla chiamata.
	\item{\method{+ setCall(callList: Set<ICallList>): void}}\\
	Metodo usato per impostare la lista dei partecipanti alla chiamata.
	\item{\method{+ addCall(call: ICallList): boolean}}\\
	Metodo usato per aggiungere un partecipante alla chiamata.
	\item{\method{+ removeCall(call: ICallList): boolean}}\\
	Metodo usato per rimuovere un partecipate alla chiamata 
\end{description}

\classsection{Call}

\subsubsection*{Funzione}
Classe che implementa l'interfaccia \classname{ICall}.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.util.Date}: tipo utilizzato per definire la data d'inizio e fine di una chiamata.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \classname{ICall} interfacci d'implementazione.
\end{itemize}

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{-- id: long}}
	Attributo contenente il codice identificativo della chiamata.
	\item{\memberdata{-- startDate: Date}}
	Attributo di tipo \texttt{java.util.Date} contenente la data (compresa l'ora) d'inizio della chiamata.
	\item{\memberdata{-- endDate: Date}}
	Attributo di tipo \texttt{java.util.Date} contenente la data (compresa l'ora) in cui la chiamata è terminata.
	\item{\memberdata{-- calls: Set<ICallList>}}
	Attributo usato per definire la lista dei partecipanti alla chiamata.
\end{itemize}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce l'identificativo univoco della chiamata ritornando il contenuto dell'attributo \memberdata{id}.
	\item{\method{+ getStart(): Date}}\\
	Restituisce il contenuto del campo \memberdata{startDate}.
	\item{\method{+ setStart(startDate: Date): void}}\\
	Imposta la data di avvio della chiamata, sovrascrivendo il contenuto \memberdata{startData}.
	\item{\method{+ getEnd(): Date}}\\
	Restituisce il contenuto del campo \memberdata{endDate}.
	\item{\method{+ setEnd(endDate: Date): void}}\\
	Imposta la data di avvio della chiamata, sovrascrivendo il contenuto \memberdata{endData}.
	\item{\method{+ getCall(): Set<ICallList>}}\\
	Restituisce il contenuto del campo \memberdata{calls}.
	\item{\method{+ setCall(callList: Set<ICallList>): void}}\\
	Metodo usato per impostare la lista dei partecipanti alla chiamata. Sovrascrive il contenuto di \memberdata{calls}.
	\item{\method{+ addCall(call: ICallList): boolean}}\\
	Metodo usato per aggiungere un partecipante alla chiamata. Aggiunge al \memberdata{calls} un nuovo partecipante (call). Il metodo termina ritornando \inglese{true} se l'operazione va a buon fine. \inglese{false} altrimenti.
	\item{\method{+ removeCall(call: ICallList): boolean}}\\
	Metodo usato per rimuovere un partecipate alla chiamata. La rimozione avviene invocando il metodo \texttt{remove(call)} dall'attributo \memberdata{calls}. Il metodo ritorna un valore booleano per indicare l'esisto dell'operazione: \inglese{false} in presenza di errori, \inglese{true} altrimenti.
\end{description}

\classsection{ICallList}

\subsubsection*{Funzione}
Interfaccia rappresentante una \textit{entry} di uno storico chiamate di un utente del sistema mytalk.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \classname{IUserData}: l'interfaccia \classname{ICallList} definisce più metodi che restituiscono oggetti aventi tipo di ritorno \classname{IUserData}, essi sono i metodi \inglese{get} per ottenere l'utente che ha effettuato la chiamta. Analogamente \classname{IUserData} viene usato come parametro d'ingresso per i metodi \inglese{set} collegati ai metodi già citati.
	\item \classname{ICall}: l'interfaccia \classname{ICallList} definiscono metodi che restituiscono oggetti aventi tipo di ritorno \classname{ICall}.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{org.softwaresynthesis.mytalk.server.IMyTalkObject}: interfaccia da estendere. Ogni oggetto che implementerà l'interfaccia \classname{ICallList} dovrà essere in grado di convertire il proprio contenuto informativo in formato \textit{Json}.
\end{itemize}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce l'identificativo univoco di una \inglese{entry} di uno storico chiamate.
	
	\item{\method{+ setIdCall(call: ICall): void}}\\
	Imposta l'id della chiamta \classname{ICall} (passato come parametro d'ingresso).
	\item{\method{+ getIdCall(): IUserData}}\\
	Restituisce un id di un oggetto avente tipo \classname{ICall} rappresentante una chiamata effettuata dall'utente.
	
	\item{\method{+ setIdUser(contact: IUserData): void}}\\
	Imposta l'id dell'utente \classname{IUserData} (passato come parametro d'ingresso) come l'utente che ha effettuato la chiamata.
	\item{\method{+ getIdUser(): IUserData}}\\
	Restituisce l'id di oggetto avente tipo \classname{IUserData} rappresentante l'utente che ha effettuato la chiamata.
	
	\item{\method{+ setCaller(caller: boolean): void}}\\
	Imposta l'utente che ha effettuato la chiamata come chiamante se il parametro ricevuto ha valore true.
	\item{\method{+ getCaller(): boolean}}\\
	Ritorna un valore di tipo bool se l'utente della chiamata è colui che l'ha iniziata o meno.
\end{description}




\classsection{CallList}

\subsubsection*{Funzione}
Classe che implementa l'interfaccia \classname{ICallList}.

\subsubsection*{Relazioni d'uso}

Nessuna relazione evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{call.ICallList}: interfaccia implementata dalla classe.
\end{itemize}

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{-- id: long}}
	Attributo contenente il codice identificativo dello storico chiamata.
	\item{\memberdata{-- idCall: long}}
	Attributo contenente il codice identificativo della chiamata.
	\item{\memberdata{-- idUser: long}}
	Attributo contenente il codice identificativo dell'utente partecipante alla chiamata.
	\item{\memberdata{-- caller: boolean}}
	Attributo che identifica se l'utente è il chiamante o meno.
\end{itemize}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce il valore dell'attributo \memberdata{id}.
	
	\item{\method{+ setIdCall(call: Long): void}}\\
	Imposta il valore dell'attributo \memberdata{idCall} con il valore ricevuto da parametro ``call''.
	\item{\method{+ getIdCall(): Long}}\\
	Restituisce il valore dell'attributo \memberdata{idCall}.
	
	\item{\method{+ setIdUser(contact: Long): void}}\\
	Imposta il valore dell'attributo \memberdata{idUser} con il valore ricevuto da parametro ``contact''.
	\item{\method{+ getIdUser(): Long}}\\
	Restituisce il valore dell'attributo \memberdata{idUser}.
	
	\item{\method{+ setCaller(caller: boolean): void}}\\
	Imposta il valore dell'attributo \memberdata{caller} con il valore ricevuto da parametro ``caller''.
	\item{\method{+ getCaller(): boolean}}\\
	Restituisce il valore dell'attributo \memberdata{caller}.
\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.call.controller}\label{sec:callServlet}

\classsection{GetCallsController}

\subsubsection*{Funzione}
\texttt{Controller} da richiamare per effettuare il download della lista che rappresenta lo storico delle chiamate effettuate e ricevute dell'utente. I dati vengono ritornati sotto forma di stringa in formato JSON.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dal metodo\method{doAction()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doAction()}. Usata per scrivere l'output del \inglese{controller}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doAction()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \classname{call.ICall}: usata per definire un oggetto rappresentante una chiamata.
	\item \classname{abook.IUserData}: usata per definire un utente generico, che ha partecipato alla chiamata.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{server.AbstractController}: classe estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato

\subsubsection*{Metodi}
\begin{description}
	
	\item{\method{\# doAction(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Metodo usato per accedere alla funzionalità della \texttt{controller}. Il procedimento da definire passa attraverso 3 step essenziali:
	\begin{itemize}
		\item \texttt{Inizializzazione}: il metodo definisce ed apre una nuova sessione a partire dalla richiesta request passata come parametro;
		\item \texttt{Elaborazione dati}: il metodo interroga il database attraverso la classe \classname{DataPersistanceManager}. Per ogni oggetto \classname{ICall} in cui si evidenzia che uno dei due partecipanti è il client (\classname{IUserData}) che ha inoltrato la richiesta al \texttt{front controller}, si aggiunge alla stringa result da ritornare i dati di tale chiamata. Nello specifico la formattazione della stringa di ritorno, dovrà descrivere la seguente logica:\\
		
		\verb|{name:"NOME_UTENTE",start="DATA_INIZIO",end="DATA_FINE"}|\\
		
		Si consideri che la dove vi è un nome in maiuscolo, vi dovrà essere il dato inerente estrapolato dall'istanza \classname{ICall} presa in considerazione.
		\item \texttt{Restituzione risultato}: dopo aver elaborato i dati, il \texttt{controller} dovrà scrivere nel \texttt{PrintWriter} associato alla request:
			\begin{itemize}
				\item una stringa formattata come sopra, se l'utente ha effettuato o ricevuto almeno una chiamata;
				\item null, altrimenti.
			\end{itemize}
	\end{itemize}

\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.message}\label{sec:message}

\classsection{IMessage}

\subsubsection*{Funzione}
Interfaccia che rappresenta un messaggio di segreteria del sistema \caName.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.util.Date}: tipo utilizzato per definire la data in cui è stato registrato un messaggio.
	\item \classname{abook.IUserData}: usata per rappresentare il mittente e il destinatario del messaggio di segreteria.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

\begin{itemize}
	\item \texttt{org.softwaresynthesis.mytalk.server.IMyTalkObject}: interfaccia estesa. Utilizzata per dire che la classe è da considerarsi come un \texttt{transfer object} gestito da \texttt{Hibernate}.
\end{itemize}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce l'identificativo univoco del messaggio.
	\item{\method{+ getSender(): IUserData}}\\
	Restituisce un istanza di tipo classname{abook.IUserData} che rappresenta il mittente del messaggio.
	\item{\method{+ setSender(sender: IUserData): void}}\\
	Imposta il mittente del messaggio.
	\item{\method{+ getReceiver(): IUserData}}\\
	Restituisce un istanza di tipo classname{abook.IUserData} che rappresenta il destinatario del messaggio.
	\item{\method{+ setReceiver(receiver: IUserData): void}}\\
	Imposta il destinatario del messaggio.
	\item{\method{+ getNewer(): boolean}}\\
	Restituisce un valore booleano che identifica lo stato del messaggio (``già letto'' se il valore ritornato è \textit{true}, ``da leggere'' se il valore ritornato è \textit{false}).
	\item{\method{+ setNewer(status: boolean): void}}\\
	Imposta il messaggio come ``già ascoltato'' o come ``da ascoltare''.
	\item{\method{+ getVideo(): boolean}}\\
	Restituisce un booleano che determina se si tratta di un messaggio audio oppure audio-video.
	\item{\method{+ setVideo(video: boolean): void }}\\	
	Imposta il messaggio come messaggio audio-video o come messaggio contenente solamente una traccia audio.
	\item{\method{+ getDate(): Date}}\\
	Restituisce la data in cui il mittente ha lasciato il messaggio nella segreteria del destinatario.
	\item{\method{+ setDate(date: Date): void}}\\
	Imposta la data in cui il mittente ha lasciato il messaggio nella segreteria del destinatario.
\end{description}

\classsection{Message}

\subsubsection*{Funzione}
Classe che implementa l'interfaccia \classname{IMessage}.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.util.Date}: tipo utilizzato per definire la data in cui è stato registrato un messaggio.
	\item \classname{abook.IUserData}: usata per rappresentare il mittente e il destinatario del messaggio di segreteria.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \classname{message.IMessage}: interfaccia d'implementazione.
\end{itemize}

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{-- id: long}}
	Attributo contenente il codice identificativo del messaggio.
	\item{\memberdata{-- sender: IUserData}}
	Attributo contenente lo \classname{IUserData} che rappresenta il destinatario del messaggio.
	\item{\memberdata{-- receiver: IUserData}}
	Attributo contenente lo \classname{IUserData} che rappresenta il destinatario del messaggio.
	\item{\memberdata{-- status: boolean}}
	Attributo contenente un valore booleano che identifica se il messaggio è stato visionato/ascoltato o meno. L'attributo se impostato a \textit{true}, designa il messaggio come \textit{ascoltato}. Invece se impostato a \textit{false} identifica il messaggio come \textit{ancora da ascoltare}.
	\item{\memberdata{-- video: boolean}}
	Attributo che stabilisce se il messaggio contiene o meno una traccia video. Si ricorda che ogni messaggio contiene (di \inglese{default}) una traccia audio. Se tale attributo è impostato a \textit{true} allora il messaggio contiene una traccia video.
	\item{\memberdata{-- date: Date}}
	Attributo che definisce l'orario di invio del messaggio.
\end{itemize}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce l'identificativo univoco del messaggio, ritornando il contenuto di \memberdata{id}.
	\item{\method{+ getSender(): IUserData}}\\
	Restituisce un istanza di tipo classname{abook.IUserData} che rappresenta il mittente del messaggio. Nello specifico il metodo ritorna l'attributo \memberdata{sender}.
	\item{\method{+ setSender(sender: IUserData): void}}\\
	Imposta il mittente del messaggio, sovrascrivendo il contenuto dell'attributo \memberdata{sender}.
	\item{\method{+ getReceiver(): IUserData}}\\
	Restituisce un istanza di tipo classname{abook.IUserData} che rappresenta il destinatario del messaggio. Nello specifico il metodo ritorna l'attributo \memberdata{receiver}.
	\item{\method{+ setReceiver(receiver: IUserData): void}}\\
	Imposta il destinatario del messaggio, sovrascrivendo il contenuto dell'attributo \memberdata{receiver}.
	\item{\method{+ getNewer(): boolean}}\\
	Metodo che ritorna il contenuto dell'attributo \memberdata{status}.
	\item{\method{+ setNewer(status: boolean): void}}\\
	Imposta il messaggio come ``già ascoltato'' o come ``da ascoltare'', sovrascrivendo il contenuto dell'attributo \memberdata{status}.
	\item{\method{+ getVideo(): boolean}}\\
	Restituisce il contenuto dell'attributo \memberdata{video}.
	\item{\method{+ setVideo(video: boolean): void }}\\	
	Metodo usato per impostare la ``natura'' del messaggio, impostando il contenuto dell'attributo \memberdata{video} mettendolo a \textit{true} se il messaggio contiene una traccia video, oppure a \textit{false} se non la contiene.
	\item{\method{+ getDate(): Date}}\\
	Restituisce la data in cui il mittente ha lasciato il messaggio nella segreteria del destinatario, ritornando il contenuto dell'attributo \memberdata{date}.
	\item{\method{+ setDate(date: Date): void}}\\
	Imposta la data in cui il mittente ha lasciato il messaggio nella segreteria del destinatario, sovrascrivendo il contenuto dell'attributo \memberdata{date}.

\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.message.controller}\label{sec:messageServlet}

\classsection{AddMessageController}

\subsubsection*{Funzione}
\inglese{Controller} da richiamare per inserire un messaggio nella segreteria di un utente.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dal metodo\method{doAction()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doAction()}. Usata per scrivere l'output della del \inglese{controller}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doAction()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \classname{message.IMessage}: usata per definire un oggetto rappresentante un messaggio in segreteria.
	\item \classname{abook.IUserData}: usata per definire un utente generico, che ha partecipato alla chiamata.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{server.AbstractController}: classe estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato

\subsubsection*{Metodi}
\begin{description}
	
	\item{\method{\# doAction(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Metodo usato per accedere alla funzionalità del \inglese{controller}. Il procedimento da definire passa attraverso 3 step essenziali:
	\begin{itemize}
		\item \texttt{Inizializzazione}: il metodo definisce ed apre una nuova sessione a partire dalla richiesta request passata come parametro;
		\item \texttt{Elaborazione dati}: il metodo procede creando un \classname{IMessage} con i dati forniti dalla request e dopo aver aperto una \texttt{transaction} verso il database, esegue l'operazione \method{save()} sul relativo oggetto DAO. Al termine sarà necessario procedere con un operazione di \texttt{commit}. Nel realizzare il metodo, il programmatore incaricato dovrà tenere in considerazione la possibilità di fallimento durante l'esecuzione delle operazioni mediante la \texttt{transaction}. Ciò andrà gestito mediante un operazione di \texttt{rollback} atta ad eliminare una possibile inconsistenza dei dati.
		\item \texttt{Restituzione risultato}: dopo aver elaborato i dati, la \inglese{servlet} dovrà scrivere nel \texttt{PrintWriter} associato alla request:
			\begin{itemize}
				\item ``\inglese{true}'' se l'operazione è andata a buon fine;
				\item ``\inglese{false}'' altrimenti.
			\end{itemize}
	\end{itemize}

\end{description}

\classsection{DeleteMessageController}

\subsubsection*{Funzione}
\inglese{Controller} da richiamare per eliminare un messaggio.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dal metodo\method{doAction()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doAction()}. Usata per scrivere l'output della del \inglese{controller}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doAction()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \classname{message.IMessage}: usata per definire un oggetto rappresentante un messaggio in segreteria.
	\item \classname{abook.IUserData}: usata per definire un utente generico, che ha partecipato alla chiamata.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{server.AbstractController}: classe estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato

\subsubsection*{Metodi}
\begin{description}

\item{\method{\# doAction(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Metodo usato per accedere alla funzionalità della \inglese{controller}. Il procedimento da definire passa attraverso 3 step essenziali:
	\begin{itemize}
		\item \texttt{Inizializzazione}: il metodo definisce ed apre una nuova sessione a partire dalla richiesta request passata come parametro;
		\item \texttt{Elaborazione dati}: il metodo procede creando un \classname{IMessage} con i dati forniti dalla request e dopo aver aperto una \texttt{transaction} verso il database, esegue un operazione di ricerca dell'instanza appena creata all'interno della lista di \classname{IMessage} ottenuta dal db. Quindi se si verifica che tale istanza è effettivamente presente nel database, il metodo esegue l'operazione \method{delete()} sul relativo oggetto DAO. Al termine sarà necessario procedere con un operazione di \texttt{commit}. Nel realizzare il metodo, il programmatore incaricato dovrà tenere in considerazione la possibilità di fallimento durante l'esecuzione delle operazioni mediante la \texttt{transaction}. Ciò andrà gestito mediante un operazione di \texttt{rollback} atta ad eliminare una possibile inconsistenza dei dati.
		\item \texttt{Restituzione risultato}: dopo aver elaborato i dati, il \texttt{controller} dovrà scrivere nel \texttt{PrintWriter} associato alla request:
			\begin{itemize}
				\item ``\inglese{true}'' se l'operazione è andata a buon fine;
				\item ``\inglese{false}'' altrimenti (compreso non solo il caso di errore dovuto ad un problema di connessione verso il db, ma anche quello relativo al mancato match del elemento ricercato con quelli presenti nel database).
			\end{itemize}
	\end{itemize}

\end{description}

\classsection{UpdateStatusMessageController}

\subsubsection*{Funzione}
\inglese{Controller} da richiamare per modificare lo stato di un messaggio. L'idea alla base è che un messaggio può trovarsi in uno dei seguenti due stati:
\begin{itemize}
	\item letto;
	\item non letto;
\end{itemize}
Il \inglese{controller} permette di effettuare una transizione di stato da ``non letto'' a ``letto''.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dal metodo\method{doAction()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doAction()}. Usata per scrivere l'output della del \inglese{controller}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doAction()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \classname{message.IMessage}: usata per definire un oggetto rappresentante un messaggio in segreteria.
	\item \classname{abook.IUserData}: usata per definire un utente generico, che ha partecipato alla chiamata.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{server.AbstractController}: classe estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato


\subsubsection*{Metodi}
\begin{description}
	\item{\method{\# doAction(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Il procedimento da definire passa attraverso 3 step essenziali:
	\begin{itemize}
		\item \texttt{Inizializzazione}: il metodo definisce ed apre una nuova sessione a partire dalla richiesta request passata come parametro;
		\item \texttt{Elaborazione dati}: il metodo procede creando un \classname{IMessage} con i dati forniti dalla request e dopo aver aperto una \texttt{transaction} verso il database, esegue un operazione di ricerca dell'instanza appena creata all'interno della lista di \classname{IMessage} ottenuta dal db. Quindi se si verifica che tale istanza è effettivamente presente nel database, il metodo esegue l'operazione \method{update()} sul relativo oggetto DAO, andando a modificare lo stato in di lettura del messaggio. Al termine sarà necessario procedere con un operazione di \texttt{commit}. Nel realizzare il metodo il programmatore incaricato dovrà tenere in considerazione la possibilità di fallimento durante l'esecuzione delle operazioni mediante la \texttt{transaction}. Ciò andrà gestito mediante un operazione di \texttt{rollback} atta ad eliminare una possibile inconsistenza dei dati.
		\item \texttt{Restituzione risultato}: dopo aver elaborato i dati, il \inglese{controller} dovrà scrivere nel \texttt{PrintWriter} associato alla request:
			\begin{itemize}
				\item ``\inglese{true}'' se l'operazione è andata a buon fine;
				\item ``\inglese{false}'' altrimenti.
			\end{itemize}
	\end{itemize}

\end{description}

\classsection{GetMessagesController}

\subsubsection*{Funzione}
\inglese{Controller} da richiamare per scaricare la lista di messaggi attualmente presenti nella propria segreteria.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dal metodo\method{doAction()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doAction()}. Usata per scrivere l'output della del \inglese{controller}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doAction()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \classname{message.IMessage}: usata per definire un oggetto rappresentante un messaggio in segreteria.
	\item \classname{abook.IUserData}: usata per definire un utente generico, che ha partecipato alla chiamata.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{server.AbstractController}: classe estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato

\subsubsection*{Metodi}
\begin{description}
	\item{\method{\# doAction(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Il procedimento da definire passa attraverso 3 step essenziali:
	\begin{itemize}
		\item \texttt{Inizializzazione}: il metodo definisce ed apre una nuova sessione a partire dalla richiesta request passata come parametro;
		\item \texttt{Elaborazione dati}: quindi esegue un operazione di download degli oggetti \classname{IMessage} il cui possessore è l'utente che ha fatto richiesta di \inglese{download}. in seguito a tale operazione, sarà necessario popolare e formattare la stringa di ritorno come segue: per ogni messaggio presente nella lista si dovrà riportare la dicitura:\\
		
		\verb|{name:"NOME_UTENTE",state="LETTO/NON LETTO"|\\
		\verb|,url="INDIRIZZO_MESSAGGIO",data="DATA_REGISTRAZIONE_MESSAGGIO"}|\\
	
		\item \texttt{Restituzione risultato}: dopo aver elaborato i dati, il \inglese{controller} dovrà scrivere nel \texttt{PrintWriter} associato alla request:
			\begin{itemize}
				\item la sequenza
				\item null, altrimenti.
			\end{itemize}
	\end{itemize}

\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.authentication.security}\label{sec:authentication}

\classsection{ISecurityStrategy}

\subsubsection*{Funzione}
Interfaccia che identifica il comportamento di una strategia generica di crittografia dei dati.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione d'uso evidenziata.

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ encrypt(plainText: String): String}}\\
	Cripta la stringa di testo ricevuta come parametro e la restituisce al chiamante.\\\\
	Il metodo può solleva eccezioni:
	\begin{itemize}
		\item \exception{IOException}: l'implementazione di tale metodo dovrà predisporre il lancio di un eccezione qualora il messaggio passato al metodo (plainText) sia vuoto.
	\end{itemize}
	\item{\method{+ decrypt(encryptedText: String)}}\\
	Decripta la stringa di testo ricevuta come parametro e la restituisce al chiamante.\\\\
	Il metodo può sollevare eccezioni:
	\begin{itemize}
		\item \exception{IOException}: l'implementazione di tale metodo dovrà predisporre il lancio di un eccezione qualora il messaggio passato al metodo (plainText) sia vuoto.
	\end{itemize}
\end{description}

\classsection{AESAlgorithm}

\subsubsection*{Funzione}
Implementazione della strategia di codifica/decodifica con l'uso dell'algoritmo AES a 128bit.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.security.Key}: usata per creare un istanza di una chiave durante il processo di criptazione.
	\item \texttt{javax.crypto.Cipher}: usata per creare un istanza di un oggetto di criptazione che implementa l'algoritmo AES a 128 bit.
	\item \texttt{javax.crypto.spec.SecretKeySpec}: usata dall'algoritmo di per costruire una chiave segreta a partire da un array di byte.
	\item \texttt{sun.misc.BASE64Encoder}: utilizzata per eseguire una trasformazione da stringa a byte.
	\item \texttt{sun.misc.BASE64Decoder}: utilizzata per eseguire una trasformazione da byte in stringa.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \classname{ISecurityStrategy}: interfaccia d'implementazione.
\end{itemize}

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{-- \{frozen\} \underline{keyValue}: byte[]}}\\
  Array di byte usato per definire il valore della chiave su cui si basa l'algoritmo AES di criptazione. La chiave effettiva sarà creata a partire da tale attributo, per mezzo della classe \texttt{javax.crypto.spec.SecretKeySpec}.
  \item{\memberdata{-- \{frozen\} \underline{algorithm}: String}}\\
  Stringa costante che identifica il nominativo dell'algoritmo usato, e che dovrà essere specificato durante l'uso di \texttt{javax.crypto.Cipher}. l'attributo avrà valore ``AES''.
\end{description}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{- generateKey(): Key}}\\
	Metodo che restituisce una chiave di tipo \texttt{java.security.Key}, a partire dall'array \memberdata{keyValue}. Per fare ciò, il metodo usa il costruttore di \texttt{javax.crypto.spec.SecretKeySpec}.
	Il metodo può sollevare eccezioni:
	\begin{itemize}
		\item \exception{Exception}: il metodo può sollevare un'eccezione generica.
	\end{itemize}
	\item{\method{+ encrypt(plainText: String): String}}\\
	Metodo usato per criptare un testo di tipo \texttt{String} passato come parametro d'ingresso. Il metodo usa una chiave ottenuta a partire dal metodo \method{generateKey()} in associazione alla classe \texttt{javax.crypto.Cipher} per criptare il testo tramite l'algoritmo AES.
	\begin{itemize}
		\item \exception{Exception}: il metodo solleva un'eccezione.
	\end{itemize}
	\item{\method{+ decrypt(encryptedText: String)}}\\
	Decripta la stringa di testo ricevuta come parametro, attuando una procedura inversa a quella presentata nel metodo \method{encrypt(plainText: String)}\\\\
	Il metodo può sollevare eccezioni:
	\begin{itemize}
		\item \exception{Exception}: il metodo può sollevare un'eccezione generica.
	\end{itemize}
\end{description}

\classsection{AESTemplate}

\subsubsection*{Funzione}
Rappresenta la struttura dell'algoritmo di crittografia AES a 128 bit. Implementa \texttt{template method}.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.security.Key};
	\item \texttt{javax.crypto.Cipher};
	\item \texttt{javax.crypto.spec.SecretKeySpec};
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{-- key: byte[]}}\\
  Array di byte usato per definire il valore della chiave su cui si basa l'algoritmo AES di criptazione. La chiave effettiva sarà creata a partire da tale attributo, per mezzo della classe \texttt{javax.crypto.spec.SecretKeySpec}.
  \item{\memberdata{-- cipher: Cipher}}\\
  Oggetto rappresentante l'algoritmo di criptazione.
  \item{\memberdata{-- generated: Key}}\\
  Oggetto rappresentante la chiave generata dall'algoritmo di criptazione.
\end{description}

\subsubsection*{Metodi}
\begin{description}

	\item{\method{+ AESTemplate()}}\\
	Costruttore pubblico. imposta key con il seguente contenuto:\\
	\verb|new byte[]{'C', 'p', '2', 'Q', 'j', 'w', 'M', 'F', '7', 'e', 'j', 'N', 't', 'd', 'b', '1'};|.

	\item{\method{+ \{frozen\} execute(text: String): String}}\\
	Metodo che definisce l'iter di esecuzione di una generica procedura riguardante il sistema di sicurezza. Il metodo si occupa di inizializzare il cifratore \memberdata{cipher} mediante il metodo \texttt{getIstance(''AES'')}. Quindi si imposta il contenuto di \memberdata{generated} con ciò che viene restituito da \texttt{SecretKeySpec(this.key, ''AES'')}. Il metodo invoca \method{compleateAlgorithm}, e salva il suo valore di ritorno in una Stringa denominata result. Il metodo termina restituendo result

	\item{\method{\# \{abstract\} compleateAlgotihm(text: String): String}}\\
	Metodo astratto. Costituisce l'implementazione del pattern \texttt{template method}.

	\item{\method{\# getCipher(): Cipher}}\\
	Metodo che restituisce il cifratore \memberdata{cipher} alle sottoclassi in modo che possano criptare/decriptare il testo.

	\item{\method{\# getGenerateKey(): Key}}\\
	Metodo che restituisce una chiave di tipo \texttt{java.security.Key}, a partire dall'attributo \memberdata{generated}.
	
\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.authentication}\label{sec:authentication}

\classsection{PrincipalImpl}

\subsubsection*{Funzione}
Oggetto che permette di identificate univocamente uno \texttt{IUserData} memorizzato nel database del sistema \caName.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.Serializable}: interfaccia d'implementazione usata per rendere serializzabili le istanze della classe.
	\item \texttt{java.security.Principal}: interfaccia d'implementazione usata per rendere caratterizzate le istanze della classe.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{-- \{frozen\} \underline{serialVersionUID}: long}}\\
  Identificativo univoco per la classe, usato al fine di rendere l'oggetto serializzabile.
  \item{\memberdata{-- mail: String}}\\
  Attributo che rappresenta l'indirizzo e-mail dell'utente.
\end{description}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ PrincipalImpl(mail: String)}}\\
	Classe costruttore. crea un oggetto \texttt{PrincipalImpl} che permette di determinare univocamente lo \texttt{IUserData} che ha effettuato il login.
	\item{\method{+ getName(): String}}\\
	Restituisce l'elemento identificativo (mail dell'utente) dello \texttt{IUserData} che ha effettuato la procedura di login.
	\item{\method{+ equals(obj: Object): boolean}}\\
	Verifica l'uguaglianza di due oggetti \texttt{PrincipalImpl} sulla base di un confronto tra gli indirizzi mail degli utenti confrontati.
	\item{\method{+ hashCode(): int}}\\
	Restituisce il codice hash dell'oggetto di invocazione.				\item{\method{+ toString(): String}}\\
	Restituisce l'istanza dell'oggetto sotto forma di stringa. In particolare evidenziando l'indirizzo e-mail dell'utente.
\end{description}

\classsection{AuthenticationModule}

\subsubsection*{Funzione}
Modulo di autenticazione utilizzato dal sistema \caName.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException}: la classe è in grado di sollevare eccezioni relative a operazioni di IO.
	\item \texttt{java.security.Principal}: cinterfaccia che definisce i dati di autenticazione di un utente.
	\item \texttt{java.util.Map}: parametri passati ad \method{iniziaile()}.
	\item \texttt{java.util.Set}: la classe può definire istanze di Set, per memorizzare i dati trattati.
	\item \texttt{javax.security.auth.callback.Callback}: vettore utilizzato per contenere i dati di autenicazione.
	\item \texttt{javax.security.auth.callback.CallbackHandler}: parametri passati ad \method{iniziaile()}.
	\item \texttt{javax.security.auth.callback.NameCallback}: oggetto che contiene il name dell'utente da autenticare.
	\item \texttt{javax.security.auth.callback.PasswordCallback}: oggetto che contiene la password dell'utente da autenticare
	\item \texttt{javax.security.auth.callback.UnsupportedCallbackException}: la classe è in grado di sollevare eccezioni relative a operazioni di UnsupportedCallback.
	\item \texttt{javax.security.auth.login.FailedLoginException}: la classe è in grado di sollevare eccezioni relative a operazioni di FailedLoginException.
	\item \texttt{javax.security.auth.login.LoginException}: la classe è in grado di sollevare eccezioni relative a operazioni di LoginException.
	\item \texttt{javax.security.auth.Subject}: definisce il soggetto da autenticare.
	\item \classname{abook.IUserData}: la classe interagisce con istanze di oggetti identificabili come utenti.
	\item \classname{dao.UserDataDAO}: utilizzata per modificare il contenuto del database. Nello psecifico viene usata per interagire con la tabella UserData.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{javax.security.auth.spi.LoginModule}: interfaccia d'implementazione.
\end{itemize}

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{-- login: boolean}}\\
  Attributo che determina se il login è avvenuto oppure no.
  \item{\memberdata{-- commit: boolean}}\\
  Attributo che determina se il commit è già stato eseguito.
  \item{\memberdata{-- handler: CallbackHandler}}\\
  Oggetto utilizzato per il caricamento delle credenzialie.
  \item{\memberdata{-- password: char[]}}\\
  Attributo che che contiene la password immessa dall'utente.
  \item{\memberdata{-- username: String}}\\
   Attributo che che contiene lo username immesso dall'utente.
  \item{\memberdata{-- principal: Principal}}\\
  Contiene la caratteristica autenticativa del subject. Nel sistema MyTalk tale proprietà è riservata al campo mail.
  \item{\memberdata{-- subject: Subject}}\\
  Attributo che definisce il soggetto da autenticare.
\end{description}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ initialize(subject: Subject, handler: CallbackHandler, sharedState: Map, option: Map): void }}\\
	Il metodo ha il compito di inizializzare gli attributi privati della classe con i parametri d'input.

	\item{\method{+ login(): boolean throws LoginException}}\\
	Metodo richiamato per verificare un riscontro tra i dati passati per l'autenticazione e i dati presenti nel database. Il metodo deve appoggiarsi alla classe \classname{UserDataDAO} per le operazione di estrazione dati dal database.
	
	\item{\method{+ commit(): boolean throws LoginException}}\\
	Metodo richiamato direttamente dal framework se il login va a buon fine. Il suo scopo è quellodi inizializzare il subject con i relativi principle.
	
	\item{\method{+ abort(): boolean throws LoginException}}\\
	Metodo usato per bloccare la procedura di login.
	
	\item{\method{+ logout(): boolean throws LoginException}}\\
	Metodo per il logout del sistema. Il suo scopo è quello di eliminare il principle e il subject.

\end{description}

\classsection{CredentialLoader}

\subsubsection*{Funzione}
Permette di caricare le credenziali di autenticazione, fornite dall'utente, per preparare la fase di login.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{javax.security.auth.callback.Callback}: usato durante la procedura di inserimento dati.
	\item \texttt{javax.security.auth.callback.NameCallback}: tipo di dato richiesto in ingresso per completare la parte di login.
	\item \texttt{javax.security.auth.callback.PasswordCallback}: tipo di dato richiesto in ingresso per completare la parte di login.
	\item \texttt{java.io.IOException}: eccezione che può essere sollevata dal metodo \texttt{handle} definito dall'interfaccia \texttt{javax.security.auth.callback.CallbackHandler}.
	\item \texttt{javax.security.auth.callback.UnsupportedCallbackException}: eccezione che può essere sollevata dal metodo \texttt{handle} definito dall'interfaccia \texttt{javax.security.auth.callback.CallbackHandler}.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{javax.security.auth.callback.CallbackHandler}: Interfaccia implementata dalla classe.
\end{itemize}

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{-- credential: AuthenticationData}}\\
  Attributo contenente i dati da autenticare per la login dell'utente.
  \item{\memberdata{-- security: ISecurityStrategy}}\\
  Attributo che contiene un oggetto che definisce un algoritmo di criptazione per i dati. Necessario per criptare i dati di autenticazione.
\end{description}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ CredentialLoader(credential: AuthenticationData, security: ISecurityStrategy)}}\\
	Costruttore pubblico. Crea un istanza con le credenziali fornite dall'utente (fornite in fase di login).

	\item{\method{+ handle(callbacks: Callback[]): void}}\\
	Effettua il caricamento e crittografa delle credenziali fornite dall'utente per la fase di login\\\\
	Il metodo può sollevare eccezioni:
	\begin{itemize}
		\item \exception{IOException}
		\item \exception{UnsupportedCallbackException}
	\end{itemize}

\end{description}

\classsection{Loader}

\subsubsection*{Funzione}
Oggetto usato per il caricamento delle credenziali di autenticazione.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException};
	\item \texttt{javax.servlet.http.HttpServletRequest};
	\item \texttt{org.softwaresynthesis.mytalk.server.authentication.security.ISecurityStrategy}: usata per definire l'algoritmo di criptazione.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

\begin{itemize}
	\item \texttt{javax.security.auth.callback.Callback}: interfaccia d'implementazione.
\end{itemize}

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{-- callback: Callback}}\\
  \item{\memberdata{-- strategy: ISecurityStrategy}}\\
\end{description}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ Loader(callback: Callback)}}\\
	Costruttore pubblico. Crea il ''caricatore'' con la giusta istanza di callback.
	
	\item{\method{\# getCallback(): callback}}\\
	Metodo usato per ritornare l'attributo \memberdata{callback}.
	
	\item{\method{\# getISecurityStrategy(): ISecurityStrategy}}\\
	Metodo usato per ritornare l'attributo \memberdata{strategy}.
	
\end{description}

\classsection{NameLoader}

\subsubsection*{Funzione}
Caricatore per lo username. Ha il compito di caricare e preparare lo username fornito dall'utente per la successiva fase di autenticazione.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException};
	\item \texttt{javax.servlet.http.HttpServletRequest};
	\item \texttt{javax.security.auth.callback.NameCallback)};
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

\begin{itemize}
	\item \texttt{Loader}: classe estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato.

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ NameLoader()}}\\
	Costruttore pubblico che richiama il costruttore della super classe passando come parametro: \verb|new NameCallback("username")|.
	
	\item{\method{+ load(request: HttpServletRequest): void}}\\
	Il metodo crea un istanza di \texttt{NameCallback} a partire dalla callback ottenuta dalla chiamata \verb|super.getCallback()|. Quindi carica in una variabile locale di tipo String il nome dell'utente. Tale parametro si ottiene mediante una chiamata a metodo getParameter(''username'') invocata dall'istanza request. Quindi si imposta tale nome sull'istanza callback (usare \verb|callback.setName(username)|).
	
	\item{\method{+ getData(): String}}\\
	Metodo usato per ottenere il nome dell'utente. Il metodo ritorna il contenuto di una chiamata \verb|super.getCallback().getName()|.
	
\end{description}

\classsection{PasswordLoader}

\subsubsection*{Funzione}
Caricatore per la password. Ha il compito di caricare e preparare la password fornita dall'utente per la successiva fase di autenticazione.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException};
	\item \texttt{javax.servlet.http.HttpServletRequest};
	\item \texttt{javax.security.auth.callback.PasswordCallback)};
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

\begin{itemize}
	\item \texttt{Loader}: classe estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato.

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ PasswordLoader()}}\\
	Costruttore pubblico che richiama il costruttore della super classe passando come parametro: \verb|new PasswordCallback("password")|.
	
	\item{\method{+ load(request: HttpServletRequest): void}}\\
	Il metodo crea un istanza di \texttt{PasswordCallback} a partire dalla callback ottenuta dalla chiamata \verb|super.getCallback()|. Quindi carica in una variabile locale di tipo String la password dell'utente, ed usando l'algoritmo di sicurezza definito dall'istanza di tipo ISecurityStrategy, cripta la password. Tale parametro si ottiene mediante una chiamata a metodo getParameter(''password'') invocata dall'istanza request. Quindi si imposta tale nome sull'istanza callback (usare \verb|callback.setName(PASSWORD_CRIPTATA)|).
	
	\item{\method{+ getData(): String}}\\
	Metodo usato per ottenere la password dell'utente. Il metodo salva il contenuto di una chiamata \verb|super.getCallback().getPassword()|. Poi, prima di ritornare il valore, esegue la decriptazione mediante l'algoritmo ISecurityStrategy utilizzato.
	
\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.authentication.controller}\label{sec:autservlet}

%TODO da rivedere nella definizione dei metodi! 
\classsection{LogoutController}

\subsubsection*{Funzione}
\inglese{Controller} da richiamare per effettuare il logout dal sistema.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dal metodo\method{doAction()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doAction()}. Usata per scrivere l'output della \inglese{servlet}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doAction()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \classname{abook.IUserData}: usata per definire un utente.
	\item \classname{dao.DataPersistanceManager}: usata per comunicare tramite Hibernate con la tabella UserData della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{server.AbstractController}: classe estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato

\subsubsection*{Metodi}
\begin{description}
	\item{\method{\# doAction(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Metodo che costituisce il kernel logico di risposta della \inglese{servlet}. Il metodo inizia caricando i parametri ricevuti mediante \texttt{HttpServletRequest}. Una chiamata a tale \inglese{servlet} corrisponde ad una richiesta di logout e si attua impostando a false la sessione contenuta nell'oggetto HttopServletRequest request. Il metodo procede con la creazione di un istanza  di \texttt{LoginContext} denominata context. Quindi viene effettuata la memorizzazione dell'oggetto ritornato da una chiamata:
\\
\verb|session.getAttribute("LoginContext");|
\\

L'oggetto cosi ottenuto dovrà essere controllato, ovvero si dovrà accertare che il tipo dinamico è conforme al tipo \texttt{LoginContext} (il programmatore dovrà obbligatoriamente usare   la primitiva \texttt{istanceof}). Quindi si sovrascrive il contenuto di context con quanto ottenuto dalla chiamata a metodo sopracitata, e si richiama il metodo \texttt{logout()} a partire dall'oggetto context. Il metodo termina invalidando la sessione richiamando il metodo \texttt{invalidate()} di HttpSession.

\end{description}

\classsection{LoginController}

\subsubsection*{Funzione}
\inglese{Controller} da richiamare per effettuare l'autenticazione dell'utente.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
\item \texttt{java.io.IOException}: eccezione richiamabile dal metodo\method{doAction()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doAction()}. Usata per scrivere l'output della \inglese{servlet}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doAction()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \classname{abook.IUserData}: usata per definire un utente.
	\item \classname{dao.DataPersistanceManager}: usata per comunicare tramite Hibernate con la tabella \texttt{UserData} della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{server.AbstractController}: classe estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato

\subsubsection*{Metodi}
\begin{description}
	\item{\method{\# doAction(request: HttpServletRequest, response: HttpServletResponse): void}}\\

Il metodo inizia caricando i parametri ricevuti mediante \texttt{HttpServletRequest}. Una chiamata a tale metodo corrisponde ad una richiesta di login e si attua impostando due campi String con i dati ottenuti da una chiamata a \texttt{getParameter(``username'')} e \texttt{getParameter(``password'')} . Quindi si crea un istanza di \texttt{HttpSession} tramite il metodo \texttt{getSession(true)} del parametro request. Il metodo prosegue controllando se l'username e la password precedentemente ottenute hanno valore diverso da null. Nel caso il flusso principale continua creando un'istanza di \classname{AutenthicationData} (denominata credential) a partire dai parametri username e password. Quindi si carica la path del file di configurazione in un apposita stringa \texttt{pathFileConfig}, tramite la chiamata a metodo:\\
	
\verb|System.getenv("MyTalkConfiguration") + "\\LoginConfiguration.conf"|.\\

Il flusso principale prosegue all'interno di un blocco \texttt{try-catch} creando:
	\begin{itemize}
		\item[•] un \classname{CredentialLoader} (loader);
		\item[•] un \classname{LoginContext} (context);
		\item[•] un \classname{dao.UserDataDao} (user);
	\end{itemize}
Quindi tramite context si esegue il login e si impostano gli attributi di sessione come segue: 

\texttt{session.setAttribute("LoginContext", context);}

Infine si carica in user un istanza di \classname{dao.UserDataDAO} ottenuta dalla chiamata a metodo \method{UserDataDAO.getByEmail()}, e restituendo user in un formato di formattazione \texttt{Json} (\texttt{user.toJson()}).

\end{description}

\classsection{RegisterController}

\subsubsection*{Funzione}
\inglese{Conroller} da richiamare per effettuare la registrazione al sistema MyTalk.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dal metodo\method{doAction()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doAction()}. Usata per scrivere l'output della \inglese{servlet}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doAction()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per interagire con le richieste \texttt{ajax} inoltrate dal client.
	\item \classname{abook.IUserData}: usata per definire un utente.
	\item \classname{dao.DataPersistanceManager}: usata per comunicare tramite Hibernate con la tabella \texttt{UserData} della base di dati.
	\item \classname{authentication.security.ISecurityStrategy}: usata per criptare/decriptare i dati da inviare/ricevere
	\item \classname{authentication.security.AESAlgorithm}: implementazione di \classname{authentication.ISecurityStrategy} usata dalla classe descritta.
	
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{server.AbstractController}: classe estesa.
\end{itemize}

\subsubsection*{Attributi}

Nessun attributo evidenziato

\subsubsection*{Metodi}
\begin{description}
	\item{\method{\# doAction(request: HttpServletRequest, response: HttpServletResponse): void}}\\

Il metodo inizia caricando i parametri ricevuti mediante \texttt{HttpServletRequest}. Una chiamata a tale metodo corrisponde ad una richiesta di registrazione al sistema e si attua impostando i dati di registrazione:
	\begin{itemize}
		\item name;
		\item username;
		\item mail;
		\item password;
		\item path immagine;
		\item domanda segreta;
		\item risposta alla domanda segreta;
	\end{itemize}
	Per eseguire tali operazioni, il metodo predispone delle opportune variabili di tipo String e crea uno \classname{abook.IUserData} user. Quindi all'interno di un blocco try catch viene impostata una strategia di criptaggio dei dati (creando un istanza di \classname{authentication.security.AESAlgorithm}). Quindi vengono caricati i dati di registrazione nelle variabili precedentemente create. Per eseguire tali operazioni è necessario usare l'istruzione:\\
	
	\verb|request.getParameter("NOME_PARAMTERO")|\\
	
	dove i nomi dei parametri sono:
	\begin{itemize}
		\item username (usata per l'indirizzo mail);
		\item name;
		\item surname;
		\item password;
		\item answer;
		\item question;
		\item picturePath;
	\end{itemize}
	Il passo successivo (sempre dentro il blocco try) consiste nel creare un istanza di \classname{dao.UserDataDAO} userDAO, e nell'eseguire un operazione di userDAO.\method{insert()} passando come parametro user (l'utente precedentemente creato). Il blocco try termina impostando result a ``\inglese{true}''.
	
	Per quanto riguarda il blocco catch, in esso viene impostato result a ``\inglese{false}''.
	
	Il metodo termina scrivendo in un \texttt{PrintWriter} il valore di result.
\end{description}


\subsection{Package org.softwaresynthesis.mytalk.server.connection}\label{sec:connection}

\classsection{PushInbound}

\subsubsection*{Funzione}
Classe per la definizione di un apposito canale di comunicazione client-server. La classe è un'estensione di \texttt{org.apache.catalina.websocket.MessageInbound} che verrà usata poi in \classname{ChannelServlet}. Si osservi che l'associazione tra un istanza di \classname{PushInbound} e un utente del sistema è univoca: fintanto che connesso un utente ha un proprio \classname{PushInbound} presente sul server.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException}: Eccezione che può sollevare il metodo \method{OnTextMessage()}.
	\item \texttt{java.nio.CharBuffer}: tipologia di \textit{buffer} usata per memorizzare il messaggio ricevuto come parametro d'ingresso.
	\item \texttt{java.util.Iterator}: usata per scorrere il contenuto dell'insieme di \classname{AddressBookEntry}
	\item \texttt{java.util.Set}: struttura dati usata per memorizzare le \inglese{entry} (\classname{AddressBookEntry}) che costituiscono la rubrica dell'utente.
	\item \texttt{com.google.gson.*}: converte i dati interni in una stringa formato json.
	\item \classname{State}: classe interna utilizzata per rappresentare lo stato dell'utente a cui è associata l'istanza di \classname{PushInbound}. Un utente ha uno stato fintanto che è connesso (quindi fintanto che esiste sul server un'istanza di \classname{PushInbound}  ad esso associata). Gli stati possibili sono: \texttt{available} (utente connesso e libero, quindi disposto a ricevere chiamate) e \texttt{occupied} (utente connesso ma attualmente occupato in un'altra conversazione).
	\item \classname{abook.AddressBookEntry}: usata per definire la rubrica dell'utente, richiamata dal metodo \method{onTextMessage} nel momento in cui si presenta la necessità di aggiornare lo stato dell'utente e renderlo visibile ai suoi contatti.
	\item \classname{abook.IUserData}: usata per riferire un istanza della classe ad un particolare utente.
	\item \classname{dao.UserDataDAO}: usata per riferire un istanza della classe ad un particolare utente.

\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{org.apache.catalina.websocket.MessageInbound}: classe da estendere, aggiunge alla classe \classname{PushInbound} le funzionalità necessarie per renderla un ``canale di comunicazione'' utilizzabile dai client.
\end{itemize}

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{-- id: Long}}\\
  Identificativo di tipo \textit{Long} del canale di comunicazione associato ad un client univoco.
  \item{\memberdata{-- state: State}}\\
  Attributo usato per memorizzare lo stato dell'utente ``proprietario'' del \classname{PushInbound}.
\end{description}

%TODO da rivedere.

\subsubsection*{Metodi}
\begin{description}

	\item{\method{+ setId(n: Long): void}}\\
	Metodo per impostare il valore contenuto nell'attributo \memberdata{id}.
	
	\item{\method{+ getId(): Long}}\\
	Metodo che ritorna il contenuto dell'attributo \memberdata{id}.
	
	\item{\method{+ onTextMessage(message: CharBuffer): void}}\\
	Metodo invocato al momento della ricezione di un messaggio da parte del client. Il metodo riceve in input un oggetto di tipo \texttt{CharBuffer} contenente il messaggio inviato dal client.
Inizialmente il metodo crea un istanza per ognuno dei seguenti oggetti:
	\begin{itemize}
		\item[•]\texttt{Gson}: tipo di \textit{Json} definito da \textit{Google};
		\item[•]\texttt{JsonParser}: \textit{parser} usato per scorrere il contenuto di una stringa \textit{Json};
		\item[•]\texttt{JsonArray}: array popolato a partire dal \inglese{parsing} della stringa di messaggio data in input.
	\end{itemize}
	
	Prima di procedere si voglia considerare quanto segue: il metodo dopo aver ``segmentato'' il messaggio ricevuto in input, si occupa di esaminarne il contenuto che può essere di 5 tipologie, ciascuna identificata tramite un valore intero positivo da 1 a 5. Tale valore deve essere salvato nell'istanza di \texttt{JsonArray}
	Detto ciò, tornando a definire il flusso principale del metodo, si osservi che:

	\begin{itemize}
		\item[•]Se la richiesta inoltrata è del tipo 1: il metodo prende in lettura il messaggio e imposta il contenuto di \memberdata{id} con il valore letto mediante procedura di \inglese{parsing} analoga a quella definita al passo precedente. Per farlo utilizza il metodo \texttt{fromJson} richiamato dall'istanza \texttt{gsonObj} di tipo \texttt{Gson} creata al passo precedente. A tale metodo passa il contenuto dell'array e in particolare ciò che è salvato nella posizione 1 (utilizzo di metodo \texttt{get(int i)}).
		\item[•]Se la richiesta inoltrata è del tipo 2: il metodo procede con le istruzioni necessarie a scambiare i dati per la chiamata. Nello specifico viene salvato in un attributo di tipo \texttt{Long}, l'\texttt{id} del client che desidero chiamare, quindi ricerco l'oggetto \texttt{PushInbound} associato al client che desidero contattare, e gli inoltro il messaggio ricevuto come parametro d'ingresso.
		\item[•]Se la richiesta inoltrata è del tipo 3: il metodo comunica al client ``destinatario'' della chiamata, l'\texttt{id} del client chiamante. La procedura è analoga a quella identificata nel punto precedente, con la specifica che il messaggio inoltrato è l'identificativo del cliente che desidera avviare la chiamata.
		\item[•]Se la richiesta inoltrata è del tipo 4: il metodo si occupa dell'eliminazione della \textit{webSocket}, contattando l'istanza \classname{ChannelServlet} associata a questo \texttt{PushInbound}.
		\item[•]Se la richiesta inoltrata è del tipo 5: il metodo viene usato per modificare lo stato dell'utente, con il valore passato tramite messaggio. Dopo la ricezione del messaggio, il metodo cambia il valore del campo \texttt{state} con il valore ricevuto come parametro d'ingresso. Quindi procede ricavando la lista degli utenti nella rubrica dell'utente che ha cambiato stato e comunica loro che è avvenuto un cambiamento di stato.
	\end{itemize}
\end{description}

\classsection{ChanelServlet}

\subsubsection*{Funzione}
\inglese{Servlet} per la gestione delle connessioni. Richiamata dai client per ottenere le informazioni necessarie a stabilire una comunicazione client-client.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.util.Vector}: vettore usato per memorizzare i \texttt{PushInBound} creati all'interno della classe.
	\item \texttt{javax.servlet.ServletConfig}: classe per la configura della \inglese{servlet}. 
	\item \texttt{javax.servlet.ServletException}: eccezione richiesta per la firma del metodo \method{init} (metodo richiesto per implementazione dell'interfaccia \texttt{javax.servlet.Servlet}.
	\item \texttt{javax.servlet.annotation.WebServlet}: necessaria per definire la \inglese{servlet} come \texttt{WebServlet}.
	\item \texttt{javax.servlet.http.HttpServletRequest}: necessaria per definire le richieste inoltrate alla classe (richieste a \inglese{servlet}).
	\item \classname{org.apache.catalina.websocket.StreamInbound}: classe utilizzata per definire un canale di comunicazione server-client.
	\item \classname{org.apache.catalina.websocket.WebSocketServlet}: classe da estendere per utilizzare i metodi di comunicazione tramite \inglese{webSocket}.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{javax.servlet.Servlet}: interfaccia d'implementazione. Necessaria per definire la classe come \inglese{servlet}.
\end{itemize}

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{\underline{-- \{frozen\} serialVersionUID: long}}}\\
  Utilizzato come ID univoco per identificare un oggetto serializzabile.
  \item{\memberdata{-- \{frozen\} clients: Vector<PushInbound>}}\\
  Vettore contenente i canali di comunicazione server-client. Un canale di comunicazione \texttt{PushInbound} viene creato dal Server al momento dell'autenticazione di un utente (al quale poi viene associato).
\end{description}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ ChannelServlet()}}\\
	Costruttore della \textit{servlet}. Richiama \method{super()}.
	
	\item{\method{\# createWebSocketInbound(subProtocol: String, request: HttpServletRequest): StreamInbound}}\\
	Metodo per la creazione di una \textit{websocket}. Il metodo ha anche il compito di salvare nel vettore di connessioni attive e la ritorna al client. Nello specifico il server segue l'iter:
	
	\begin{itemize}
		\item[1)] creazione di un \textit{PushInbound};
		\item[2)] aggiungo l'oggetto creato al punto precedente, al vettore di \textit{PushInbound} \memberdata{clients};
		\item[3)] il metodo termina ritornando l'istanza di \textit{PushInbound} creata al punto 1.
	\end{itemize}
	
	\item{\method{\underline{ + findClient(n: Long): PushInbound}}}\\
	Metodo per la ricerca di una connessione client dato l'identificativo dell'utente, esegue una ricerca (mediante ciclo \inglese{for}) all'interno del vettore \memberdata{clients} e ad ogni iterazione verifica se l'istanza i-esima presa in esame ha un campo id che corrisponde a quello dato in input come parametro di ricerca.
Il metodo termina ritornando il \textit{PushInbound} associato al client, se si verifica l'effettiva esitenza di un client con \texttt{id} uguale a quello passato in input, \texttt{null} altrimenti.
	
	\item{\method{\underline{ + removeClient(c: PushInbound): void}}}\\
	Metodo per la rimozione di un oggetto \texttt{PushInbound} dal vettore \memberdata{clients}. Il metodo esegue una ricerca tramite ciclo \inglese{for} (analoga a quella eseguita nel metodo \method{findClient}. Se la ricerca ha esito positivo il metodo termina eseguendo la rimozione dell'istanza dall'oggetto \memberdata{clients} tramite la chiamata a metodo \texttt{remove}.
\end{description}

\clearpage

\section{Specifica sotto-architettura clientpresenter}\label{sec:clientpresenterarchitecture}

La sotto-architettura \texttt{clientpresenter}, a livello di definizione di prodotto, richiede una trattazione speciale a causa del particolare dominio tecnologico coinvolto. Essa è infatti definita con il linguaggio \textit{JavaScript} che pur essendo definito come linguaggio orientato agli oggetti non permette di definire classi, a ciò si aggiunge un ulteriore particolarità di \textit{JavaScript}: è debolmente tipizzato.
In ragione di ciò, al fine di facilitare al programmatore la comprensione del progetto (pesando quindi alle varie entità come a classi) senza però confonderlo in fase di stesura del codice, si è pensato di adoperare la seguente terminologia:

\begin{description}
	\item{\scshape\bfseries Attributi}: saranno definiti con una sintassi simile a quella già usata per la parte \inglese{server}, pertanto al nome dell'attributo sarà associato il tipo ``logico'' che idealmente rappresenta. In particolare emergono i seguenti casi:
		\begin{itemize}
			\item Nodi DOM: come si vedrà alcuni attributi rappresentano nodi DOM già esistenti nella pagina HTML che definisce l'interfaccia utente e modificati (a \textit{run-time}) sulla base di informazioni ottenute dal \inglese{server}. Tali attributi dovranno essere codificati come:
			
			\begin{verbatim}
				this.mio_attributo = document.getElementById(``id_DOM'');
			\end{verbatim}
			
			Tali attributi saranno indicati con il formalismo:
			
			\begin{verbatim}
				(+, -, #) nome_attributo: Nodo_DOM
			\end{verbatim}
			
			\item String: se l'attributo è destinato a contenere esclusivamente valori di tipo \textit{String} sarà segnato nel documento come:
			
			\begin{verbatim}
				(+, -, #) nome_atributo: String
			\end{verbatim}
			
			\item Array: se l'attributo è un \inglese{array}, che in \textit{JavaScript} non chiede di essere definito per tipo di valori contenibili, nel documento sarà precisato come:
			
			\begin{verbatim}
				(+, -, #) nome_atributo: Tipo[]
			\end{verbatim}
			
			\item Contatto: se l'attributo è un contatto, nel documento sarà precisato come:
			
			\begin{verbatim}
				(+, -, #) nome_atributo: Object(contact)
			\end{verbatim}
			Tale oggetto conterrà i seguenti campi dati:
			\begin{itemize}
			\item name;
			\item surname;
			\item email;
			\item id;
			\item picturePath;
			\item state;
			\item blocked.
			\end{itemize}

\item Gruppo: se l'attributo è un gruppo, nel documento sarà precisato come:
			
			\begin{verbatim}
				(+, -, #) nome_atributo: Object(group)
			\end{verbatim}
			Tale oggetto conterrà i seguenti campi dati:
			\begin{itemize}
			\item name;
			\item id;
			\item contacts (rappresentato come un \inglese{array} di Object(contact).
			\end{itemize}
		\end{itemize}
	\item{\scshape\bfseries Metodi}: la sintassi usata dal programmatore per definire un metodo in \textit{JavaScript} dovrà essere la seguente:
		\begin{verbatim}
			var nome_metodo = function(){ contenuto }
		\end{verbatim}
		
		mentre la sintassi usata nel documento per definirne la firma, resta la stessa usata in precedenza.
	
\end{description}

\subsection{Package org.softwaresynthesis.mytalk.clientpresenter.guicontrol}\label{sec:guicontrol}

\classsection{AddressBookPanelPresenter}

\subsubsection*{Funzione}
Presenter incaricato di gestire il pannello della rubrica, contiene le funzioni associate ai \inglese{widget} grafici della vista relativi a quest'ultima e ha la responsabilità di aggiornare la vista sulla base dei dati ricevuti dal \inglese{server}.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}

  \item{\memberdata{-- element: DOM\_node}}\\
  Attributo che definisce il contenuto del nodo DOM inerente alla rappresentazione della rubrica. Nello specifico tale nodo corrisponde ad un \texttt{div} con id \texttt{AddressBookPanel}.
  \item{\memberdata{-- urlServlet: String}}\\
  Attributo che definisce l'URL dal quale è richiamabile la \textit{servlet} usata per interagire con l'apparato server del sistema.
  \item{\memberdata{-- suffix: String}}\\
Suffisso da concatenare all'url per richiamare le \inglese{servlet} appropriate.  
  \item{\memberdata{-- contacts: Array()}}\\
  Attributo che definisce la lista degli utenti presenti nella rubrica dell'utente che ha effettuato l'autenticazione.
   \item{\memberdata{-- groups: Array()}}\\
  Attributo che definisce la lista dei gruppi presenti nella rubrica dell'utente che ha effettuato l'autenticazione. Pero ogni gruppo sono  elencati i contatti contenuti in esso.
   \item{\memberdata{-- operations: String[]}}\\ 
   \inglese{Array} di stringhe usato per memorizzare i nomi delle istruzioni eseguibili, essi rappresentano una parte del nome della \inglese{servlet} incaricata a risolvere l'operazione descritta (e.g. GetContacts rappresenta l'operazione svolta dalla \inglese{servlet} avente nome: \memberdata{urlServlet} concatenato a ``GetContactsServlet''). I valori con i quali si dovrà caricare \memberdata{operations}) sono:
   \begin{itemize}
   	\item GetContacts;
    \item DoAddContact;
    \item DoDeleteContact;
    \item DoInsertInGroup;
    \item DoRemoveFromGroup;
    \item DoCreateGroup;
    \item DoDeleteGroup;
    \item GetGroups;
    \item DoBlock;
    \item DoUnblock;
    \item DoSearch;
   \end{itemize}

\end{description}

\subsubsection*{Metodi}
\begin{description}	
	
	\item{\method{+ inizialize(): void}}\\
	Metodo per inizializzare  \texttt{AddressBookPanel} e popolarlo con i contatti della rubrica, modifica il DOM creando tre div: divSearch, divSort e divList. Quindi sequenzialmente ne crea il contenuto:
		\begin{itemize}
			\item divSearch: definisce un campo per l'\inglese{input} testuale e un bottone per ricercare nella lista un utente avente avete tra le parole chiave, una con valore uguale a quello inserito nel campo d'\inglese{input}.
			\item divSort: crea delle \inglese{select} per specificare le tipologie di ordinamento attuabili sulla lista degli utenti.
			\item divList: \textit{div} che viene popolato con i nomi degli utenti presenti nella rubrica dell'utente che l'ha richiamata.
		\end{itemize}

Quindi dopo aver creato questi elementi il metodo procede inserendo nel DOM il ``sotto-albero'' cosi creato.

	\item{\method{- getAddressBookContacts(): void}}\\
Metodo che recupera i contatti e i gruppi della propria rubrica dal server usando la tecnologia AJAX. Il metodo crea una variabile contenente un istanza \texttt{XMLHttpRequest()}. Quindi con metodo \inglese{POST} inoltra la richiesta alla \inglese{servlet} il cui indirizzo è generato dalla concatenazione di \memberdata{urlServlet} con \memberdata{operation[1]}. Elabora quindi i dati ottenuti mediante il metodo \texttt{JSON.parse()} e li salva negli \textit{array} \memberdata{contacts} e \memberdata{groups}.
	
	\item{\method{+ setup(): void}}\\
	Inserisce i contatti estratti dal \textit{server} all'interno della lista \texttt{AddressBookList} all'interno di \texttt{AddressBookPanel}.
	
	\item{\method{+ displayContactList(contact: String[]): void}}\\
	Metodo usato per visualizzare la lista dei contatti utente, esso prende il nodo DOM (già esistente) e destinato a contenere la lista dei contatti, popolandolo richiamando il metodo \method{addListItem()}.
	
	\item{\method{-- addListItem(list: DOM\_node, contact: Object(contact): void}}\\

Metodo richiamato da \method{displayContactList()} per visualizzare i contatti presenti della rubrica, crea le variabili contenenti i dati del contatto da attribuire al \textit{tag} di \textit{markup} \texttt{li}. Tali variabili sono quelle tipiche di un oggetto Object(contact) (nome, cognome, email, status e immagine).


\item{\method{-- addOptionToSelect(select: DOM\_element, value: String, text: String): void}}\\
Metodo utilizzato per aggiungere un'opzione all'elemento \memberdata{select} ricevuto come parametro dal metodo. Ha il compito di creare un \texttt{TextNode} ed appenderlo alla \memberdata{select}.

	
	\item{\method{+ addContact(contact: Object(contact)): boolean}}\\
	Metodo per l'aggiunta di un contatto alla rubrica, riceve come parametro un oggetto di tipo contatto da inserire, appunto, nella propria rubrica. 
Per assicurarsi di non introdurre ridondanza ed aggiungere un contatto già presente il metodo esegue due controlli: uno lato \inglese{client} e uno lato \textit{server}. 
Il controllo lato \inglese{client}, si scorre la lista \memberdata{contact} alla ricerca di un \texttt{contact} che cerca un \inglese{match} con il nuovo contatto. Nel caso sia già presente il metodo termina ritornando \inglese{false}. Per eseguire il controllo lato \inglese{server} il metodo contatta il \inglese{server} mediante la \inglese{servlet} \texttt{AddressBookDoAddContatctServlet}, questa verificherà se l'utente avente \texttt{id} \textit{contact} è già presente nella rubrica, nel caso non lo sia si occuperà di creare la nuova istanza di \texttt{AddressBookEntry} e la registrerà nel database, in caso contrario non esegue operazioni. 
La chiamata a \inglese{servlet} ritorna un valore booleano che sarà \textit{true} se l'inserimento ha avuto successo, \textit{false} altrimenti. 
Se l'inserimento ha avuto successo il flusso principale prosegue eseguendo l'aggiornamento della rubrica in locale tramite la chiamata a metodo \method{setup()}. Il metodo termina infine ritornando \textit{true} se è stato aggiunto l'utente, altrimenti solleva un'eccezione.

	\item{\method{+ removeContact(contact: Obj): boolean}}\\
Metodo il cui funzionamento è analogo a quello precedentemente definito, si occupa di eliminare un contatto conoscendone l'\texttt{id} passato per parametro d'ingresso. Il flusso principale esegue due controlli per verificare la presenza dell'utente nella rubrica (analogamente a quanto visto nel caso precedente). 
Dopo tale verifica, se il contatto è realmente presente nella rubrica, la \inglese{servlet} \texttt{AddressBookDoRemoveContactServlet} avrà eseguito la cancellazione come conseguenza al match effettuato in fase di verifica, nel caso il metodo richiama \method{setup()} per rieseguire l'aggiornamento della rubrica. Il metodo ritorna infine \textit{true} se effettivamente il contatto era presente ed è stato eliminato, altrimenti solleva un'eccezione.

	\item{\method{+ addGroup(name: String): boolean}}\\
	Metodo per l'aggiunta di un nuovo gruppo nella rubrica, permette l'aggiunta di gruppi con nomi duplicati (ossia nomi di gruppi già presenti nella rubrica). Il flusso principale richiama la \inglese{servlet} \texttt{AddressBookDoCreateGroupServlet} con il nome del gruppo da creare. Successivamente, se la \inglese{servlet} ha dato \method{setup()} esito positivo, viene richiamata il metodo \inglese{setup} che aggiorna la rubrica locale, altrimenti solleva un'eccezione.
	
	\item{\method{+ deleteGroup(idGroup: int): boolean}}\\
	Metodo per l'eliminazione di un nuovo gruppo presente nella rubrica, riceve come parametro d'ingresso l'\texttt{id} del gruppo da eliminare. Il flusso principale richiama la \inglese{servlet} \texttt{AddressBookDoRemoveGroupServlet} passandogli l'\texttt{id} del gruppo candidato all'eliminazione. Quindi, se la \inglese{servlet} notifica l'effettiva esistenza di un gruppo con tale \texttt{id}, essa si occupa dell'eliminazione e il flusso principale prosegue richiamando il metodo \inglese{setup} se la eliminazione ha avuto buon fine, altrimenti solleva un'eccezione.
	
	\item{\method{+ addContactInGroup(contact: Object(contact), group: Object(contact)): boolean}}\\
	Metodo per l'aggiunta di un contatto in un gruppo ben definito, riceve come parametro d'ingresso il contatto e il gruppo.
Il metodo richiama da prima \method{contactExistInGroup}, successivamente il flusso principale richiama la \inglese{servlet} \texttt{AddressBookDoInsertInGroupServlet} passandogli i parametri d'ingresso, quindi se la \inglese{servlet} notifica l'effettiva esistenza di un gruppo con il nome ricevuto, essa si occupa di aggiungervi il contatto e il flusso principale ritorna al metodo \method{setup()} per aggiornare la rubrica in locale, ritorna infine un \inglese{feedback} booleano a \textit{true} per dare notifica se l'operazione ha avuto buon fine, altrimenti solleva un'eccezione.
	
	\item{\method{+ deleteContactFromGroup(contact: Object(contact), group: Object(group)): boolean}}\\
	Metodo per l'eliminazione di un contatto presente in un gruppo, riceve come parametro d'ingresso il gruppo su cui effettuare la ricerca del contatto da eliminare e il contatto. 
Il metodo richiama da prima \method{contactExistInGroup}, poi Il flusso principale richiama la \inglese{servlet} \texttt{AddressBookDoRemoveFromGroupServlet} passandogli i parametri d'ingresso, la \inglese{servlet} notifica l'effettiva esistenza di un gruppo con il nome ricevuto che contiene il contatto candidato all'eliminazione, essa si occupa dell'eliminazione e il flusso principale ritorna al metodo \method{setup()} per aggiornare la rubrica in locale, ritorna infine un \inglese{feedback} booleano per dare notifica sull'esito dell'operazione: \textit{true}\textit{true} se è stato creato il nuovo gruppo, altrimenti solleva un'eccezione.
	
	\item{\method{- contactExistInGroup(contact: Object(contact), group: Object(group)): boolean}}\\
Metodo che verifica l'esistenza di un contato in un determinato gruppo, restituisce un \inglese{feedback} booleano per confermare o meno l'esistenza dell'utente ricercato nel gruppo designato.

\item{\method{+ applyFilterByString(param: String): array()}}\\
Metodo che data una stringa come parametro d'ingresso filtra la lista di contatti presente in locale. Non richiede interazione con il server, ovvero non vengono richiamate \inglese{servlet}.

In un primo step il programmatore dovrà creare un \inglese{array} atto a contenere l'elenco dei contatti da restituire, quindi il metodo procede con la definizione di un espressione regolare basata sul parametro ricevuto. Per tale operazione la sintassi obbligatoria è:\\

\verb|var pattern = new RegExp(param)|\\

Quindi viene avviato un ciclo \textit{for} che analizza ogni contatto presente in \memberdata{contacts}. Successivamente si effettua un filtraggio sui campi \textit{name, surname, email} del contatto attualmente in esame. Per fare tali operazioni si dovrà usare:\\

\verb|pattern.test(\*elemento su cui ricercare param*\)|\\

Se tale filtraggio da esito positivo, il contatto viene aggiunto all'\textit{array} dei contatti da restituire. Il metodo termina quando, dopo aver eseguito il ciclo \textit{for}, il metodo ritorna l'\textit{array} sopracitato.

\item{\method{+ applyFilterByGroup(idGroup: int): array()}}\\
Metodo che dato un intero come parametro d'ingresso filtra la lista di contatti presente in locale, restituendo un elenco dei contatti appartenenti al gruppo avente id uguale a idGroup, inoltre non deve interagire con il \inglese{server}, ovvero non vengono richiamate \inglese{servlet}. 

Come per \method{applyFilterByString()} anche in questo caso il metodo deve creare un \textit{array} da popolare con i contatti appartenente al gruppo idGroup. Quindi viene eseguito un ciclo \inglese{for} che ispezione tutti i contatti presenti in \memberdata{contacts} e per ogni ciclo il metodo controlla i gruppi in cui compare il contatto i-esimo (tale azione si attua per mezzo di un secondo ciclo innestato), se si verifica una corrispondenza tra l'id del gruppo in esame con l'identificativo idGroup, si aggiunge il contatto all'\textit{array} creato in precedenza. Il metodo termina restituendo l'\textit{array} sopra-citato.

\item{\method{+ showFilter(filteredContacts: Array()): void}}\\
Metodo usato per l'eliminare il contenuto preesistente nella rubrica e visualizza il nuovo contenuto filtrato. Il metodo riceve come parametro un \textit{array} che rappresenta la lista filtrata dei contatti da visualizzare. Per eseguire tali operazioni viene avviato un ciclo \inglese{for} per ogni contatto presente in \memberdata{contacts}. All'interno di tale ciclo deve essere eseguita la seguente istruzione:\\

\verb|addListItem(/*nome della variabile contenente il nodo dom AddressBookList*/,|\\
\verb|filtredContacts[contact])|\\

\item{\method{+ contactAlredyPresent(contact: Object(contact)): boolean}}\\
Metodo che dato un contatto verifica se appartiene alla rubrica. Per compiere tale azione viene da prima riscaricata la rubrica, mediante una chiamata a metodo \method{getAddressBookContacts()}. Quindi si usa un ciclo \inglese{for} per scorrere l'intera lista precedentemente ottenuta e ad ogni ciclo si controlla se il contatto i-esimo ha id uguale a quello del contatto ricevuto come parametro d'ingresso (\texttt{contact.id}). Se tale confronto ha esito positivo, il metodo termina ritornando \inglese{true}, altrimenti il metodo termina al termine del ciclo \inglese{for} ritornando \inglese{false}.

\item{\method{+ blockUser(contact: Object(contact)): boolean}}\\
Metodo utilizzato per bloccare (all'interno della rubrica utente) il contatto contact passato come parametro d'ingresso. Il primo step consiste nell'eseguire il controllo sul parametro ricevuto. Per farlo si osserva il valore ritornato da una chiamata a metodo \method{constactAlradyPresent()} passando come parametro d'ingresso contact. Se il valore di ritorno è \inglese{false} il metodo termina con l'eccezione ``Contatto non presente nella rubrica''. Altrimenti il controllo passa allo step successivo, in cui si verifica se l'attributo blocked di contact è impostato a \inglese{true}. Nel caso il metodo termina con l'eccezione ``Contatto già bloccato''. Se il flusso principale ha superato i test precedenti, allora viene creata un istanza di request \texttt{XMLHttpRequest()} usata per contattare la \inglese{servlet} avente nome:\\

\verb|urlServlet + operations[8] + suffix|\\

Per tale richiesta deve essere associata, all'evento \texttt{onreadystatechange}, una funzione che salva in un array il contenuto di una chiamata:\\

\verb|JSON.parse(request.responseText)|\\

Il flusso principale prosegue aprendo la request cosi definita (uso del metodo \texttt{open("POST", urlServlet + operations[8] + suffix, "true")}) e inviando il contatto mediante una chiamata \texttt{request.send("contactId=" + contact.id)}.

Il metodo termina eseguendo un controllo. Se il risultato result della chiamata a \inglese{servlet} ha valore \inglese{true} allora il metodo termina aggiornando la rubrica mediante una chiamata \method{setup()} e ritornando \inglese{true}. In caso contrario il metodo termina con un eccezione.

\item{\method{+ unlockUser(contact: Object(contact)): boolean}}\\
Metodo usato per sbloccare un utente all'interno di una rubrica. Il metodo ha un funzionamento analogo al precedente, nello specifico vengono attuati gli stessi controlli prima tramite \method{contactAlradyPresent()} e poi tramite la verifica del contenuto del di contact.block. Successivamente si crea una XMLHttpRequest che si appoggia alla \inglese{servlet} definita dalla stringa:\\

\verb|urlServlet + operations[9] + suffix|\\

Tale server ha il compito di sbloccare il contatto \textit{contact}. Quindi il metodo termina eseguendo un controllo sul tipo di risultato. Se l'operazione precedente è avvenuta con successo allora si procede aggiornando la rubrica (chiamata a metodo \method{setup()}), altrimenti il metodo termina con un eccezione.

\item{\method{+ getGroupsWhereContactsIs(contact: Object(contact)): Object(group)}}\\
Tale metodo ha il compito, dato un utente, di ritornare una lista di gruppi in cui esso è presente. Riceve come unico parametro il contatto da ricercare e successivamente vengono ciclati tutti i gruppi e per ogni gruppo si controlla se è inserito il contatto, in caso di match viene aggiunto il gruppo alla lista di gruppi da ritornare.


\end{description}

\classsection{LoginPanelPresenter}

\subsubsection*{Funzione}
Presenter incaricato di gestire il pannello di \textit{login}, prende in carica i dati inseriti dall'utente (username e password) passandoli al server per eseguire l'autenticazione. La \inglese{servlet} usata a tale scopo è \texttt{LoginManager}.

Il presenter si occupa anche di fornire delle funzionalità per il recupero della password.

\subsubsection*{Relazioni d'uso}

Nessuna relazione evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}

  \item{\memberdata{-- element: DOM\_node}}\\
  Attributo che definisce il contenuto del nodo DOM inerente alla schermata di \inglese{login}, nello specifico tale nodo corrisponde ad un \texttt{<div>} con id \texttt{LoginPanel}.
  \item{\memberdata{-- urServlet: String}}\\
  Attributo contenente l'url della \inglese{servlet} incaricata di gestire il \inglese{login}.

\end{description}

\subsubsection*{Metodi}
\begin{description}

	\item{\method{-- testCredentials(data: String): void}}\\
Metodo che testa quanto ricevuto dal server e, in caso di login avvenuto correttamente, reindirizza il browser nel presenter finale dopo aver salvato i dati dell'utente. Il metodo inizia salvando in una variabile avente nome \inglese{user} il contenuto di data trattato attraverso una chiamata \texttt{JSON.parse(data)}, quindi se il contenuto di user non è nullo si procede richiamando il \texttt{communicationcenter} e impostando il valore di \texttt{communicationcenter.my} a \inglese{user}. Il metodo termina richiamando il metodo \method{hide()} e avviando la costruzione della UI mediante una chiamata \method{medietor.buildUI()}.
	
	\item{\method{+ sendAnswer(username: String, answer: String): void}}\\
	Metodo per inviare la risposta alla domanda segreta al server, riceve due parametri d'ingresso: lo \inglese{username} dell'utente e la risposta (\inglese{answer}) da inviare al \inglese{server}. Come primo passo viene creata un istanza di \texttt{XMLHttpRequest} salvata in una variabile avente nome \textit{request}, successivamente si associa all'evento \texttt{onclick} di \textit{request} una funzione avente il compito di inviare la richiesta \textit{AJAX} al server, e di richiamare in risposta uno dei seguenti metodi:
	\begin{itemize}
		\item \method{correctAnswer()} nel caso la risposta inviata sia corretta;
		\item \method{incorrectAnswer()} se invece la risposta inviata dall'utente è errata.
	\end{itemize}
	
	\item{\method{+ correctAnswer(): void}}\\
	Metodo usato per modificare il nodo DOM salvato in \memberdata{element} per comunicare all'utente che la risposta da lui inserita (per il recupero password) è corretta. 
Il metodo deve rimuovere il figlio \textit{passwordretrieval} da \memberdata{element} quindi salva in una variabile avente nome \textit{message} il contenuto di una chiamata \verb|document.createElement("p")|. 
Successivamente procede caricando su \textit{message} (usando il metodo \texttt{appendChild(var\_figlio)}) il messaggio da visualizzare per notificare all'utente il successo dell'operazione. Il messaggio visualizzato sarà: \\
	
	\verb|Recupero password avvenuto correttamente.|\\
	\verb|Ti è stata inviata un'email contenente i dati richiesti.|\\
	
il messaggio sopracitato è temporaneo e dovrà essere rimosso allo scadere di un \inglese{timeout} di durata 2000 millisecondi (usare la funzione \texttt{window.setTimeout(nome\_funzione))}.
	
	\item{\method{+ incorrectAnswer(): void}}\\
	Metodo che In caso di inserimento della risposta non corretta alla domanda segreta visualizza un messaggio di avvertimento all'utente per 2 secondi quindi lascia il controllo al \inglese{form} di inserimento della risposta alla domanda segreta.
	
	Il metodo deve cercare un elemento (\texttt{document.createElement("p")}) per la visualizzazione del messaggio:\\
	
	\verb|Dati non corretti. Inserire nuovamente la risposta.|\\
	
	Quindi si visualizza il messaggio con una procedura identica a quella usata in \method{correctAnswer()}.
		
	\item{\method{+ getSecretQuestion(): void}}\\
	Metodo che recupera la domanda segreta con una richiesta asincrona al server, esso imposta una variabile \texttt{userID} con il valore ritornato da una chiamata \method{getUsername()}, quindi avvia una richiesta \textit{AJAX} inizializzando un oggetto \texttt{XMLHttpRequest}. La variabile \texttt{request} contenente tale istanza dovrà associare all'evento \texttt{onreadystatechange} una funzione che si occupa di catturare la stringa ritornata dal server (uso obbligatorio di \texttt{question = this.responseText}). Il metodo termina infine restituendo il valore contenuto in question.
	
	\item{\method{+ buildRetrievePasswordForm(): nodo\_DOM}}\\
	Metodo usato per costruire la \inglese{form} per il recupero della password utente, inizia costruendo la citata \inglese{form} con il valore ottenuto mediante una chiamata \verb|document.createElement("fieldset")|, quindi a partire dalla variabile in cui ha memorizzato il dato ritornato con il metodo precedente, imposta l'attributo \textit{id} con \textit{passwordretrieval}. Definisce quindi una \inglese{label} con la domanda (utilizzare \verb|document.createElement("label")| e imposta l'attributo \texttt{for} con \textit{inputanswer}). Il metodo procede impostando il campo d'immissione della domanda e successivamente si impostano i seguenti attributi:
	\begin{itemize}
		\item attributo id con ``inputanswer'';
		\item attributo name con ``inputanswer'';
		\item attributo placeholder con ``risposta'';
		\item attributo required con ``required'';
	\end{itemize}
	
	Successivamente si crea il bottone di \texttt{submit} impostando gli attributi:
	\begin{itemize}
		\item attributo type con ``submit'';
		\item attributo value con ``OK'';
	\end{itemize}
	
	Associare all'evento \texttt{click} del bottone una funzione che richiami \method{sendAnswer()} passando come attributi \memberdata{username} e il valore contenuto nell'elemento \texttt{inputAnswer}.
	
	In ultima si usa \texttt{appendChild} per agganciare al nodo DOM la \inglese{label} e \texttt{inputAnswer}. Il metodo termina ritornando il nodo DOM.
	
	\item{\method{+ getUsername(): String}}\\
	Metodo  per il recupero dello \inglese{username} dall'interfaccia grafica. Per tale operazione il metodo deve usare l'istruzione:\\
	
	\verb|var username = document.getElementById("username").value;|
	\\
	
	quindi verifica se il contenuto di \inglese{username} è vuoto o no: nel caso lo sia, termina, altrimenti procede nel verificare se l'email inserita rispetta l'espressione regolare:\\
	
	\verb|^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$|
	\\
	
	il metodo termina ritornando \inglese{username}.	
	
	\item{\method{+ getPassword(data: array()): String}}\\
	Metodo che esegue il \inglese{login} inviando al server i dati di autenticazione, esso riceve come parametro d'ingresso un \textit{array} associativo contenente \textit{username} e \textit{password}.
	
	Il flusso principale inizia verificando il che il contenuto di \texttt{data.username} e di \texttt{data.password} non sia vuoto, quindi invia una richiesta \textit{AJAX} al \textit{server} (come sempre in questo caso è d'obbligo usare \verb|var request = new XMLHttpRequest();|).
	Il programmatore dovrà associare all'evento \texttt{onreadystatechange} una funzione che si occupa di richiamare il metodo \method{testCredentials()}. Il passo successivo consiste ``nell'aprire'' la richiesta \textit{request} con un istruzione \texttt{open()} che riceve come parametro l'url della \inglese{servlet} associata (valore presente in \memberdata{servletURL}), successivamente viene usata un istruzione \texttt{setRequestHeader()} passando i seguenti parametri:
	\begin{itemize}
		\item[•] ``content-type'';
		\item[•] ``application/x-www-form-urlencoded'';
	\end{itemize}
	infine va creata la \textit{querystring} da inviare (tramite istruzione request.send()), deve essere obbligatoriamente impostata a:\\
	
	\verb|"username=" + encodeURIComponent(data.username) +|\\ \verb|"&password=" + encodeURIComponent(data.password) + "&operation=1"|\\
	
	Il metodo termina ritornando la \textit{querystring}.

	\item{\method{+ hide(): void}}\\
	Metodo usato per nascondere il \inglese{form} di autenticazione, per lasciare spazio nella finestra ad altri elementi grafici come la schermata principale o il pannello di registrazione.
	
	\item{\method{+ initialize(): void}}\\
	Metodo usato per inizializzazione del pannello di login con la creazione di tutti i \inglese{widget} grafici che sono contenuti al suo interno. Nello specifico il metodo esegue la creazione (nell'ordine proposto) dei seguenti elementi:
	\begin{itemize}
		\item form, con attributi:
		\begin{itemize}
			\item ``name'' impostato a ``login'';
			\item ``action'' impostato a ``'';
			\item ``method'' impostato a ``'';
			\item ``accept-charset'' impostato a ``utf-8'';				
		\end{itemize}
		\item ul contennete il form;
		\item li che conterrà lo username, con attributi;
		\item label che riporterà la frase ``Nome utente: ''. Label con attributi:
		\begin{itemize}
			\item ``for'' impostato a ``username'';		
		\end{itemize}
		\item input per l'inserimento della e-mail, con attributi:
		\begin{itemize}
			\item ``type'' impostato a ``email'';
			\item ``id'' impostato a ``username'';
			\item ``name'' impostato a ``username'';
			\item ``placeholder'' impostato a ``yourname@email.com'';				\item ``required'' impostato a ``required'';
		\end{itemize}		
		\item input per l'inserimento della password, con attributi:
		\begin{itemize}
			\item ``type'' impostato a ``password'';
			\item ``id'' impostato a ``password'';
			\item ``name'' impostato a ``password'';
			\item ``placeholder'' impostato a ``password'';				\item ``required'' impostato a ``required'';
		\end{itemize}		
		\item input submit pulsante di login, con attributi:
		\begin{itemize}
			\item ``type'' impostato a ``submit'';
			\item ``value'' impostato a ``Login'';
		\end{itemize}
		\item input submit pulsante di registrazione, con attributi:
		\begin{itemize}
			\item ``type'' impostato a ``submit'';
			\item ``value'' impostato a ``Registrazione'';
		\end{itemize}
		\item input submit pulsante di recupero password, con attributi:
		\begin{itemize}
			\item ``type'' impostato a ``submit'';
			\item ``value'' impostato a ``Recupera password'';
		\end{itemize}
	\end{itemize}

\end{description}

\classsection{RegisterPanelPresenter}

\subsubsection*{Funzione}
Presenter incaricato di gestire la \inglese{form} di registrazione

\subsubsection*{Relazioni d'uso}

Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}

  \item{\memberdata{-- servletURL: String}}\\
  Url della \inglese{servlet} che deve gestire la registrazione.
  \item{\memberdata{-- element: DOM\_node}}\\
  Elemento (inteso come nodo DOM) controllato da questo Presenter.

\end{description}

\subsubsection*{Metodi}
\begin{description}

	\item{\method{+ getSurname(): String}}\\
	Metodo che estrae dalla \inglese{form} il valore del cognome del nuovo utente e lo restituisce.
	
	\item{\method{+ getName(): String}}\\
	Metodo che estrae dalla \inglese{form} il valore del nome del nuovo utente e lo restituisce.
	
	\item{\method{+ getAnswer(): String}}\\
	Metodo che estrae dal \inglese{form} la risposta alla domanda segreta associata al nuovo utente e la restituisce.	
		
	\item{\method{+ getQuestion(): String}}\\
	Metodo che estrae dalla \inglese{form} la domanda segreta associata al nuovo utente e la restituisce.
	
	\item{\method{+ getPassword(): String}}\\
	Metodo che estrae dalla \inglese{form} la \textit{password} associata al nuovo utente e la restituisce.
	
	\item{\method{+ getUsername(): String}}\\
	Metodo che estrae dalla \inglese{form} lo \textit{username} del nuovo utente (per \textit{username} si intende l'indirizzo email dell'utente). Si osservi che il metodo dovrà verificare che la mail restituita sia ben formattata secondo l'espressione regolare:\\
	
	\verb|^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$|
	\\
	
	Se la mail è valida il metodo termina ritornandone il valore.
	
	\item{\method{+ getPicturePath(): String}}\\
	Metodo che estrae dalla \inglese{form} il percorso dell'immagine del nuovo profilo utente e lo restituisce.
	
	\item{\method{+ register(userData: Arrey()): String}}\\
	Metodo che Invia i dati ricevuti alla \inglese{servlet} per la creazione di un nuovo account utente. Tale metodo inizia creando un istanza (\inglese{request}) di \texttt{XMLHttpRequest} usata per comunicare con la \inglese{servlet}. Quindi il metodo abilita \textit{request} ad inviare un richiesta sincrona al \textit{server}, usando l'istruzione:\\
	
	\verb|request.open("POST", servletURL, false)|\\
	
	Il metodo procede definendo la stringa da usare come \textit{query} per da inviare alla \inglese{servlet}. Tale \textit{querystring} contiene:\\
	
	\verb|"username=" + encodeURIComponent(userData.username) +|\\
	\verb|"&password=" + encodeURIComponent(userData.password) +|\\
	\verb|"&question=" + encodeURIComponent(userData.question) +|\\
	\verb|"&answer=" + encodeURIComponent(userData.answer)|\\
	
	Il metodo termina restituendo il contenuto di \textit{querystring}.
	
	\item{\method{+ initialize(): void}}\\
	Metodo che si occupa di inizializzare la \inglese{form} di registrazione con la creazione di tutti i \inglese{widget} grafici che sono contenuti al suo interno. Nello specifico il metodo esegue i seguenti passi:
	\begin{itemize}
		\item[•] creazione dell'elemento \inglese{form};
		\item[•] creazione dell'elemento <ul> contenuto nel \inglese{form};		
		\item[•] creazione dell'item per lo username, definito mediante una \inglese{label} riportante la frase ``Indirizzo email: '', e di un campo \textit{input} di tipo email per l'inserimento della email dell'utente;
		\item[•] costruisce il \inglese{list item} con la \inglese{label} e l'\textit{input} definiti al punto precedente, usando il metodo \texttt{appendChild()};
		\item[•] crea l'item per la password, definendo una \inglese{label} riportante la frase ``Password: '' e un oggetto \textit{input} di tipi \textit{password};			
		\item[•] costruisce il \inglese{list item} con la \inglese{label} e l'input definiti al punto precedente, usando il metodo \texttt{appendChild()};
		\item[•] creazione dell'item per la domanda segreta definito mediante una \inglese{label} avente valore ``Domanda segreta: '' e un oggetto \textit{input} di tipo \texttt{text};
		\item[•] costruisce il \inglese{list item} con la \inglese{label} e l'\textit{input} definiti al punto precedente, usando il metodo \texttt{appendChild()};
		\item[•] creazione dell'item per la risposta alla domanda segreta, definito mediante una \inglese{label} avente valore ``Risposta: '' e un oggetto input di tipo \texttt{text};
		\item[•] costruisce il \inglese{list item} con la \inglese{label} e l'input definiti al punto precedente, usando il metodo \texttt{appendChild()};
		\item[•] creazione dell'item per il nome, definito mediante una \inglese{label} avente valore ``Nome: '' e un oggetto input di tipo \texttt{text};
		\item[•] costruisce il \inglese{list item} con la \inglese{label} e l'input definiti al punto precedente, usando il metodo \texttt{appendChild()};
		\item[•] creazione dell'item per il cognome, definito mediante una \inglese{label} avente valore ``Cognome: '' e un oggetto input di tipo \texttt{text};
		\item[•] costruisce il \inglese{list item} con la \inglese{label} e l'input definiti al punto precedente, usando il metodo \texttt{appendChild()};
		\item[•] creazione dell'item per inserire l'immagine utente, definito mediante una \inglese{label} avente valore ``Immagine del profilo: '' e un oggetto input di tipo \texttt{text};
		\item[•] costruisce il \inglese{list item} con la \inglese{label} e l'input definiti al punto precedente, usando il metodo \texttt{appendChild()};
		\item[•] creazione di un pulsante di registrazione (oggetto input di tipo submit e value ``Registrati'').
		\item[•] operazione finale per ``appendere'' tutti  gli oggetti creati al \texttt{registerForm}.
	\end{itemize}
	
	\item{\method{+ hide(): void}}\\
	Nasconde il \inglese{form} di registrazione per lasciare spazio alla schermata principale dell'applicativo (che deve essere costruita dal PresenterMediator).

\end{description}

%TODO da verificare
\classsection{CommunicationPanelPresenter}

\subsubsection*{Funzione}
Questo presenter ha il compito di gestire tutte le comunicazioni che possono avvenire tra persone, quindi sia di natura testuale che di tipo audio - audio/video.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
\item{\memberdata{-- chatElements: HTMLDivElements[]}}\\
  array associativo contenente tutte le chat aperte in un dato momento.
\end{description}

\subsubsection*{Metodi}
\begin{description}
\item{\method{- createLabel(user: Object(contact)): String}}\\
	Metodo che dato un utente (parametro del metodo), restituisce una stringa identificativa per il contatto in questione. Più precisamente, se il contatto contiene sia il nome che il cognome, la stringa restituita sarà composta da questi due elementi, altrimenti in base ai casi solo il nome o il cognome. Nell'ulteriore caso non siano presenti ne il nome ne il cognome, restituisce l'email, campo dati obbligatorio in fase di registrazione e quindi sempre presente.

\item{\method{- createChatItem(user: Object(contact)): DOM\_node}}\\
	Tale metodo restituisce un DOM\_element di tipo <li> contenente l'identificativo dell'utente con cui si sta comunicando (parametro del metodo). All'oggetto restituito viene assegnato un ``id'' corrispondente all'``id'' dell'utente con cui si vuole dialogare. All'evento \textit{onClick} viene collegato l'invocazione del metodo \method{displayChat(user)} che fa visualizzare la chat, viene inoltre creato il bottone per chiudere la chat che con l'evento ``onclick'' richiama il metodo \method{removeChat(user)}.

\item{\method{- createChatElement(user: Object(contact)): DOM\_node}}\\
	Tale metodo restituisce un DOM\_element contenente un \textit{div} che rappresenta l'area di chat. A tale elemento viene assegnato un ``id'' impostato a ``divContainerChat''. Deve essere creato anche una \textit{form} assegnando l'``id'' dell'utente come valore all'attributo ``id'' a tale \textit{form} va aggiunto una \textit{textarea} con \textit{id} impostato a \textit{chatText} dove andrà visualizzata la cronologia della chat; una casella di input con \textit{id} uguale \textit{input}; un bottone per inviare il messaggio assegnandogli all'evento \textit{onClick} l'invocazione del metodo \method{send(user, text)} del \textit{CommunicationPanelPresenter}. Infine viene aggiunta la \textit{form} all'elemento \textit{div} e ritornato.
	
\item{\method{+ displayChat(user: Object(contact)): void}}\\
Provoca la visualizzazione della chat con l'utente (ricevuto da parametro) nel \textit{div} contenitore pertinente.

\item{\method{+ addChat(user: Object(contact)): void}}\\
Provoca l'aggiunta di una chat, con l'utente ricevuto come parametro, andando ad aggiornare il campo privato \textit{chatElements} e visualizzandola nell'elemento ulOpenChat.
	
\item{\method{+ removeChat(user: Object(contact)): void}}\\
Comportamento simile al metodo scritto precedentemente. Viene chiusa una chat aperta con l'utente ricevuto da parametro andando ad eliminare l'elemento corrispondente da \textit{chatElements} e rimuovendo anche il DOM\_element dall'ulOpenChat.

\item{\method{+ appendToChat(user: Object(contact), text: String): void}}\\
Il metodo ha il compito di aggiunge una stringa \textit{text} all'interno dell'area di testo che è associata alla chat con l'utente \textit{user} (parametro del metodo).

\item{\method{+ createPanel(): DOM\_node}}\\
Con l'invocazione di tale metodo, viene inizializzato il pannello costruendo i \inglese{widget} grafici interni e lo restituisce in modo che possa essere inserito all'interno del pannello principale. Più dettagliatamente, deve costruire:
\begin{itemize}
\item div relativo alla chiamata assegnandogli come ``id'' CommunicationPanel;
\item div relativo alla gestione della chiamta assegnandogli come ``id'' divCall;
\item div relativo alla chat testuale assegnandogli come ``id'' divChat;
\item elemento video per la visualizzazione del proprio stream ricavato dalla videocamera con ``id'' myVideo;
\item elemento video per la visualizzazione dello \textit{stream} dell'altro utente con \textit{id} otherVideo;
\item div dove inserire la visualizzazione delle statistiche della chiamata tra cui:
\begin{itemize}
\item elemento ``span'' per byte Ricevuti con \textit{id}= statReceived;
\item elemento ``span'' per byte Inviati con \textit{id}= statSend;
\item elemento ``span'' per il tempo con \textit{id}= timerSpan;
\end{itemize}
\item bottone per la terminazione della chiamata che all'evento \textit{onClick} richiama il metodo \method{endCall()} di communicationcenter;
\item elemento div contenente le chat aperte.
\end{itemize}
Tutti gli elementi sopra descritti andranno poi aggiunti al parametro di ritorno \textit{element} tramite la funzione \method{appendChild()} fornita dai DOM\_element.

\item{\method{+ updateTimer(text: String): void}}\\
Il metodo aggiorna il tempo di comunicazione durante una chiamata. Imposta il campo \textit{value} dello \inglese{span} relativo alla visualizzazione del tempo chiamata con il valore del parametro ricevuto in input (text).

\item{\method{+ updateStats(text: String, isReceivedData: boolean): void}}\\
Il metodo controlla tramite il parametro booleano ricevuto in input (isReceivedData) se bisogna aggiornare lo span relativo ai dati inviati oppure lo span relativo ai dati ricevuti e lo imposta con il valore \textit{text} ricevuto per parametro.

\item{\method{+ getMyVideo(): DOM\_element}}\\
Il metodo ritorna l'elemento DOM con \textit{id} uguale ad ``myVideo''.

\item{\method{+ getOtherVideo(): DOM\_element}}\\
Il metodo ritorna l'elemento DOM con \textit{id} uguale ad ``otherVideo''.

\end{description}

\classsection{ContactPanelPresenter}

\subsubsection*{Funzione}
Presenter incaricato di gestire il pannello che visualizza le informazioni di un singolo contatto.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
\item{\memberdata{-- element: DOM\_element}}\\
  elemento controllato dal presenter in questione.
\end{description}

\subsubsection*{Metodi}
\begin{description}
\item{\method{- adjustBlockButtonDisplay(contact: Object(contact)): void}}\\
	Il metodo riceve come parametro un contatto (\textit{contact}), successivamente viene controllato se tale utente è bloccato o meno e imposta correttamente la proprietà \textit{style} agli elementi della vista. più dettagliatamente:\\
se il contatto è bloccato:
\begin{itemize}
\item nascondo il bottone per bloccare un utente;
\item mostro il bottone per sbloccare un utente
\end{itemize}
altrimenti\\
\begin{itemize}
\item mostro il bottone per bloccare un utente;
\item nascondo il bottone per sbloccare un utente
\end{itemize}


\item{\method{- buildGroupsDiv(contact Object(contact)): void}}\\
Il metodo, che riceve come parametro un contatto (\textit{contact}, ha il compito di recuperare tutti i gruppi 
 a cui il contatto appartiene e visualizzare nel \textit{div} opportuno una \textit{label} per ogni gruppo trovato indicandone il nome. 

\item{\method{+ createPanel():DOM\_element}}\\
Metodo richiamato quando viene selezionato un contatto dalla rubrica. Inizializza il pannello che mostra le informazioni del contatto selezionato. Più precisamente, verranno creati tanti listItem (<li>) quanti i seguenti elementi:
\begin{itemize}
\item nome;
\item cognome;
\item email;
\item avatar raffigurante l'immagine del contatto;
\item div contenente i gruppi a cui il contatto appartiene;
\item pulsante per la chiamata audio;
\item pulsante per la chiamata video;
\item pulsante per avviare una chat;
\item pulsante per bloccare il contatto;
\item pulsante per sbloccare il contatto.
\end{itemize}
Infine ritorno l'elemento creato.
	
\item{\method{+ display(contact: Object(contact)): void}}\\
Metodo che popola nel corretto modo tutti gli elementi necessari per la visualizzazione di un utente. Prima di tutto quindi si recupereranno tutti gli elementi necessari, ossia:
\begin{itemize}
\item elemento per nome;
\item elemento per cognome;
\item elemento per email;
\item elemento per avatar;
\item pulsante per aggiungere un contatto alla rubrica;
\item pulsante per la chiamata audio;
\item pulsante per la video-chiamata;
\item pulsante per avviare una chat;
\item pulsante per bloccare il contatto;
\item pulsante per sbloccare il contatto.
\end{itemize}
Successivamente si andranno a popolare tali elementi utilizzando le informazioni del contatto passato come parametro (\textit{contact}), infine si imposterà correttamente il comportamento dei bottoni associando le giuste chiamate a metodi del \textit{mediator}, ossia:
\begin{itemize}
\item aggiungi contatto --> onContactAdded(contact.id);
\item blocca contatto --> onBlockContact();
\item sblocca contatto --> onUnlockContact();
\item chiamata audio --> onCall(contact, false);
\item chiamata video --> onCall(contact, true);
\item avvia chat --> onChatStarted(contact);
\end{itemize}

\end{description}

%TODO da verificare
\classsection{MainPanelPresenter}

\subsubsection*{Funzione}
Presenter incaricato di gestire il pannello principale, ossia quello centrale.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
\item{\memberdata{-- element: DOM\_element}}\\
  elemento controllato dal presenter in questione.
\end{description}

\subsubsection*{Metodi}
\begin{description}
\item{\method{+ initialize(): void}}\\
Metodo utilizzato per costruire il pannello principale che occupa la parte centrale della finestra, esso imposta inoltre l'immagine del logo ``MyTalk'' come sfondo quando il pannello è vuoto.

\item{\method{+ displayChildPanel(node DOM\_node): void}}\\
Metodo che visualizza il DOM\_node (\textit{node}) ricevuto come parametro nel pannello in questione.
	
\item{\method{+ hide(): void}}\\
Metodo che rende invisibile il pannello impostando la proprietà \textit{display} a ``none''.

\end{description}

\classsection{PresenterMediator}

\subsubsection*{Funzione}
Presenter incaricato di gestire la collaborazione tra i vari sotto-presenter.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
\item{\memberdata{-- presenters: Array associativo}}\\
  \textit{array} contenente tutti i sotto-presenter.\\
  Presenter di primo livello:
  \begin{itemize}
  \item login --> LoginPanelPresenter;
  \item register --> RegisterPanelPresenter;
  \item addressbook --> AddressBookPanelPresenter;
  \item tools --> ToolsPanelPresenter;
  \item main --> MainPanelPresenter.
  \end{itemize}
  Presenter di secondo livello:
  \begin{itemize}
  \item accountsettingspp --> AccountSettingsPanelPresenter;
  \item communicationpp --> CommunicationPanelPresenter;
  \item contactpp --> ContactPanelPresenter;
  \item callhistorypp --> CallHistoryPanelPresenter;
  \item messagepp --> MessagePanelPresenter;;
  \item searchresultpp --> SearchResultPanelPresenter;
  \item grouppp --> GroupPanelPresenter.
  \end{itemize}
\end{description}

\subsubsection*{Metodi}
\begin{description}
\item{\method{- getCommunicationPP(): CommunicationPanelPresenter}}
Il metodo restituisce l'istanza dell'attributo di tipo  CommunicationPanelPresenter.

\item{\method{+ buildUI(): void}}\\
Tale metodo ha il compito di inizializzare l'interfaccia grafica delegando ai presenter il compito di disegnare gli elementi principali dell'interfaccia, incaricando i presenter di primo livello di creare e popolare i rispettivi pannelli. In particolare, si nasconderanno i seguenti pannelli:
\begin{itemize}
\item register;
\item login;
\item addressbook;
\item main;
\item tools.
\end{itemize}


\item{\method{+ buildLoginUI(): void}}\\
Visualizza l'interfaccia di autenticazione al sistema, che comprende il \textit{form} di \textit{login}. Viene chiamato quindi il metodo \method{initialize()} del LoginPanelPresenter per la sua costruzione.
	
\item{\method{+ buildRegistrationUI(): void}}\\
Visualizza il form di registrazione al sistema, utilizzato dagli utenti che vogliono creare un nuovo account, viene chiamato quindi il metodo \method{initialize()} del RegisterPanelPresenter per la sua costruzione.

\item{\method{+ onContactSelected(contact: Object(contact)): void}}\\
Metodo invocato nel momento in cui viene selezionato un contatto, tale evento invoca il metodo \method{display} del ContactPanelPresenter prendendo come parametro l'oggetto \textit{contact} ricevuto inizialmente. 


\item{\method{+ onContactAdded(contact: Object(contact)): void}}\\
Funzione di \textit{callback} richiamata dai pulsanti di SearchResultPanel che comunica all'AddressBookPanelPresenter di aggiungere un contatto. Riceve come parametro l'utente che si vuole aggiungere (\textit{contact}), questo parametro viene a suo volta passato alla funzione \texttt{addContact()} di addressBookPanelPresenter. In caso di errore, viene segnalato con un \textit{alert}.

\item{\method{+ onContactRemoved(userID: String): void}}\\
Funzione di \textit{callback} richiamata dai pulsanti di SearchResultPanel che comunica all'AddressBookPanelPresenter di rimuovere un contatto. Il metodo riceve come parametro l'utente che si vuole rimuovere (contact). Questo parametro viene a suo volta passato alla funzione \texttt{removeContact()} di addressBookPanelPresenter. In caso di errore, viene segnalato con un \textit{alert}.

\item{\method{+ onGroupAdded(name: String): void}}\\
Funzione di \textit{callback} richiamata dai pulsanti di SearchResultPanel che comunica all'AddressBookPanelPresenter di aggiungere un gruppo. Il metodo riceve come parametro il nome del nuovo gruppo che si vuole aggiungere (name). Questo parametro viene a suo volta passato alla funzione addGroup() di addressBookPanelPresenter.


\item{\method{+ onGroupRemoved(group: object(group)): void}}\\
Funzione di \textit{callback} richiamata dai pulsanti di SearchResultPanel che comunica all'AddressBookPanelPresenter di rimuovere un gruppo. Il metodo riceve come parametro il gruppo che si vuole rimuovere (\textit{group}). Questo parametro viene a suo volta passato alla funzione \texttt{removeGroup()} di addressBookPanelPresenter.


\item{\method{+ onContactAddeddInGroup(contact: Object(contact), group: Object(group)): void}}\\
Funzione di \textit{callback} richiamata dai pulsanti di SearchResultPanel che comunica all'AddressBookPanelPresenter di aggiungere un contatto ad un gruppo. Il metodo riceve come parametro il contatto che si vuole aggiungere (\textit{contact}) e il gruppo a cui aggiungere il contatto (\textit{group}). Questi parametri vengono a suo volta passati alla funzione \texttt{addContactInGroup()} di addressBookPanelPresenter.


\item{\method{+ onContactRemovedInGroup(contact: Object(contact), group: Object(group)): void}}\\
Funzione di \textit{callback} richiamata dai pulsanti di SearchResultPanel che comunica all'AddressBookPanelPresenter di rimuovere un contatto da un gruppo. Il metodo riceve come parametro il contatto che si vuole rimuovere (\textit{contact}) e il gruppo a cui rimuovere il contatto (\textit{group}). Questi parametri vengono a suo volta passati alla funzione \texttt{removeContactFromGroup()} di addressBookPanelPresenter.


\item{\method{+ onBlockedContact(contact: Object(contact)): void}}\\
Funzione di \textit{callback} che comunica all'AddressBookPanelPresenter di bloccare un contatto. Il metodo riceve come parametro il contatto che si vuole bloccare (\textit{contact}), questo parametro viene a suo volta passato alla funzione \texttt{blockUser()} di addressBookPanelPresenter. In caso di errore, viene notificato con un \textit{alert} riportando l'errore relativo.


\item{\method{+ onUnlockContact(contact: Object(contact)): void}}\\
Funzione di \textit{callback} che comunica all'AddressBookPanelPresenter di sbloccare un contatto. Il metodo riceve come parametro il contatto che si vuole sbloccare (\textit{contact}), questo parametro viene a suo volta passato alla funzione \texttt{unlockUser()} di addressBookPanelPresenter. In caso di errore, viene notificato con un \textit{alert} riportando l'errore relativo.


\item{\method{+ displayMessagePanel(): void}}\\
Provoca la creazione del pannello della segreteria e la sua visualizzazione all'interno del MainPanel come elemento figlio. La costruzione del pannello è affidata al metodo \textit{createPanel} che viene reso disponibile da tutti i presenter di secondo livello, viene quindi creato dal metodo \method{createPanel()} del presenter messagePanelPresenter un elemento di tipo DOM\_node che viene poi passato al presenter \textit{main} come parametro del metodo \method{displayChildPanel}.


\item{\method{+ displayAccountSettingsPanel(): void}}\\
Provoca la creazione del pannello delle impostazioni dell'utente e la sua visualizzazione all'interno del MainPanel. Come il metodo sopra citato, viene creato dal metodo \method{createPanel()} del presenter CallHistoryPanelPresenter un elemento di tipo DOM\_node che viene poi passato al presenter \textit{main} come parametro del metodo \method{displayChildPanel}.


\item{\method{+ displayCallHistoryPanel(): void}}\\
Provoca la creazione del pannello dello storico delle chiamate e la sua visualizzazione all'interno del MainPanel. Come il metodo sopra citato, viene creato dal metodo \method{createPanel()} del presenter CallHistoryPanelPresenter un elemento di tipo DOM\_node che viene poi passato al presenter \textit{main} come parametro del metodo \method{displayChildPanel}.


\item{\method{+ onFiltredApplyedByParam(param: String): void}}\\
Funzione di \textit{callback} richiamata dai pulsanti di SearchResultPanel che comunica all'AddressBookPanelPresenter di filtrare la lista dei contatti secondo il parametro ricevuto (param). Viene scatenata l'invocazione del metodo \method{applyFilterByString} del presenter AddressBookPresenter passandogli come parametro \textit{param}.

\item{\method{+ getGroupsWhereContactsIs(contact: Object(contact)): void}}\\
Funzione di \textit{callback} che comunica all'AddressBookPanelPresenter di cercare i gruppi a cui appartiene un utente nella propria rubrica ricevuto come parametro (contact). Viene quindi invocato il metodo \method{getGroupsWhereContactIs()} del presenter AddressBookPanelPresenter.

\item{\method{+ displaySearchResultPanel(): void}}\\
Provoca la creazione del pannello delle impostazioni del proprio account e la sua visualizzazione all'interno del MainPanel. Viene creato dal metodo \method{createPanel()} del presenter AccountSettingsPanelPresenter un elemento di tipo DOM\_node che viene poi passato al presenter \textit{main} come parametro del metodo \method{displayChildPanel}.


\item{\method{+ displayCommunicationPanel(): void}}\\
Provoca la creazione del pannello delle comunicazioni e la sua visualizzazione all'interno del MainPanel. Viene creato dal metodo \method{createPanel()} del presenter CommunicationPanelPanelPresenter un elemento di tipo DOM\_node che viene poi passato al presenter \textit{main} come parametro del metodo \method{displayChildPanel}.

\item{\method{+ displayContact(contact: Object(contact)): void}}\\
L'invocazione di tale metodo provoca la visualizzazione della scheda di un contatto (contact) nel CommunicationpanelPresenter. Viene richiamato il metodo \method{displayCommunicationPanel()} e successivamente il metodo \method{display} passando come contatto il parametro ricevuto precedentemente.

\item{\method{+ contactAlreadyPresent(contact: Object(contact)): boolean}}\\
Metodo che controlla se l'utente ricevuto come parametro del metodo (contact) è gia presente nella rubrica. Viene invocato il metodo \method{contactAlreadyPresent()} di AddressBookPanelPresenter passando come parametro il contatto in questione.

\item{\method{+ onChatStarted(user: Object(contact)): void}}\\
Coordina i presenter nel momento in cui ha inizio una nuova comunicazione testuale e incapsula la collaborazione fra ContactPanelPresenter e CommunicationPanelPresenter. Viene quindi
\begin{itemize}
\item invocato il metodo \method{createPanel()} di CommunicationPanelPresenter;
\item invocato il metodo \method{displayChildPanel()} di MainPanelPresenter passandogli come parametro l'oggetto creato precedentemente;
\item invocato il metodo \method{addChat()} di CommunicationPanelPresenter passando come parametro l'utente interessato;
\item invocato il metodo \method{displayChat()} di CommunicationPanelPresenter passando come parametro l'utente interessato.
\end{itemize} 

\item{\method{+ onCall(contact: Object(contact), onlyAudio: boolean): boolean}}\\
Metodo per gestire la chiamata, riceve come parametri l'utente che si vuole chiamare (\textit{contact}) e un \textit{flag} per segnalare se la chiamata è solo audio (\textit{onlyAudio}).

\end{description}

\classsection{MessagePanelPresenter}

\subsubsection*{Funzione}
Presenter incaricato di gestire i messaggi in segreteria.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
\item{\memberdata{-- messages: Message[]}}\\
Array che conterrà tutti i messaggi della segreteria
\item{\memberdata{-- servlets: String[]}}\\
Array che contiene le tre URL delle \inglese{servlets} da contattare per i messaggi
\end{description}

\subsubsection*{Metodi}
\begin{description}
\item{\method{- getServletURLs(): void}}\\
Configura gli URL delle \inglese{servlet} da interrogare leggendoli dal file di configurazione in base alle operazioni che questo presenter deve essere in grado di compiere.\\
Più precisamente, si dovrà creare una ``XMLHttpRequest'' rivolta al file XML di configurazione dove sono riportate tutte le \inglese{servlet}, ricevuta la risposta si popolerà l'\textit{array} dichiarato nella classe (\inglese{servlet}).

\item{\method{- deleteMessage(idMessage: String): void}}\\
Elimina un messaggio dalla segreteria contattando la \inglese{servlet} responsabile dell'operazione e scaricando nuovamente i messaggi. Il metodo procede quindi nell'invocazione della \inglese{servlet} corretta passando come parametro l'``id'' ricevuto come parametro del metodo (idMessage). Se la \inglese{servlet} ritorna il valore \textit{true}, significa che l'eliminazione è andata a buon fine e quindi si riscaricano i messaggi. In caso di errore, apparirà all'utente un messaggio d'errore indicante il motivo.

\item{\method{- addListItem(message: Object()): void}}\\
Aggiunge un messaggio ad una lista per creare l'elenco della segreteria telefonica generale. Viene quindi creati un \textit{list item} e successivamente aggiunto alla lista MessageList di tale Presenter.

\item{\method{- setAsRead(idMessage: String, valueToSet: String): void}}\\
Imposta lo stato di un messaggio come ``letto'' oppure ``non letto'' a seconda del parametro ricevuto in input. Tale metodo demanda il compito alla \inglese{servlet} opportuna passandogli entrambi i parametri (idMessage e valueToSet). In caso di messaggio d'errore da parte del server, viene notificato anche all'utente.

\item{\method{- getMessages(): void}}\\
Ottiene i messaggi di segreteria salvati nel server contattando la \inglese{servlet} corrispondente. Una volta ricevuta risposta con relativi dati associati, li salva all'interno dell'\textit{array messages} dichiarato all'interno di questo presenter. Per contattare la \inglese{servlet}, va usato come in precedenza ``XMLHttpRequest''.

\item{\method{+ createPanel(): DOM\_element}}\\
Costruisce il pannello della segreteria telefonica, che deve essere visualizzato all'interno del MainPanel dell'applicazione quando è selezionata la funzione corrispondente dal pannello degli strumenti. Il MessagePanel è costituito da un elemento video seguito da un \textit{div} che a sua volta contiene una lista di messaggi creata con l'ausilio dei metodo \method{getMessages()} e \method{addListItem()}. Tutti questi elementi vanno aggiunti all'elemento \textit{element} ritornato poi dal metodo.

\item{\method{+ setup(): void}}\\
Metodo che ogni sua invocazione provoca il recupero dei messaggi in segreteria. Al suo interno sarà presente la chiamata al metodo \method{getMessages()}.

\end{description}


%TODO da verificare
\classsection{CallHistoryPanelPresenter}

\subsubsection*{Funzione}
Presenter incaricato alla gestione dello storico chiamate.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
\item{\memberdata{-- calls: String[]}}\\
Array che conterrà tutte le chiamate effettuate
\item{\memberdata{-- servlets: String[]}}\\
Array che contiene le tre URL delle \inglese{servlet} da contattare per i messaggi
\end{description}

\subsubsection*{Metodi}
\begin{description}
\item{\method{- getServletURLs(): void}}\\
Configura gli URL delle \inglese{servlet} da interrogare leggendoli dal file di configurazione in base alle operazioni che questo presenter deve essere in grado di compiere.\\
Più precisamente, si dovrà creare una ``XMLHttpRequest'' rivolta al file XML di configurazione dove sono riportate tutte le \inglese{servlet}, ricevuta la risposta si popolerà l'\textit{array} dichiarato nella classe (\inglese{servlet}).

\item{\method{- getCalls(): String}}\\
Ottiene tutta la lista delle chiamate effettuate e tracciate nel \textit{server}, una volta ricevuta risposta con relativi dati associati li utilizza come dati di ritorno. Per contattare la \inglese{servlet}, va usato come in precedenza ``XMLHttpRequest''.

\item{\method{- addListItem(call: String): void}}\\
Aggiunge alla lista delle chiamate visualizzata nel CallHistoryPanel una nuova voce che corrisponde alla chiamata ricevuta da parametro. Ogni voce della lista contiene i dati relativi alla chiamata e non consente di effettuare alcuna azione su di essa.

\item{\method{+ createPanel(): DOM\_element}}\\
Costruisce il pannello dello storico delle chiamate, che deve essere visualizzato all'interno del MainPanel dell'applicazione quando è selezionata la funzione corrispondente dal pannello degli strumenti. Il CallHistoryPanel è costituito da una semplice lista con tanti \textit{list Item} quante sono le chiamate tracciate nel server. Tutti questi elementi vanno aggiunti all'elemento \textit{element} ritornato poi dal metodo.

\item{\method{+ setup(): void}}\\
Metodo che ogni sua invocazione provoca il recupero dello storico chiamate, verrà quindi per prima cosa richiamato il metodo \method{getCalls()} e successivamente una chiamata al metodo \method{addListItem(call)} per ogni chiamata ritornata.

\end{description}

%TODO da verificare
\classsection{SearchresultPanelPresenter}

\subsubsection*{Funzione}
Presenter incaricato di gestire il pannello che visualizza i risultati di ricerca.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
\item{\memberdata{-- servlets: String[]}}\\
Array che contiene le URL delle \inglese{servlet} da contattare per eseguire ricerche
\end{description}

\subsubsection*{Metodi}
\begin{description}
\item{\method{- getServletURLs(): void}}\\
Configura gli URL delle \inglese{servlet} da interrogare leggendoli dal file di configurazione in base alle operazioni che questo presenter deve essere in grado di compiere.\\
Più precisamente, si dovrà creare una ``XMLHttpRequest'' rivolta al file XML di configurazione dove sono riportate tutte le \inglese{servlet}. Ricevuta la risposta, si popolerà l'\textit{array} dichiarato nella classe (\inglese{servlet}).

\item{\method{- addListItem(list: DOM\_element, contact: Object(contact)): void}}\\
Aggiunge alla lista ricevuta da parametro (\textit{list}) il contatto anch'esso ricevuto da parametro (\textit{contact}). L'aggiunta del contatto alla lista avviene prima di tutto effettuando un controllo sui dati da visualizzare nel \textit{list item} che se presenti nel database saranno:
\begin{itemize}
\item nome;
\item cognome;
\item email;
\item immagine profilo.
\end{itemize}
Infine, si assegna il comportamento corretto all'evento ``onClick'' che andrà a richiamare il metodo \method{onContactSelected(contact)} del MediatorPresenter.

\item{\method{+ createPanel(): DOM\_element}}\\
Costruisce il pannello dei risultati di ricerca, che deve essere visualizzato all'interno del MainPanel dell'applicazione quando viene effettuata una ricerca. Il SearchResultPanel è costituito da una semplice lista che verrà popolata con i risultati della ricerca.

\item{\method{+ displayContactList(contacts: Object(contact)): void}}\\
Metodo che visualizza all'interno del pannello una lista di contatti che ottenuta dal server a seguito di una ricerca. Tale metodo demanda la visualizzazione per ogni contatto richiamando il metodo \method{addListItem(userList, contact}.

\end{description}


\classsection{GroupPanelPresenter}

\subsubsection*{Funzione}
Presenter incaricato di gestire i gruppi.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
\item Nessun attributo presente.
\end{description}

\subsubsection*{Metodi}
\begin{description}
\item{\method{- addListItem(list: DOM\_element, group: Object(group)): void}}\\
Aggiunge alla lista ricevuta come parametro (\textit{list}) un gruppo, anch'esso ricevuto come parametro (\textit{group}) creando un listItem (<li>). Il \textit{list item} sarà composto da uno \textit{span} con il nome del gruppo e vicino dovrà apparire un'immagine per l'eliminazione del gruppo stesso. Va quindi gestito il comportamento all'evento ``onclick'' su tale immagine che comporterà l'eliminazione del gruppo. Prima di procedere alla vera e propria eliminazione, dovrà apparire all'utente un messaggio di conferma che chiede se effettivamente vuole cancellare il gruppo: se l'utente accetta, viene richiamato il metodo del MediatorPresenter \method{onGroupRemoved(group)} che procedere ad eliminare il gruppo.

\item{\method{+ createPanel(): DOM\_element}}\\
Costruisce il pannello per la gestione dei gruppi, che deve essere visualizzato all'interno del MainPanel dell'applicazione quando viene richiesta tale operazione. Il GroupPanel è costituito da una semplice lista contenente tanti \textit{list item} quanti sono i gruppi dell'utente.

\item{\method{+ displayGroupList(groups: Object(group)): void}}\\
Metodo che visualizza all'interno del pannello una lista di gruppi, tale metodo demanda la visualizzazione di ogni singolo gruppo richiamando il metodo \method{addListItem(groupList, group}.

\end{description}


\classsection{ToolsPanelPresenter}

\subsubsection*{Funzione}
Presenter incaricato di gestire il pannello degli strumenti.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
\item{\memberdata{-- servlets: String[]}}\\
Array che contiene le URL delle \inglese{servlet} relative a tale presenter
\item{\memberdata{-- element: DOM\_element}}\\
elemento di tipo DOM che rappresenta l'intero pannello
\end{description}

\subsubsection*{Metodi}
\begin{description}
\item{\method{- getServletURLs(): void}}\\
Configura gli URL delle \inglese{servlet} da interrogare leggendoli dal file di configurazione in base alle operazioni che questo presenter deve essere in grado di compiere.\\
Più precisamente, si dovrà creare una ``XMLHttpRequest'' rivolta al file XML di configurazione dove sono riportate tutte le \inglese{servlet}. Ricevuta la risposta, si popolerà l'\textit{array} dichiarato nella classe (\inglese{servlet}).

\item{\method{+ initialize()(): void}}\\
Inizializza il pannello degli strumenti dell'applicazione rendendolo visibile. Tale pannello conterrà link che rimandano a tutte le funzioni disponibili per l'operazione scelta. In particolare:
\begin{itemize}
\item sezione che rimanda alle funzionalità della segretaria;
\item sezione che rimanda alle impostazioni dell'account;
\item sezione che rimanda alle funzionalità dello storico chiamate;
\item sezione che rimanda alle funzionalità della gestione dei contatti.
\end{itemize}
Tutte queste sezioni saranno espresse come list item di una lista. All'evento ``onclick'' su ogni sezione corrisponderà l'invocazione del metodo che rimanda al presenter relativo alla sezione.

\item{\method{+ hide(): void}}\\
Rende invisibile il pannello degli strumenti. Va impostata la proprietà \textit{display} di tale elemento a false.

\item{\method{+ logout(): void}}\\
Effettua il \textit{logout} dell'utente dal sistema, per far ciò viene invocata la \inglese{servlet} relativa.

\end{description}

\classsection{AccountSettingsPanelPresenter}

\subsubsection*{Funzione}
Presenter incaricato di gestire il pannello delle impostazioni dell'utente.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
\item{\memberdata{-- servlets: String[]}}\\
Array che contiene le URL delle \inglese{servlet} relative a tale presenter
\end{description}

\subsubsection*{Metodi}
\begin{description}
\item{\method{+ createPanel(): DOM\_element}}\\
Inizializza il pannello costruendone i \textit{widget} grafici interni e lo restituisce in modo che possa essere inserito all'interno del pannello principale. Più dettagliatamente, verrà costruita una lista con \textit{list item} contenenti le informazioni dell'utente, ossia:
\begin{itemize}
\item nome;
\item cognome;
\item e-mail;
\item immagine profilo;
\item password;
\item domanda segreta;
\item risposta alla domanda segreta.
\end{itemize}
Infine, sarà presente un pulsante con \textit{id} uguale ``changeButton'' il quale all'evento ``onclick'' richiama il metodo \method{onChangeButtonPressed()}, descritto successivamente, che da la possibilità di modificare i dati.


\item{\method{- onChangeButtonPressed(): void}}\\
Gestisce la pressione del pulsante ``changeButton'' che trasforma la lista di elementi testuali in un \textit{form} da compilare per modificare i propri dati. Il \textit{form} è completo di un pulsante \textit{submit} che attiva ``onSubmitChange'', metodo descritto successivamente.\\
I campi modificabili, recuperati dall'oggetto presente in CommunicationCenter (\memberdata{my}) che rappresenta il profilo utente, sono:
\begin{itemize}
\item nome;
\item cognome;
\item e-mail;
\item immagine profilo;
\item password;
\item domanda segreta;
\item risposta alla domanda segreta.
\end{itemize}

\item{\method{- onSubmitChange(): void}}\\
Gestisce il cambiamento dei dati da parte dell'utente contattando, se necessario (controllo effettuato tramite chiamata al metodo \method{hasSometingChanged}), la \inglese{servlet} incaricata di aggiornare il contenuto del database sul server. Il metodo va a recuperare i valori tramite chiamate di metodo \method{document.getElementById(id)} e successivamente contatta la \inglese{servlet} tramite un XMLHttpRequest passando i dati prelevati dalla pagina. Se la \inglese{servlet} ritorna un errore viene gestito tramite la visualizzazione dell'errore all'utente, altrimenti viene richiamato il metodo \method{initialize()} per aggiornare la visualizzazione dei dati più recenti.

\item{\method{- hasSomethingChanged(data: String[]): boolean}}\\
Metodo che verifica l'effettivo cambiamento di dati rispetto a quanto contenuto in\\ \memberdata{communicationcenter.my} confrontandoli con l'oggetto \memberdata{data} ricevuto come parametro. Il metodo controlla che almeno il valore di un campo dati sia effettivamente cambiato e ritorna \textit{true} in tale caso. Nel caso opposto, ossia tutti i dati sono uguali ai precedenti, ritorna \textit{false}.

\item{\method{- buildQueryString(data: String[]): String}}\\
Costruisce la stringa corrispondente alla \textit{query} che deve essere spedita alla \inglese{servlet} per portare a termine la richiesta di cambiamento dei dati personali. Viene costruita partendo dai valori recuperati dall'oggetto \memberdata{data} passato come parametro e utilizzando la giusta sintassi MySQL.

\end{description}

\subsection{Package org.softwaresynthesis.mytalk.clientpresenter.kernel}\label{sec:kernel}
\classsection{CommunicationCenter}

\subsubsection*{Funzione}
Classe logica che gestisce tutta la parte della comunicazione lato \textit{client}.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
\item{\memberdata{+ videoComunication: String[]}}\\
Array che contiene i dati della video-chiamata
\item{\memberdata{+ openChat: DOM\_element[]}}\\
Array che contiene i dati della video-chiamata
\item{\memberdata{- urlServlet: String}}\\
Contiene l'indirizzo della \inglese{servlet} che gestisce la comunicazione
\item{\memberdata{- my: String[]}}\\
Array contenente i dati personali dell'utente
\item{\memberdata{- websocket: Object()}}\\
Oggetto che rappresenta la \textit{websocket} da utilizzare per comunicare con il server. Il costruttore di tale oggetto richiede l'URL della \inglese{servlet}.

\end{description}

\subsubsection*{Metodi}
\begin{description}
\item{\method{- formatBytes(bytes: int): String}}\\
Metodo che formatta i byte ricevuti ed inviati al fine di fornire una visualizzazione sensata delle statistiche.\\
Il metodo riceve un numero rappresentante i \textit{bytes} (\memberdata{bytes} e li converte in KB/s o MB/s a seconda della grandezza.

\item{\method{- formatTime(tempo: int): String}}\\
Metodo che ritorna nel formato ``hh:mm:ss'' il tempo della comunicazione.\\
Il metodo riceve un numero rappresentante il tempo espresso in secondi (\memberdata{tempo}, lo converte nel formalismo descritto prima e lo restituisce.

\item{\method{- stopTimer(): void}}\\
Metodo che ferma l'aggiornamento del timer, viene richiamato quando la chiamata termina.

\item{\method{- stopStats(): void}}\\
Metodo che ferma l'aggiornamento delle statistiche relative alla chiamata in corso, viene richiamato quando la chiamata termina.

\item{\method{- dumpStats(obj: Object()): void}}\\
 Metodo che permette l'estrazione dei dati rappresentanti le statistiche della chiamata, esso riceve come parametro un oggetto (\memberdata{obj}), lo elabora, ed estrae solo i byte ricevuti e inviati. Ricavati questi dati, li visualizza nello \textit{span} corrispondente.
 
\item{\method{- gotDescription(): void}}\\
Metodo utilizzato da WebRTC che imposta la propria descrizione e la invia al \textit{client} chiamato in modo tale da poter instaurare la comunicazione. Verrà quindi prima di tutto utilizzata la funzione proprietaria di WebRTC \method{setLocalDescription} per impostare la propria descrizione e successivamente, mediante la \textit{websocket}, inviata al client \underline{peer} chiamato.
 
\item{\method{+ connect(): void}}\\
Metodo utilizzato per la creazione della connessione con il \textit{server}. Viene inizializzata la variabile \memberdata{websocket} richiamando il costruttore con un parametro (URL della servlet). Successivamente viene specificato il comportamento della \textit{websocket} per determinati eventi quali:
\begin{itemize}
\item \textbf{onopen}: istruzioni da eseguire quando la \textit{websocket} viene aperta. In questo caso, deve essere inviato alla \textit{websocket} il proprio \textit{id} utente in modo tale da identificare univocamente il canale aperto con il server.
\item \textbf{onclose}: istruzioni da eseguire quando la \textit{websocket} viene chiusa per qualsiasi motivo, notificando il server di tale avvenimento.
\item \textbf{onerror}: istruzioni da eseguire quando avviene un errore con la \textit{websocket}. Tale evento verrà notificato all'utente con un messaggio d'errore che descrive l'errore e l'atteggiamento da seguire.
\item \textbf{onmessage}: metodo più corposo in quanto gestisce l'unico evento richiamato mentre avviene una comunicazione dal server verso il \textit{client}. Per diversificare i messaggi ricevuti, si è deciso di rappresentare il messaggio come un \textit{array} nel quale il primo elemento identifica il tipo di richiesta. In questo modo, avremo tre tipi:
\begin{itemize}
\item type 2: riceve e gestisce una richiesta di chiamata. Imposta quindi con il metodo nativo di WebRTC \method{setRemoteDescription} la descrizione del \underline{peer} chiamante (secondo elemento dell'\textit{array} ricevuto) e la comunicazione può iniziare.
\item type 3: riceve una richiesta con l'\textit{id} del chiamante come dato. Viene memorizzato nel \textit{client} in modo tale da conoscere il canale che il chiamante ha aperto con il server per future comunicazioni.
\item type 5: notifica il cambiamento di stato degli amici. I dati ricevuti contengono l'\textit{id} dell'utente e relativo nuovo stato, si procede quindi a modificare lo stato dell'utente nella rubrica.
\end{itemize}
\end{itemize}
 
\item{\method{+ disconnect(): void}}\\
Metodo utilizzato per disconnettersi dal sistema, tale evento deve essere notificato al \textit{server} tramite la \textit{websocket} inviando un messaggio di tipo 4 contenente il proprio \textit{id}.

\item{\method{+ call(isCaller: boolean, contact: Object(contact)): void}}\\
Metodo che gestisce la vera e propria chiamata tramite WebRTC.\\
Inizialmente, si inizializza la variabile \memberdata{pc} che è di tipo RTCPeerConnection, oggetto reso disponibile dalle librerie di WebRTC, successivamente si definiscono i comportamenti associati agli eventi di RTCPeerConnection, ossia:
\begin{itemize}
\item onicecandidate: evento scatenato quando un nuovo \underline{peer} si ``candida'' per poter chiamare, viene quindi inviata la propria ``descrizione'' all'altro \underline{peer}.
\item onaddstream: evento scatenato quando viene aggiunto uno \textit{stream} nell'oggetto RTCPeerConnection. In questa situazione, il chiamato riceve lo \textit{stream} del chiamante e lo visualizza nell'apposito tag video. In contemporanea, vengono richiamati i metodi che fanno partire la visualizzazione delle statistiche di chiamata.
\item onremovestream: evento scatenato quando viene rimosso uno \textit{stream} nell'oggetto RTCPeerConnection. In questa situazione, colui che effettua questa operazione vuole terminare la chiamata e deve quindi re-inviare la propria descrizione (attraverso il metodo \method{gotDescription()} in modo tale che l'altro \underline{peer} possa aggiornare la descrizione remota. Vengono richiamati alla fine i metodi che fermano la visualizzazione delle statistiche di chiamata e chiudono il canale di comunicazione tramite la chiamata del metodo \method{close()} dell'oggetto \memberdata{pc}.
\end{itemize}

\item{\method{+ webkitGetUserMedia(audio: boolean, video: boolean): void}}\\
Metodo richiamato nel momento in cui un utente vuole iniziare una chiamata. Il metodo, fornito dalle librerie native di \textit{Google Chrome}, cattura lo \textit{stream} della propria videocamera/microfono. Riceve due parametri che indicano se deve essere catturato audio e/o video. Procedendo, viene aggiunto lo \textit{stream} all'oggetto RTCPeerConnection tramite il metodo \method{addStream(localstream)} fornito dalle librerie di WebRTC.

\item{\method{+ endCall(): void}}\\
Metodo richiamato per terminare una chiamata, a cascata viene richiamato il metodo \method{removeStream(localstream)} e inviata la nuova descrizione al \underline{peer} remoto.
 
 \end{description}

\clearpage

\section{Specifica sotto-architettura clientview}\label{sec:clientviewarchitecture}
Il sistema dispone di dodici viste, ognuna associata ad ogni presenter. Tali viste si modificano all'occorrenza dopo una chiamata del presenter relativo.

\subsection{AccountSettingsView}
\subsubsection*{Funzione}
Vista associata al presenter \classname{AccountSettingsPresenter}.
\subsubsection*{Elementi}
\begin{itemize}
\item \textit{div} contenente i dati personali;
\item \textit{ul} contenente 3 \textit{li} per:
\begin{itemize}
\item nome;
\item cognome;
\item immagine profilo.
\end{itemize}
\item \textit{button} che rimanda alla modifica dei dati personali.
\end{itemize}

\subsection{AddressBookView}
\subsubsection*{Funzione}
Vista associata al presenter \classname{AddressBookPresenter}. Utilizzata per la visualizzazione della rubrica personale.
\subsubsection*{Elementi}
\begin{itemize}
\item \textit{div} contenente un elemento di tipo \textit{text} e un \textit{button} per una ricerca veloce nella propria rubrica;
\item \textit{div} contenente un \textit{ul} dove verranno visualizzati tutti i contatti della rubrica;
\item \textit{div} contenente una \textit{select} utilizzata per ordinare la rubrica in base ai parametri dati;
\item \textit{div} contenente una \textit{select} dove sono elencati i gruppi della propria rubrica.
\end{itemize}

\subsection{CallHistoryView}
\subsubsection*{Funzione}
Vista associata al presenter \classname{CallHistoryPresenter}. Utilizzata per la visualizzazione dello storico chiamate.
\subsubsection*{Elementi}
\begin{itemize}
\item \textit{div} contenente un \textit{ul} dove verrà visualizzato lo storico chiamate.
\end{itemize}

\subsection{CommunicationView}
\subsubsection*{Funzione}
Vista associata al presenter \classname{CommunicationPresenter}. Utilizzata inizialmente durante una chiamata.
\subsubsection*{Elementi}
\begin{itemize}
\item \textit{div} contenente un elemento di tipo \textit{text} e un \textit{button} per una ricerca veloce nella propria rubrica;
\item \textit{div} contenente due elementi \textit{video} rispettivamente utilizzati per visualizzare lo stream della propria fotocamera e dell'altro client;
\item \textit{div} contenente 3 \textit{span} utilizzati per visualizzare le statistiche, ossia i dati inviati, i dati ricevuto e il tempo di comunicazione;
\item \textit{button} per terminare la chiamata.
\end{itemize}

\subsection{ContactView}
\subsubsection*{Funzione}
Vista associata al presenter \classname{ContactPresenter}. Utilizzate per visualizzare il profilo di un utente.
\subsubsection*{Elementi}
\begin{itemize}
\item \textit{div} contenente un elemento di tipo \textit{ul} con 4 \textit{li}:
\begin{itemize}
\item nome;
\item cognome;
\item email;
\item gruppi a cui appartiene se il contatto è presente nella mia rubrica.
\end{itemize}
\item \textit{button} per avviare una chiamata audio;
\item \textit{button} per avviare una video chiamata;
\item \textit{button} per avviare una chat;
\item \textit{button} per lasciare un messaggio in segreteria;
\item \textit{button} per aggiungere il contatto nella propria rubrica se non presente;
\item \textit{button} per rimuovere il contatto dalla propria rubrica se presente;
\item \textit{button} per bloccare il contatto se presente nella propria rubrica e non bloccato;
\item \textit{button} per sbloccare il contatto se presente nella propria rubrica e bloccato.
\end{itemize}

\subsection{GroupView}
\subsubsection*{Funzione}
Vista associata al presenter \classname{GroupPresenter}. Utilizzata per la visualizzazione dei gruppi della propria rubrica.
\subsubsection*{Elementi}
\begin{itemize}
\item \textit{div} contenente un \textit{ul} dove verranno inseriti tanti \textit{li} quanti i gruppi presenti nella proria rubrica.
\end{itemize}

\subsection{LoginView}
\subsubsection*{Funzione}
Vista associata al presenter \classname{LoginPresenter}. Utilizzata per effettuare il login nel sistema.
\subsubsection*{Elementi}
\begin{itemize}
\item \textit{div} contenente un elemento di tipo \textit{ul} con 2 \textit{li} utilizzati per inserire:
\begin{itemize}
\item username;
\item password.
\end{itemize}
\item \textit{button} per effettuare il login;
\item \textit{button} per effettuare la registrazione al sistema;
\item \textit{button} per recuperare i dati dimenticati.
\end{itemize}

\subsection{MessageView}
\subsubsection*{Funzione}
Vista associata al presenter \classname{MessagePresenter}. Utilizzata per visualizzare i messaggi presenti nella propria segreteria.
\subsubsection*{Elementi}
\begin{itemize}
\item \textit{div} contenente un elemento di tipo \textit{video} per la visualizzazione del messaggio;
\item \textit{div} contenente un elemento \textit{ul} che avrà tanti \textit{li} quanti sono i messaggi presenti in segreteria.
\end{itemize}

\subsection{PhoneCallsRegistryView}
\subsubsection*{Funzione}
Vista associata al presenter \classname{PhoneCallsRegistryPresenter}. Utilizzata per lasciare un messaggio in segreteria ad un utente non in linea.
\subsubsection*{Elementi}
\begin{itemize}
\item \textit{button} per iniziare la registrazione del messaggio;
\item \textit{button} per terminare la registrazione;
\item \textit{button} per inviare la registrazione appena effettuata.
\end{itemize}

\subsection{RegisterView}
\subsubsection*{Funzione}
Vista associata al presenter \classname{RegisterPresenter}. Utilizzata per effettuare la registrazione al sistema.
\subsubsection*{Elementi}
\begin{itemize}
\item elemento di tipo \textit{ul} con 7 \textit{li} per:
\begin{itemize}
\item nome;
\item cognome;
\item email;
\item password;
\item domanda segreta;
\item risposta alla domanda segreta;
\item immagine del profilo.
\end{itemize}
\item \textit{button} per tornare indietro;
\item \textit{button} per registrarsi con i dati inseriti.
\end{itemize}

\subsection{SearchResultView}
\subsubsection*{Funzione}
Vista associata al presenter \classname{SearchResultPresenter}. Utilizzata per visualizzare i risultati di una ricerca.
\subsubsection*{Elementi}
\begin{itemize}
\item \textit{div} contenente un elemento di tipo \textit{ul} con tanti \textit{li} quanti i risultati ritornati dalla ricerca.
\end{itemize}

\subsection{ToolsView}
\subsubsection*{Funzione}
Vista associata al presenter \classname{ToolsPresenter}. Utilizzata per visualizzare gli strumenti disponibili all'utente.
\subsubsection*{Elementi}
\begin{itemize}
\item \textit{select} dove poter scegliere il proprio stato (disponibile, occupato);
\item elemento di tipo \textit{ul} con 6 \textit{li} per:
\begin{itemize}
\item accedere alla segreteria;
\item accedere alle impostazioni;
\item accedere allo storico chiamate;
\item accedere alla sezione dei gruppi;
\item accedere alla sezione dove effettuare una ricerca;
\item effettuare il logout.
\end{itemize}
\end{itemize}



\clearpage

\section{Tracciamenti}

Al fine di rendere evidente l'associazione di necessità e sufficienza che intercorre tra i requisiti (emersi in attività di analisi) e le classi predisposte per soddisfarli, riportiamo di seguito due tabulati di tracciamento. Il primo, requisiti-classi, mostra il soddisfacimento di ogni requisito identificato. Il secondo, classi-requisiti, evidenzia l'utilità delle classi e dimostra che ogni una di esse è stata creata con uno scopo ben preciso.

\subsection{Requisiti - classi}

\subsection{Classi - requisiti}

\end{document}