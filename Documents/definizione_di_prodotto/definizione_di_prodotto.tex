% ATTENZIONE!!! 
% Per far funzionare i collegamenti ipertestuali si raccomanda di usare
%	\classname{nomedellaclasse}
% per le classi dello stesso package mentre invece 
%	\hyperref[nomedellaclasse]{\ttfamily{}nomequalificatodellaclasse}
% per le classi che non sono dello stesso package e che hanno il nome completo

% **************************************************
% Macro specifiche per il documento corrente
% **************************************************
% Nome
\newcommand{\docName}{Definizione di prodotto}
% Nome file
\newcommand{\docFileName}{definizione\_di\_prodotto.1.0.pdf}
% Versione
\newcommand{\docVers}{1.0}
% Data creazione
\newcommand{\creationDate}{2013-03-04}
% Data ultima modifica
\newcommand{\modificationDate}{2013-03-19}
% Stato in {Approvato, Non approvato}
\newcommand{\docState}{Approvato}
% Uso in {Interno, Esterno}
\newcommand{\docUsage}{Esterno}
% Destinatari da specificare come nome1\\ &nome2\\ ecc.
\newcommand{\docDistributionList}{Prof. Tullio Vardanega\\&Prof. Riccardo Cardin\\&Dott. Gregorio Piccoli\\&Team SoftwareSynthesis}
% Redattori da specificare come nome1\\ &nome2\\ ecc.
\newcommand{\docAuthors}{Andrea Rizzi\\&Elena Zecchinato\\&Marco Schivo \\&Stefano Farronato}
% Approvato da
\newcommand{\approvedBy}{Diego Beraldin}
% Verificatori
\newcommand{\verifiedBy}{Andrea Meneghinello}
% Perscorso (relativo o assoluto) che punta alla directory contenente shared/
% come sua sottodirectory (per comodità chiamiamola 'doc root').
\newcommand{\docRoot}{..}
% definire se si vuole l'indice delle tabelle
\def\INDICETABELLE{false}
% definire se si vuole l'indice delle figure
\def\INDICEFIGURE{false}

% importa il preambolo condiviso da tutti i documenti
\input{\docRoot/shared/preamble.tex}

% macro specifiche per il documento corrente
\newcommand{\classsection}[1]{\subsubsection{#1}\label{#1}}
\newcommand{\classname}[1]{\hyperref[#1]{\ttfamily#1}}

% Fine del preambolo e inizio del documento
\begin{document}

% Inclusione della prima pagina
\input{\docRoot/shared/firstpage.tex}

%---------------------------RUOLI----------------------------
%FASE 1:
%Progettisti: STEFANO,RIZZI,SCHIVO,ELENA

%VerificatorI: MENE,TRES
%Responsabile finale supremo: DIEGO
%------------------------------------------------------------

% Storico delle modifiche
\section*{Storia delle modifiche}
\begin{center}
\begin{longtable}{lp{.32\textwidth}lll}
\toprule
Versione & Descrizione intervento & Membro & Ruolo & Data\\
\midrule % inserire qui il contenuto della tabella
1.0 & Approvazione documento &Diego Beraldin &Responsabile  & 2013-03-09\\
0.10 & Correzioni errori rilevati da verificatori &Schivo Marco  &  Progettista& 2013-03-08\\
0.9 & Verifica totale documento &Andrea Meneghinello & Verificatore & 2013-03-08\\
0.8 & Descritto classi di abook.authentication, server.authentication.servlet, server.connection & Elena Zecchinato &  Progettista& 2013-03-07\\
0.7 & Descritto PresenterMediator, CallHistoryPanelPresenter, SearchResultPanelPresenter, ToolsPanelPresenter, AccountSettingsPanelPresenter &Schivo Marco &  Progettista& 2013-03-07\\
0.7 & Descritto AddressBookPanelPresenter, GroupPanelPresenter, LoginPanelPresenter &Schivo Marco &  Progettista& 2013-03-06\\
0.6 & Descritto classi di server.abook.servlet, server.call, server.message &Elena Zecchinato &  Progettista& 2013-03-06\\
0.5 & Descritto RegisterPanelPresenter, CommunicationPanelPresenter, ContactPanelPresenter, MainPanelPresenter &Stefano Farronato &  Progettista& 2013-03-05\\
0.4 & Descritte classi package server.dao e server.abook &Andrea Rizzi &  Progettista& 2013-03-05\\
0.3 & Inizio descrizione parte clientpresenter &Stefano Farronato &  Progettista& 2013-03-04\\
0.2 & Stesura sezione ``Standard di progetto'' ed inizio descrizione server &Andrea Rizzi &  Progettista& 2013-03-04\\
0.1 & Creazione del documento e stesura delle sezioni ``Introduzione'' e ``Riferimenti'' &Elena Zecchinato &Progettista  & 2013-03-04\\
\bottomrule
\end{longtable}
\end{center}
\newpage

% inclusione dell'indice
\input{\docRoot/shared/toc.tex}

% Alcuni aggiustamenti per le pagine
\pagenumbering{arabic}
\setcounter{page}{1}
\pagestyle{normal}

% Qui ha inizio il documento vero e proprio...
\newpage

\section{Introduzione}
\subsection{Scopo del prodotto}
\purpose

\subsection{Scopo del documento}
Il presente documento presenta una descrizione dettagliata dell'architettura del sistema software destinata alla realizzazione del prodotto \caName{} coerentemente con la progettazione ad alto livello descritta nell'allegato \textit{specifica\_tecnica.2.0.pdf}.

A tal fine si riporta per ognuno dei componenti definiti nel documento di specifica tecnica una descrizione delle classi in termini di operazioni disponibili, proprietà, responsabilità e collaborazioni. Il contenuto del presente documento ha inoltre valore vincolante per i programmatori, pertanto avranno l'obbligo di attenersi alle disposizioni in esso contenute senza alcuna possibilità di deroga.

\subsection{Glossario}
\glossaryIntro

\subsection{Convenzioni di scrittura}
% vedere issue #56 al riguardo
Al fine di rendere quanto più agevole possibile la consultazione del documento da parte dei programmatori e del committente, è stata adottata una serie di accorgimenti sia a livello di riferimenti sulla nomenclatura delle classi sia a livello cromatico per campi dati e metodi. 
Tali norme possono essere consultate in dettaglio nel documento \textit{norme\_di\_progetto.3.0.pdf} allegato.
\clearpage

\section{Riferimenti}
\subsection{Normativi}
\begin{itemize}
\item[] \textit{piano\_di\_qualifica.3.0.pdf} allegato.
\item[] \textit{norme\_di\_progetto.3.0.pdf} allegato.
\item[] \textit{specifica\_tecnica.2.0.pdf} allegato
\end{itemize}

\subsection{Informativi}
\begin{itemize}
\item[] Capitolato d'appalto: \caName{}, v1.0, redatto e rilasciato dal proponente Zucchetti s.r.l. reperibile all'indirizzo \url{http://www.math.unipd.it/~tullio/IS-1/2012/Progetto/C1.pdf};
\item[] testo di consultazione: \textit{Software Engineering (8th edition) Ian Sommerville, Pearson Education | Addison Wesley};
\item[] manuale all'utilizzo dei design pattens: \textit{Design Patterns, Elementi per il riuso di software a oggetti -- (1/Ed. italiana) Eric Gamma, Richard Helm, Ralph Johnson, John Vlissides, Pearson Education};
\item[] \textit{glossario.3.0.pdf} allegato.
\end{itemize}
\clearpage

\section{Standard di progetto}

\subsection{Standard di progettazione architetturale}
Lo sviluppo del progetto ha seguito le regole architetturali specificate nel documento  \textit{norme\_di\_progetto.3.0.pdf} allegato.

\subsection{Standard di documentazione del codice}
Le regole che definiscono la documentazione del codice relativo al funzionamento del prodotto sono specificate nel documento \textit{norme\_di\_progetto.3.0.pdf} allegato.

\subsection{Standard di denominazione di entità e relazioni}
Le convenzioni relative alla denominazione delle entità e le relative relazioni sono specificate nel documento \textit{norme\_di\_progetto.3.0.pdf} allegato.

\subsection{Standard di programmazione}
Le regole relative agli standard di programmazione sono enunciate nel documento \textit{norme\_di\_progetto.3.0.pdf} allegato.

\subsection{Strumenti di lavoro}
Gli strumenti utilizzati per la stesura e lo sviluppo sono specificati nei documenti \textit{norme\_di\_progetto.3.0.pdf} e \textit{piano\_di\_qualifica.3.0.pdf} allegati.

\clearpage

\section{Specifica sotto-architettura sever}\label{sec:serverarchitecture}

\subsection{Package org.softwaresynthesis.mytalk.server.dao}\label{sec:dao}

\classsection{HibernateUtil}

\subsubsection*{Funzione}
Inizializza un'unica \inglese{factory} per le sessioni, utilizzate da \textit{Hibernate}, per comunicare con il database.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \classname{org.hibernate.SessionFactory}: necessaria per interrogare il database.
	\item \classname{org.hibernate.cfg.Configuration}: definisce i parametri necessari per la connessione con il database. Inoltre definisce i \textit{mapping} necessari tra le classi \inglese{transfer object} e le relative tabelle nel database.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.


\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{\underline{-- instance: HibernateUtil}}}\\
	Attributo usato per implementare il \inglese{pattern} singleton. Tale istanza verrà inizializzata tramite il metodo statico \method{getIstance()}, assicurando che l'attributo non sia già stato inizializzato in precedenza.
	\item{\memberdata{-- sessionFactory: SessionFactory}}\\
	Attributo contenente la \inglese{factory} delle sessioni verso il database.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{-- HibernateUtil()}}\\
	Costruttore privato della classe, definito \inglese{private} in correlazione all'applicazione del \inglese{pattern} singleton.
	\item{\method{\underline{+ getInstance(): HibernateUtil}}}\\
	Metodo pubblico che ritorna l'istanza \memberdata{istance}. Il metodo controlla se \memberdata{istance} è già stata inizializzata, nel caso in cui non lo sia il metodo dovrà generare un istanza di HibernateUtil richiamando il costruttore privato \method{HibernateUtil()} e assegnare il valore ritornato all'attributo \memberdata{istance}. Il programma termina restituendo \memberdata{istance}.
	\item{\method{\underline{+ getSessionFactory(): SessionFactory}}}\\
	Metodo che ritorna l'attributo \memberdata{sessionFactory}.
\end{description}

\classsection{UserDataDAO}

\subsubsection*{Funzione}
Classe che implementa il pattern DAO. Definisce le procedure d'inserimento, eliminazione ed aggiornamento di \inglese{entry} inerenti alla tabella UserData. La classe inoltre fornisce metodi per interrogare il database ed ottenere i dati utente con i quali costruire istanze di oggetti di tipo \classname{abook.IUserData}.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.util.List}: usata per memorizzare e ritornare i dati restituiti dalle interrogazioni a database.
	\item \classname{org.hibernate.Query}: classe rappresentante le \textit{query} d'interrogazione verso il database
	\item \texttt{org.hibernate.Session}: classe che rappresenta la sessione di ``lavoro'' verso il database.
	\item \texttt{org.hibernate.SessionFactory}: classe avente compito di instanziare nuove sessioni.
	\item \texttt{org.hibernate.Transaction}: classe che rappresenta una transazione del database.
	
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \classname{abook.IUserData}: interfaccia d'implementazione del package \textit{abook} usata per definire un generico utente. La classe può ritornare istanze di tipo \classname{abook.IUserData} come risposta a delle \textit{query} d'interrogazione al database.
\end{itemize}

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{-- util: HibernateUtil}}\\
	Attributo usato per mantenere un riferimento alla singola istanza di HibernateUtil.
	\item{\memberdata{-- factory: SessionFactory}}\\
	Attributo usato per mantenere un riferimento ad un'istanza di SessionFactory.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}

	\item{\method{+ insert(user: IUserData): boolean}}\\
	Metodo usato per inserire un utente registrato nel sistema, riceve come parametro un istanza di un oggetto \classname{abook.IUserData}. Il metodo dovrà eseguire nell'ordine le seguenti operazioni:
		\begin{itemize}
			\item[1)] ottenere dalla classe \classname{HibernateUtil} l'istanza tramite il metodo statico \method{getIstance()};
			\item[2)] ottenere dall'istanza di tipo \classname{HibernateUtil} (ottenuta al punto precedente), un oggetto di tipo \texttt{org.hibernate.SessionFactory}, tramite il metodo \method{getSessionFactory()};
			\item[3)] aprire la sessione ottenuta al punto precedente;
			\item[4)] avviare una transizione a partire dall'istanza \texttt{org.hibernate.SessionFactory} del punto 2. Tale istanza va memorizzata in un opportuno attributo (interno al metodo stesso) di tipo \texttt{org.hibernate.Transaction};
			\item[5)] eseguire il comando \inglese{save} a partire dalla sessione aperta e passando come parametro l'attributo \memberdata{user}.
			\item[6)] eseguire il comando \inglese{commit} per confermare l'operazione del punto precedente;
			\item[7)] impostare un determinato flag booleano (denominato \texttt{flag}) a \inglese{true}.
		\end{itemize}
		
Poiché l'iter presentato potrà sollevare un'eccezione, il codice dovrà essere gestito in un blocco \inglese{try-catch}. Nel caso incorra tale evento, il flusso di processo dovrà ristabilire la situazione iniziale richiamando il metodo \texttt{rollback()} dell'istanza di tipo \texttt{org.hibernate.Transaction} creata al punto 4 dell'iter. Inoltre dovrà impostare \texttt{flag} a \inglese{false}. In ogni caso il metodo deve terminare chiudendo la sessione aperta al punto 2 e ritornando il valore di \texttt{flag}.

	\item{\method{+ delete(user: IUserData): boolean}}\\
	Metodo usato per eliminare un utente registrato nel sistema, riceve come parametro un istanza di un oggetto \classname{abook.IUserData}. Il metodo dovrà eseguire nell'ordine le seguenti operazioni:
		\begin{itemize}
			\item[1)] ottenere dalla classe \classname{HibernateUtil} l'istanza tramite il metodo statico \method{getIstance()};
			\item[2)] ottenere dall'istanza di tipo \classname{HibernateUtil}(ottenuta al punto precedente), un oggetto di tipo \texttt{org.hibernate.SessionFactory}, tramite il metodo \method{getSessionFactory()};
			\item[3)] aprire la sessione ottenuta al punto precedente;
			\item[4)] avviare una transizione a partire dall'istanza \texttt{org.hibernate.SessionFactory} del punto 2. Tale istanza va memorizzato in un opportuno attributo (interno al metodo stesso) di tipo \texttt{org.hibernate.Transaction};
			\item[5)] eseguire il comando \inglese{delete} a partire dalla sessione aperta e passando come parametro l'attributo \memberdata{user}.
			\item[6)] eseguire il comando \inglese{commit} per confermare l'operazione del punto precedente;
			\item[7)] impostare un determinato flag booleano (denominato \texttt{flag}) a \inglese{true}.
		\end{itemize}
		
Poiché l'iter presentato potrà sollevare un'eccezione, il codice dovrà essere gestito in un blocco \inglese{try-catch}. Nel caso incorra tale evento, il flusso di processo dovrà ristabilire la situazione iniziale richiamando il metodo \texttt{rollback()} dell'istanza di tipo \texttt{org.hibernate.Transaction} creata al punto 4 dell'iter. Inoltre dovrà impostare \texttt{flag} a \inglese{false}. In ogni caso il metodo deve terminare chiudendo la sessione aperta al punto 2 e ritornando il valore di \texttt{flag}.

\item{\method{+ update(user: IUserData): boolean}}\\
	Metodo usato per modificare i dati di un utente registrato nel sistema, riceve come parametro un istanza di un oggetto \classname{abook.IUserData}. Il metodo dovrà eseguire nell'ordine le seguenti operazioni:
		\begin{itemize}
			\item[1)] ottenere dalla classe \classname{HibernateUtil} l'istanza tramite il metodo statico \method{getIstance()};
			\item[2)] ottenere dall'istanza di tipo \classname{HibernateUtil}(ottenuta al punto precedente), un oggetto di tipo \texttt{org.hibernate.SessionFactory}, tramite il metodo \method{getSessionFactory()};
			\item[3)] aprire la sessione ottenuta al punto precedente;
			\item[4)] avviare una transizione a partire dall'istanza \texttt{org.hibernate.SessionFactory} del punto 2. Tale istanza va memorizzato in un opportuno attributo (interno al metodo stesso) di tipo \texttt{org.hibernate.Transaction};
			\item[5)] eseguire il comando \inglese{update} a partire dalla sessione aperta e passando come parametro l'attributo \memberdata{user}.
			\item[6)] eseguire il comando \inglese{commit} per confermare l'operazione del punto precedente;
			\item[7)] impostare un determinato flag booleano (denominato \texttt{flag}) a \inglese{true}.
		\end{itemize}
		
Poiché l'iter presentato potrà sollevare un'eccezione, il codice dovrà essere gestito in un blocco \inglese{try-catch}. Nel caso incorra tale evento, il flusso di processo dovrà ristabilire la situazione iniziale richiamando il metodo \texttt{rollback()} dell'istanza di tipo \texttt{org.hibernate.Transaction} creata al punto 4 dell'iter. Inoltre dovrà impostare \texttt{flag} a \inglese{false}. In ogni caso il metodo deve terminare chiudendo la sessione aperta al punto 2 e ritornando il valore di \texttt{flag}.

	\item{\method{+ getByNameAndSurname(name: String, surname: String): List<IUserData>}}\\
	Metodo usato per effettuare un interrogazione al database atta ad ottenere la lista degli utenti aventi un determinato nome e cognome, riceve come parametri il nome e il cognome da ricercare. Il metodo dovrà eseguire nell'ordine le seguenti operazioni:
		\begin{itemize}
			\item[1)] ottenere dalla classe \classname{HibernateUtil} l'istanza tramite il metodo statico \method{getIstance()};
			\item[2)] ottenere dall'istanza di tipo \classname{HibernateUtil}(ottenuta al punto precedente), un oggetto di tipo \texttt{org.hibernate.SessionFactory}, tramite il metodo \method{getSessionFactory()};
			\item[3)] aprire la sessione ottenuta al punto precedente;
			\item[4)] eseguire il comando \inglese{createQuery()} a partire dall'istanza che definisce la sessione, passando come parametro una stringa rappresentante la \inglese{query} d'interrogazione al database (la \inglese{query} deve restituire dati validi ad essere passati a tale metodo). Una prima analisi evidenzia che la \inglese{query} corretta è: 
\begin{verbatim}
from UserData as u where u.name = :name or u.surname = :surname
\end{verbatim}
			\item[5)] eseguire una serie di comandi di tipo \texttt{setString} per ogni elemento della \inglese{query} d'interrogazione (dove per elemento si intende ogni valore di filtraggio presente nelle clausole \inglese{where} delle \inglese{query} HQL, segnato come \texttt{:nome\_variabile}).
			\item[6)] eseguire il comando \inglese{commit} per l'interrogare il database ed ottenere la lista di valori da ritornare.
		\end{itemize}
		
Il metodo deve terminare chiudendo la sessione aperta al punto 2.
	
	\item{\method{+ getByEmail(mail: String): IUserData}}\\
	Metodo usato per eseguire un interrogazione al database atta ad ottenere l'utente avente un determinato indirizzo e-mail, esso riceve come parametro l'indirizzo e-mail da ricercare. Il metodo dovrà eseguire nell'ordine le seguenti operazioni:
		\begin{itemize}
			\item[1)] ottenere dalla classe \classname{HibernateUtil} l'istanza tramite il metodo statico \method{getIstance()};
			\item[2)] ottenere dall'istanza di tipo \classname{HibernateUtil}(ottenuta al punto precedente), un oggetto di tipo \texttt{org.hibernate.SessionFactory}, tramite il metodo \method{getSessionFactory()};
			\item[3)] aprire la sessione ottenuta al punto precedente;
			\item[4)] eseguire il comando \inglese{createQuery()} a partire dall'istanza che definisce la sessione, passando come parametro una stringa rappresentante la \inglese{query} d'interrogazione al database (la \inglese{query} deve restituire dati validi ad essere passati a tale metodo). Una prima analisi evidenzia che la \inglese{query} corretta è: 
\begin{verbatim}
from UserData as u where u.mail = :mail
\end{verbatim}
			\item[5)] eseguire una serie di comandi di tipo \texttt{setString} per ogni elemento della \inglese{query} d'interrogazione (per elemento si intende ogni valore di filtraggio presente nelle clausole \inglese{where} delle \inglese{query} HQL, segnato come \texttt{:nome\_variabile}).
			\item[6)] eseguire il comando \inglese{commit} per eseguire l'interrogazione a database ed ottenere la lista di valori da ritornare.
		\end{itemize}
		
Il metodo deve terminare chiudendo la sessione aperta al punto 2.	
	
	
	\item{\method{+ searchGeneric(value: String): List<IUserData>}}\\
		Metodo usato per eseguire un interrogazione generica al database atta ad ottenere una lista di utenti aventi: o un determinato indirizzo e-mail, o un determinato nome o un determinato cognome; riceve come parametro la stringa da ricercare e dovrà eseguire nell'ordine le seguenti operazioni:
		\begin{itemize}
			\item[1)] ottenere dalla classe \classname{HibernateUtil} l'istanza tramite il metodo statico \method{getIstance()};
			\item[2)] ottenere dall'istanza di tipo \classname{HibernateUtil}(ottenuta al punto precedente), un oggetto di tipo \texttt{org.hibernate.SessionFactory}, tramite il metodo \method{getSessionFactory()};
			\item[3)] aprire la sessione ottenuta al punto precedente;
			\item[4)] eseguire il comando \inglese{createQuery()} a partire dall'istanza che definisce la sessione, passando come parametro una stringa rappresentante la \inglese{query} d'interrogazione al database (la \inglese{query} deve restituire dati validi ad essere passati a tale metodo). Una prima analisi evidenzia che la \inglese{query} corretta è: 
\begin{verbatim}
from UserData as u where u.mail like :mail or u.name like :name or
\end{verbatim}
\begin{verbatim}
u.surname like :surname
\end{verbatim}
			\item[5)] eseguire una serie di comandi di tipo \texttt{setString} per ogni elemento della \inglese{query} d'interrogazione (per elemento si intende ogni valore di filtraggio presente nelle clausole \inglese{where} delle \inglese{query} HQL, segnato come \texttt{:nome\_variabile}).
			\item[6)] eseguire il comando \inglese{commit} per eseguire l'interrogazione a database ed ottenere la lista di valori da ritornare.
		\end{itemize}
		
Il metodo deve terminare chiudendo la sessione aperta al punto 2.

\end{description}

%TODO da verificare

\classsection{GroupDAO}

\subsubsection*{Funzione}
Classe che implementa il pattern DAO. Definisce le procedure d’inserimento, eliminazione ed aggiornamento di entry inerenti alla tabella Group. La classe inoltre fornisce metodi per interrogare il database ed ottenere i dati utente con i quali costruire istanze di oggetti di tipo abook.IGroup.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.util.List}:
	\item \texttt{org.hibernate.Query}:
	\item \texttt{org.hibernate.Session}:
	\item \texttt{org.hibernate.SessionFactory}:
	\item \texttt{org.hibernate.Transaction}:
	\item \classname{abook.IGroup}:
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \classname{abook.IGroup}:
\end{itemize}

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{-- util: HibernateUtil}}\\
	Attributo usato per mantenere un riferimento alla singola istanza di HibernateUtil.
	\item{\memberdata{-- factory: SessionFactory}}\\
	Attributo usato per mantenere un riferimento ad un'istanza di SessionFactory.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ delete(group: IGroup): boolean}}\\
	Metodo usato per cancellare un gruppo dal database. Per gruppo si intende un qualsiasi oggetto implementante l'interfaccia \classname{abook.IGroup}. Il metodo riceve come parametro d'ingresso un oggetto \classname{abook.IGroup} e restituisce un valore booleano  pari a \inglese{true} se l'operazione è andata a buon fine, \inglese{false} altrimenti. Il flusso principale inizia definendo le seguenti variabili:
	\begin{itemize}
		\item viene inizializzata una variabile ti tipo boolean nominata flag, a \inglese{false};
		\item si crea un istanza di \texttt{Session} session;
		\item si crea un istanza di \texttt{Transaction} transaction;
	\end{itemize}
	Quindi nel metodo deve essere definito un blocco try catch finally:
	\begin{itemize}
		\item nel blocco try:
		\begin{itemize}
			\item util deve essere inizializzato mediante la chiamata \method{getIstance()} di \classname{HibernateUtil};
			\item quindi a partire da util si inizializza factory mediante una chiamata \method{getFactory()};
			\item analogamente a quanto fatto in precedenza, si inizializza session tramite una chiamata \method{openSession()} eseguita a partire da factory;
			\item transaction viene inizializzata con una chiamata a metodo \method{beginTransaction()} eseguita da session;
			\item quindi si è pronti per eseguire l'istruzione di delete a partire da session e passando come parametro group;
			\item si esegue il commit;
			\item si pone flag a \inglese{true};
		\end{itemize}
		\item nel blocco catch: si effettua un rollback a partire da transaction;
		\item nel blocco finally: se session è diverso da null, si chiude mediante una chimata di tipo close();
	\end{itemize}
	Infine il metodo termina ritornando il valore di flag;
	
	\item{\method{+ update(group: IGroup): boolean}}\\
	Metodo usato per modificare un gruppo dal database. Il metodo riceve come parametro d'ingresso un oggetto \classname{abook.IGroup} e restituisce un valore booleano  pari a \inglese{true} se l'operazione è andata a buon fine, \inglese{false} altrimenti. Il flusso principale inizia definendo le seguenti variabili:
	\begin{itemize}
		\item viene inizializzata una variabile ti tipo boolean nominata flag, a \inglese{false};
		\item si crea un istanza di \texttt{Session} session;
		\item si crea un istanza di \texttt{Transaction} transaction;
	\end{itemize}
	Quindi nel metodo deve essere definito un blocco try catch finally:
	\begin{itemize}
		\item nel blocco try:
		\begin{itemize}
			\item util deve essere inizializzato mediante la chiamata \method{getIstance()} di \classname{HibernateUtil};
			\item quindi a partire da \textit{util} si inizializza \textit{factory} mediante una chiamata \method{getFactory()};
			\item analogamente a quanto fatto in precedenza, si inizializza \textit{session} tramite una chiamata \method{openSession()} eseguita a partire da \textit{factory};
			\item transaction viene inizializzata con una chiamata a metodo \method{beginTransaction()} eseguita da session;
			\item quindi si è pronti per eseguire l'istruzione di \textit{update} a partire da \textit{session} e passando come parametro \textit{group};
			\item si esegue il \textit{commit};
			\item si pone \inglese{flag} a \inglese{true};
		\end{itemize}
		\item nel blocco catch: si effettua un \textit{rollback} a partire da \textit{transaction};
		\item nel blocco finally: se session è diverso da null, si chiude mediante una chiamata di tipo \texttt{close()};
	\end{itemize}
	Infine il metodo termina ritornando il valore di \inglese{flag};	
	
	\item{\method{+ insert(group: IGroup): boolean}}\\
	Metodo usato per inserire un gruppo nel database, riceve come parametro d'ingresso un oggetto \classname{abook.IGroup} e restituisce un valore booleano  pari a \inglese{true} se l'operazione è andata a buon fine, \inglese{false} altrimenti. Il flusso principale inizia definendo le seguenti variabili:
	\begin{itemize}
		\item viene inizializzata una variabile ti tipo \inglese{boolean} nominata \inglese{flag}, a \inglese{false};
		\item si crea un istanza di \texttt{Session} session;
		\item si crea un istanza di \texttt{Transaction} transaction;
	\end{itemize}
	Quindi nel metodo deve essere definito un blocco \textit{try-catch} finally:
	\begin{itemize}
		\item nel blocco try:
		\begin{itemize}
			\item util deve essere inizializzato mediante la chiamata \method{getIstance()} di \classname{HibernateUtil};
			\item quindi a partire da util si inizializza factory mediante una chiamata \method{getFactory()};
			\item analogamente a quanto fatto in precedenza, si inizializza \textit{session} tramite una chiamata \method{openSession()} eseguita a partire da \textit{factory};
			\item transaction viene inizializzata con una chiamata a metodo \method{beginTransaction()} eseguita da session;
			\item quindi si è pronti per eseguire l'istruzione di \textit{save} a partire da \textit{session} e passando come parametro group;
			\item si esegue il commit;
			\item si pone \textit{flag} a \inglese{true};
		\end{itemize}
		\item nel blocco catch: si effettua un \textit{rollback} a partire da \textit{transaction};
		\item nel blocco finally: se \textit{session} è diverso da \textit{null}, si chiude mediante una chiamata di tipo \texttt{close()};
	\end{itemize}
	Infine il metodo termina ritornando il valore di \textit{flag};
	
	\item{\method{+ getByID(identifier: long): IGroup}}\\
	Metodo usato per interrogare il database ed ottenere un istanza di \classname{IGroup} avente come identificativo, l'id del gruppo ricevuto come parametro d'ingresso. Il flusso principale inizia definendo le seguenti variabili:
	\begin{itemize}
		\item si crea un istanza di \texttt{List<IGroup>} groups;
		\item si crea un istanza di \texttt{Query} query;
		\item si crea una stringa hqlQuery impostata per default a:\\
			\verb|"from Group as g where g.id = :id"|
		\item si crea un istanza di \texttt{Session} session;
		\item si crea un istanza di \texttt{Transaction} transaction;
	\end{itemize}
	Quindi nel metodo deve essere definito un blocco try catch finally:
	\begin{itemize}
		\item nel blocco try:
		\begin{itemize}
			\item util deve essere inizializzato mediante la chiamata \method{getIstance()} di \classname{HibernateUtil};
			\item quindi a partire da \textit{util} si inizializza \textit{factory} mediante una chiamata \method{getFactory()};
			\item analogamente a quanto fatto in precedenza, si inizializza \textit{session} tramite una chiamata \method{openSession()} eseguita a partire da \textit{factory};
			\item transaction viene inizializzata con una chiamata a metodo \method{beginTransaction()} eseguita da session;
			\item query viene inizializzata mediante una chiamata \textit{createQuery}, chiamata da \textit{session} e a cui deve essere passata come parametro, la stringa hqlQuery;
			\item quindi si è pronti per eseguire query ed ottenere la lista di \classname{IGroup} desiderata. Tale operazione si effettua richiamando query.list();
			\item si esegue il \textit{commit};
		\end{itemize}
		\item nel blocco catch: si effettua un \textit{rollback} a partire da \textit{transaction};
		\item nel blocco finally: se \textit{session} è diverso da \textit{null}, si chiude mediante una chiamata di tipo \texttt{close()};
	\end{itemize}
	Il programma termina controllando se groups è diversa da \textit{null} e contiene almeno un elemento. Nel caso il programma termina ritornando il primo contatto presente nella lista. Altrimenti termina ritornando \textit{null}.
	
	\item{\method{+ getByOwner(owner: long): List<IGroup>}}\\
	Metodo usato per interrogare il database ed ottenere una lista di istanze di \classname{IGroup} aventi come possessore dei gruppi l'utente con id uguale al valore \textit{owner} passato come parametro. Il flusso principale inizia definendo le seguenti variabili:
	\begin{itemize}
		\item si crea un istanza di \texttt{List<IGroup>} groups;
		\item si crea un istanza di \texttt{Query} query;
		\item si crea una stringa hqlQuery impostata per default a:\\
			\verb|"from Group as g where g.owner = :owner"|
		\item si crea un istanza di \texttt{Session} session;
		\item si crea un istanza di \texttt{Transaction} transaction;
	\end{itemize}
	Quindi nel metodo deve essere definito un blocco \textit{try-catch} finally:
	\begin{itemize}
		\item nel blocco try:
		\begin{itemize}
			\item util deve essere inizializzato mediante la chiamata \method{getIstance()} di \classname{HibernateUtil};
			\item quindi a partire da \textit{util} si inizializza \textit{factory} mediante una chiamata \method{getFactory()};
			\item analogamente a quanto fatto in precedenza, si inizializza \textit{session} tramite una chiamata \method{openSession()} eseguita a partire da \textit{factory};
			\item transaction viene inizializzata con una chiamata a metodo \method{beginTransaction()} eseguita da session;
			\item query viene inizializzata mediante una chiamata createQuery, chiamata da \textit{session} e a cui deve essere passata come parametro, la stringa hqlQuery;
			\item quindi si è pronti per eseguire \textit{query} ed ottenere la lista di \classname{IGroup} desiderata. Tale operazione si effettua richiamando query.list();
			\item si esegue il commit;
		\end{itemize}
		\item nel blocco catch: si effettua un \textit{rollback} a partire da \textit{transaction};
		\item nel blocco finally: se \textit{session} è diverso da \textit{null}, si chiude mediante una chiamata di tipo \texttt{close()};
	\end{itemize}
	Il programma termina restituendo groups.
	
\end{description}

%TODO da verificare

\classsection{AddressBookEntryDAO}

\subsubsection*{Funzione}
Classe che implementa il pattern DAO. Definisce le procedure d'inserimento, eliminazione ed aggiornamento di entry inerenti alla tabella AddressBookEntry.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{org.hibernate.Session}:
	\item \texttt{org.hibernate.SessionFactory}:
	\item \texttt{org.hibernate.Transaction}:
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \classname{abook.IAddressBookEntry}: interfaccia d'implementazione del package \textit{abook} usata per definire una generica \inglese{entry} della rubrica.
\end{itemize}

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{-- util: HibernateUtil}}\\
	Attributo usato per mantenere un riferimento alla singola istanza di HibernateUtil.
	\item{\memberdata{-- factory: SessionFactory}}\\
	Attributo usato per mantenere un riferimento ad un'istanza di SessionFactory.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ delete(entry: IAddressBookEntry): boolean}}\\
	Metodo usato per cancellare una \textit{entry} dal database. Per \textit{entry} si intende un qualsiasi oggetto implementante l'interfaccia \classname{IAddressBookEntry}. Il metodo riceve come parametro d'ingresso un oggetto \classname{abook.IAddressBookEntry} e restituisce un valore booleano \inglese{true} se l'operazione è andata a buon fine, \inglese{false} altrimenti. Il flusso principale inizia definendo le seguenti variabili:
	\begin{itemize}
		\item viene inizializzata una variabile di tipo \inglese{boolean} nominata \textit{flag}, a \inglese{false};
		\item si crea un istanza di \texttt{Session} session;
		\item si crea un istanza di \texttt{Transaction} transaction;
	\end{itemize}
	Quindi nel metodo deve essere definito un blocco \textit{try-catch} finally:
	\begin{itemize}
		\item nel blocco \textit{try}:
		\begin{itemize}
			\item util deve essere inizializzato mediante la chiamata \method{getIstance()} di \classname{HibernateUtil};
			\item quindi a partire da \textit{util} si inizializza \textit{factory} mediante una chiamata \method{getFactory()};
			\item analogamente a quanto fatto in precedenza, si inizializza \textit{session} tramite una chiamata \method{openSession()} eseguita a partire da \textit{factory};
			\item transaction viene inizializzata con una chiamata a metodo \method{beginTransaction()} eseguita da \textit{session};
			\item quindi si è pronti per eseguire l'istruzione di inglese{delete} a partire da \textit{session} e passando come parametro \textit{entry};
			\item si esegue il \textit{commit};
			\item si pone flag a \inglese{true};
		\end{itemize}
		\item nel blocco catch: si effettua un rollback a partire da transaction;
		\item nel blocco finally: se \textit{session} è diverso da \textit{null}, si chiude mediante una chiamata di tipo \texttt{close()};
	\end{itemize}
	Infine il metodo termina ritornando il valore di \textit{flag};
	
	\item{\method{+ update(entry: IAddressBookEntry): boolean}}\\
	Metodo usato per modificare una \textit{entry} presente nel database. Il metodo riceve come parametro d'ingresso un oggetto \classname{abook.IAddressBookEntry} e restituisce un valore booleano \inglese{true} se l'operazione è andata a buon fine, \inglese{false} altrimenti. Il flusso principale inizia definendo le seguenti variabili:
	\begin{itemize}
		\item viene inizializzata una variabile ti tipo \textit{boolean} nominata \textit{flag}, a \inglese{false};
		\item si crea un istanza di \texttt{Session} session;
		\item si crea un istanza di \texttt{Transaction} transaction;
	\end{itemize}
	Quindi nel metodo deve essere definito un blocco \textit{try-catch} finally:
	\begin{itemize}
		\item nel blocco try:
		\begin{itemize}
			\item util deve essere inizializzato mediante la chiamata \method{getIstance()} di \classname{HibernateUtil};
			\item quindi a partire da \textit{util} si inizializza \textit{factory} mediante una chiamata \method{getFactory()};
			\item analogamente a quanto fatto in precedenza, si inizializza \textit{session} tramite una chiamata \method{openSession()} eseguita a partire da \textit{factory};
			\item transaction viene inizializzata con una chiamata a metodo \method{beginTransaction()} eseguita da \textit{session};
			\item quindi si è pronti per eseguire l'istruzione di \textit{update} a partire da \textit{session} e passando come parametro \textit{entry};
			\item si esegue il commit;
			\item si pone flag a \inglese{true};
		\end{itemize}
		\item nel blocco \textit{catch}: si effettua un \textit{rollback} a partire da \textit{transaction};
		\item nel blocco \textit{finally}: se \textit{session} è diverso da \textit{null}, si chiude mediante una chiamata di tipo \texttt{close()};
	\end{itemize}
	Infine il metodo termina ritornando il valore di \textit{flag};	
	
	\item{\method{+ insert(entry: IAddressBookEntry): boolean}}\\
	Metodo usato per inserire una \textit{entry} nel database. Il metodo riceve come parametro d'ingresso un oggetto \classname{abook.IAddressBookEntry} e restituisce un valore booleano \inglese{true} se l'operazione è andata a buon fine, \inglese{false} altrimenti. Il flusso principale inizia definendo le seguenti variabili:
	\begin{itemize}
		\item viene inizializzata una variabile ti tipo \textit{boolean} nominata \textit{flag}, a \inglese{false};
		\item si crea un istanza di \texttt{Session} session;
		\item si crea un istanza di \texttt{Transaction} transaction;
	\end{itemize}
	Quindi nel metodo deve essere definito un blocco \textit{try-catch} finally:
	\begin{itemize}
		\item nel blocco \textit{try}:
		\begin{itemize}
			\item \textit{util} deve essere inizializzato mediante la chiamata \method{getIstance()} di \classname{HibernateUtil};
			\item quindi a partire da \textit{util} si inizializza \textit{factory} mediante una chiamata \method{getFactory()};
			\item analogamente a quanto fatto in precedenza, si inizializza \textit{session} tramite una chiamata \method{openSession()} eseguita a partire da \textit{factory};
			\item \textit{transaction} viene inizializzata con una chiamata a metodo \method{beginTransaction()} eseguita da \textit{session};
			\item quindi si è pronti per eseguire l'istruzione di \textit{save} a partire da \textit{session} e passando come parametro \textit{entry};
			\item si esegue il \textit{commit};
			\item si pone \textit{flag} a \inglese{true};
		\end{itemize}
		\item nel blocco \textit{catch}: si effettua un \textit{rollback} a partire da \textit{transaction};
		\item nel blocco \textit{finally}: se \textit{session} è diverso da \textit{null}, si chiude mediante una chimata di tipo \texttt{close()};
	\end{itemize}
	Infine il metodo termina ritornando il valore di flag;
	
\end{description}

\classsection{CallDAO}

\subsubsection*{Funzione}
Classe che implementa il pattern DAO. Definisce le procedure d’inserimento, eliminazione ed aggiornamento di entry inerenti alla tabella Call. La classe inoltre fornisce metodi per interrogare il database ed ottenere la lista delle chiamate.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.util.List}:
	\item \texttt{org.hibernate.Query}:
	\item \texttt{org.hibernate.Session}:
	\item \texttt{org.hibernate.SessionFactory}:
	\item \texttt{org.hibernate.Transaction}:
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \classname{abook.ICall}: interfaccia del package \textit{abook} usata per definire una generica \inglese{chiamata}.
\end{itemize}

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{-- util: HibernateUtil}}\\
	Attributo usato per mantenere un riferimento alla singola istanza di HibernateUtil.
	\item{\memberdata{-- factory: SessionFactory}}\\
	Attributo usato per mantenere un riferimento ad un'istanza di SessionFactory.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ delete(call: ICall): boolean}}\\
	Metodo usato per cancellare una chiamata dal database. Il flusso principale inizia definendo le seguenti variabili:
	\begin{itemize}
		\item viene inizializzata una variabile ti tipo boolean nominata flag, a \inglese{false};
		\item si crea un istanza di \texttt{Session} session;
		\item si crea un istanza di \texttt{Transaction} transaction;
	\end{itemize}
	Quindi nel metodo deve essere definito un blocco try catch finally:
	\begin{itemize}
		\item nel blocco try:
		\begin{itemize}
			\item util deve essere inizializzato mediante la chiamata \method{getIstance()} di \classname{HibernateUtil};
			\item quindi a partire da util si inizializza factory mediante una chiamata \method{getFactory()};
			\item analogamente a quanto fatto in precedenza, si inizializza session tramite una chiamata \method{openSession()} eseguita a partire da factory;
			\item transaction viene inizializzata con una chiamata a metodo \method{beginTransaction()} eseguita da session;
			\item quindi si è pronti per eseguire l'istruzione di \inglese{delete} a partire da session e passando come parametro call;
			\item si esegue il commit;
			\item si pone flag a \inglese{true};
		\end{itemize}
		\item nel blocco catch: si effettua un rollback a partire da transaction;
		\item nel blocco finally: se session è diverso da null, si chiude mediante una chimata di tipo close();
	\end{itemize}
	Infine il metodo termina ritornando il valore di flag;
	
	\item{\method{+ update(call: ICall): boolean}}\\
	Metodo usato per modificare una chiamata presente nel database. Il metodo riceve come parametro d'ingresso un oggetto \classname{call.Call} e restituisce un valore booleano  pari a \inglese{true} se l'operazione è andata a buon fine, \inglese{false} altrimenti. Il flusso principale inizia definendo le seguenti variabili:
	\begin{itemize}
		\item viene inizializzata una variabile ti tipo boolean nominata flag, a \inglese{false};
		\item si crea un istanza di \classname{HibernateUtil} util;
		\item si crea un istanza di \texttt{Session} session;
		\item si crea un istanza di \texttt{SessionFactory} factory;
		\item si crea un istanza di \texttt{Transaction} transaction;
	\end{itemize}
	Quindi nel metodo deve essere definito un blocco try catch finally:
	\begin{itemize}
		\item nel blocco try:
		\begin{itemize}
			\item util deve essere inizializzato mediante la chiamata \method{getIstance()} di \classname{HibernateUtil};
			\item quindi a partire da \textit{util} si inizializza \textit{factory} mediante una chiamata \method{getFactory()};
			\item analogamente a quanto fatto in precedenza, si inizializza \textit{session} tramite una chiamata \method{openSession()} eseguita a partire da \textit{factory};
			\item transaction viene inizializzata con una chiamata a metodo \method{beginTransaction()} eseguita da session;
			\item quindi si è pronti per eseguire l'istruzione di \textit{update} a partire da \textit{session} e passando come parametro \textit{call};
			\item si esegue il \textit{commit};
			\item si pone \inglese{flag} a \inglese{true};
		\end{itemize}
		\item nel blocco catch: si effettua un \textit{rollback} a partire da \textit{transaction};
		\item nel blocco finally: se session è diverso da null, si chiude mediante una chiamata di tipo \texttt{close()};
	\end{itemize}
	Infine il metodo termina ritornando il valore di \inglese{flag};	
	
	\item{\method{+ insert(call: ICall): boolean}}\\
	Metodo usato per inserire una chiamata nel database, riceve come parametro d'ingresso un oggetto \classname{call.ICall} e restituisce un valore booleano  pari a \inglese{true} se l'operazione è andata a buon fine, \inglese{false} altrimenti. Il flusso principale inizia definendo le seguenti variabili:
	\begin{itemize}
		\item viene inizializzata una variabile ti tipo \inglese{boolean} nominata \inglese{flag}, a \inglese{false};
		\item si crea un istanza di \texttt{Session} session;
		\item si crea un istanza di \texttt{Transaction} transaction;
	\end{itemize}
	Quindi nel metodo deve essere definito un blocco \textit{try-catch} finally:
	\begin{itemize}
		\item nel blocco try:
		\begin{itemize}
			\item util deve essere inizializzato mediante la chiamata \method{getIstance()} di \classname{HibernateUtil};
			\item quindi a partire da util si inizializza factory mediante una chiamata \method{getFactory()};
			\item analogamente a quanto fatto in precedenza, si inizializza \textit{session} tramite una chiamata \method{openSession()} eseguita a partire da \textit{factory};
			\item transaction viene inizializzata con una chiamata a metodo \method{beginTransaction()} eseguita da session;
			\item quindi si è pronti per eseguire l'istruzione di \textit{save} a partire da \textit{session} e passando come parametro group;
			\item si esegue il commit;
			\item si pone \textit{flag} a \inglese{true};
		\end{itemize}
		\item nel blocco catch: si effettua un \textit{rollback} a partire da \textit{transaction};
		\item nel blocco finally: se \textit{session} è diverso da \textit{null}, si chiude mediante una chiamata di tipo \texttt{close()};
	\end{itemize}
	Infine il metodo termina ritornando il valore di \textit{flag};
	
	\item{\method{+ getByID(identifier: long): ICall}}\\
	Metodo usato per interrogare il database ed ottenere un istanza di \classname{ICall} avente come identificativo, l'id della chiamata ricevuta come parametro d'ingresso. Il flusso principale inizia definendo le seguenti variabili:
	\begin{itemize}
		\item si crea un istanza di \texttt{List<ICall>} calls;
		\item si crea un istanza di \texttt{Query} query;
		\item si crea una stringa hqlQuery impostata per default a:\\
			\verb|"from call as c where c.mittente = :id or c.destinarario =:id"|
		\item si crea un istanza di \texttt{Session} session;
		\item si crea un istanza di \texttt{Transaction} transaction;
	\end{itemize}
	Quindi nel metodo deve essere definito un blocco try catch finally:
	\begin{itemize}
		\item nel blocco try:
		\begin{itemize}
			\item util deve essere inizializzato mediante la chiamata \method{getIstance()} di \classname{HibernateUtil};
			\item quindi a partire da \textit{util} si inizializza \textit{factory} mediante una chiamata \method{getFactory()};
			\item analogamente a quanto fatto in precedenza, si inizializza \textit{session} tramite una chiamata \method{openSession()} eseguita a partire da \textit{factory};
			\item transaction viene inizializzata con una chiamata a metodo \method{beginTransaction()} eseguita da session;
			\item query viene inizializzata mediante una chiamata \textit{createQuery}, chiamata da \textit{session} e a cui deve essere passata come parametro, la stringa hqlQuery;
			\item quindi si è pronti per eseguire query ed ottenere la lista di \classname{ICall} desiderata. Tale operazione si effettua richiamando query.list();
			\item si esegue il \textit{commit};
		\end{itemize}
		\item nel blocco catch: si effettua un \textit{rollback} a partire da \textit{transaction};
		\item nel blocco finally: se \textit{session} è diverso da \textit{null}, si chiude mediante una chiamata di tipo \texttt{close()};
	\end{itemize}
	Il programma termina controllando se calls è diversa da \textit{null} e contiene almeno un elemento. Nel caso il programma termina ritornando la lista cosi ottenuta. Altrimenti termina ritornando \textit{null}.
	
\end{description}

%TODO da verificare

\classsection{CallListDAO}

\subsubsection*{Funzione}
Classe che implementa il pattern DAO. Definisce le procedure d’inserimento, eliminazione ed aggiornamento di entry inerenti alla tabella CallLists. La classe inoltre fornisce metodi per interrogare il database ed ottenere dati utente.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.util.List}:
	\item \texttt{org.hibernate.Query}:
	\item \texttt{org.hibernate.Session}:
	\item \texttt{org.hibernate.SessionFactory}:
	\item \texttt{org.hibernate.Transaction}:
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \classname{call.ICallList}: interfaccia del package \textit{call} usata per definire una generica lista di chiamata.
\end{itemize}

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{-- util: HibernateUtil}}\\
	Attributo usato per mantenere un riferimento alla singola istanza di HibernateUtil.
	\item{\memberdata{-- factory: SessionFactory}}\\
	Attributo usato per mantenere un riferimento ad un'istanza di SessionFactory.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ delete(entry: ICallList): boolean}}\\
	Metodo usato per cancellare una \textit{entry} dal database. Per \textit{entry} si intende un qualsiasi oggetto implementante l'interfaccia \classname{ICallList}. Il metodo riceve come parametro d'ingresso un oggetto \classname{call.ICallList} e restituisce un valore booleano \inglese{true} se l'operazione è andata a buon fine, \inglese{false} altrimenti. Il flusso principale inizia definendo le seguenti variabili:
	\begin{itemize}
		\item viene inizializzata una variabile di tipo \inglese{boolean} nominata \textit{flag}, a \inglese{false};
		\item si crea un istanza di \texttt{Session} session;
		\item si crea un istanza di \texttt{Transaction} transaction;
	\end{itemize}
	Quindi nel metodo deve essere definito un blocco \textit{try-catch} finally:
	\begin{itemize}
		\item nel blocco \textit{try}:
		\begin{itemize}
			\item util deve essere inizializzato mediante la chiamata \method{getIstance()} di \classname{HibernateUtil};
			\item quindi a partire da \textit{util} si inizializza \textit{factory} mediante una chiamata \method{getFactory()};
			\item analogamente a quanto fatto in precedenza, si inizializza \textit{session} tramite una chiamata \method{openSession()} eseguita a partire da \textit{factory};
			\item transaction viene inizializzata con una chiamata a metodo \method{beginTransaction()} eseguita da \textit{session};
			\item quindi si è pronti per eseguire l'istruzione di inglese{delete} a partire da \textit{session} e passando come parametro \textit{entry};
			\item si esegue il \textit{commit};
			\item si pone flag a \inglese{true};
		\end{itemize}
		\item nel blocco catch: si effettua un rollback a partire da transaction;
		\item nel blocco finally: se \textit{session} è diverso da \textit{null}, si chiude mediante una chiamata di tipo \texttt{close()};
	\end{itemize}
	Infine il metodo termina ritornando il valore di \textit{flag};
	
	\item{\method{+ update(entry: ICallLIst): boolean}}\\
	Metodo usato per modificare una \textit{entry} presente nel database. Il metodo riceve come parametro d'ingresso un oggetto \classname{call.ICallList} e restituisce un valore booleano \inglese{true} se l'operazione è andata a buon fine, \inglese{false} altrimenti. Il flusso principale inizia definendo le seguenti variabili:
	\begin{itemize}
		\item viene inizializzata una variabile ti tipo \textit{boolean} nominata \textit{flag}, a \inglese{false};
		\item si crea un istanza di \texttt{Session} session;
		\item si crea un istanza di \texttt{Transaction} transaction;
	\end{itemize}
	Quindi nel metodo deve essere definito un blocco \textit{try-catch} finally:
	\begin{itemize}
		\item nel blocco try:
		\begin{itemize}
			\item util deve essere inizializzato mediante la chiamata \method{getIstance()} di \classname{HibernateUtil};
			\item quindi a partire da \textit{util} si inizializza \textit{factory} mediante una chiamata \method{getFactory()};
			\item analogamente a quanto fatto in precedenza, si inizializza \textit{session} tramite una chiamata \method{openSession()} eseguita a partire da \textit{factory};
			\item transaction viene inizializzata con una chiamata a metodo \method{beginTransaction()} eseguita da \textit{session};
			\item quindi si è pronti per eseguire l'istruzione di \textit{update} a partire da \textit{session} e passando come parametro \textit{entry};
			\item si esegue il commit;
			\item si pone flag a \inglese{true};
		\end{itemize}
		\item nel blocco \textit{catch}: si effettua un \textit{rollback} a partire da \textit{transaction};
		\item nel blocco \textit{finally}: se \textit{session} è diverso da \textit{null}, si chiude mediante una chiamata di tipo \texttt{close()};
	\end{itemize}
	Infine il metodo termina ritornando il valore di \textit{flag};	
	
	\item{\method{+ insert(entry: ICallLIst): boolean}}\\
	Metodo usato per inserire una \textit{entry} nel database. Il metodo riceve come parametro d'ingresso un oggetto \classname{call.ICallLIst} e restituisce un valore booleano \inglese{true} se l'operazione è andata a buon fine, \inglese{false} altrimenti. Il flusso principale inizia definendo le seguenti variabili:
	\begin{itemize}
		\item viene inizializzata una variabile ti tipo \textit{boolean} nominata \textit{flag}, a \inglese{false};
		\item si crea un istanza di \texttt{Session} session;
		\item si crea un istanza di \texttt{Transaction} transaction;
	\end{itemize}
	Quindi nel metodo deve essere definito un blocco \textit{try-catch} finally:
	\begin{itemize}
		\item nel blocco \textit{try}:
		\begin{itemize}
			\item \textit{util} deve essere inizializzato mediante la chiamata \method{getIstance()} di \classname{HibernateUtil};
			\item quindi a partire da \textit{util} si inizializza \textit{factory} mediante una chiamata \method{getFactory()};
			\item analogamente a quanto fatto in precedenza, si inizializza \textit{session} tramite una chiamata \method{openSession()} eseguita a partire da \textit{factory};
			\item \textit{transaction} viene inizializzata con una chiamata a metodo \method{beginTransaction()} eseguita da \textit{session};
			\item quindi si è pronti per eseguire l'istruzione di \textit{save} a partire da \textit{session} e passando come parametro \textit{entry};
			\item si esegue il \textit{commit};
			\item si pone \textit{flag} a \inglese{true};
		\end{itemize}
		\item nel blocco \textit{catch}: si effettua un \textit{rollback} a partire da \textit{transaction};
		\item nel blocco \textit{finally}: se \textit{session} è diverso da \textit{null}, si chiude mediante una chimata di tipo \texttt{close()};
	\end{itemize}
	Infine il metodo termina ritornando il valore di flag;
	
\end{description}

\classsection{MessageDAO}

\subsubsection*{Funzione}
Classe che implementa il pattern DAO. Definisce le procedure d’inserimento, eliminazione ed aggiornamento di entry inerenti alla tabella Message. La classe inoltre fornisce metodi per interrogare il database ed ottenere la lista delle chiamate.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.util.List}:
	\item \texttt{org.hibernate.Query}:
	\item \texttt{org.hibernate.Session}:
	\item \texttt{org.hibernate.SessionFactory}:
	\item \texttt{org.hibernate.Transaction}:
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \classname{abook.IMessage}: interfaccia del package \textit{abook} usata per definire un generico messaggio.
\end{itemize}

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{-- util: HibernateUtil}}\\
	Attributo usato per mantenere un riferimento alla singola istanza di HibernateUtil.
	\item{\memberdata{-- factory: SessionFactory}}\\
	Attributo usato per mantenere un riferimento ad un'istanza di SessionFactory.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ delete(message: IMessage): boolean}}\\
	Metodo usato per cancellare una chiamata dal database. Il flusso principale inizia definendo le seguenti variabili:
	\begin{itemize}
		\item viene inizializzata una variabile ti tipo boolean nominata flag, a \inglese{false};
		\item si crea un istanza di \texttt{Session} session;
		\item si crea un istanza di \texttt{Transaction} transaction;
	\end{itemize}
	Quindi nel metodo deve essere definito un blocco try catch finally:
	\begin{itemize}
		\item nel blocco try:
		\begin{itemize}
			\item util deve essere inizializzato mediante la chiamata \method{getIstance()} di \classname{HibernateUtil};
			\item quindi a partire da util si inizializza factory mediante una chiamata \method{getFactory()};
			\item analogamente a quanto fatto in precedenza, si inizializza session tramite una chiamata \method{openSession()} eseguita a partire da factory;
			\item transaction viene inizializzata con una chiamata a metodo \method{beginTransaction()} eseguita da session;
			\item quindi si è pronti per eseguire l'istruzione di \inglese{delete} a partire da session e passando come parametro call;
			\item si esegue il commit;
			\item si pone flag a \inglese{true};
		\end{itemize}
		\item nel blocco catch: si effettua un rollback a partire da transaction;
		\item nel blocco finally: se session è diverso da null, si chiude mediante una chimata di tipo close();
	\end{itemize}
	Infine il metodo termina ritornando il valore di flag;
	
	\item{\method{+ update(message: IMessage): boolean}}\\
	Metodo usato per modificare una chiamata presente nel database. Il metodo riceve come parametro d'ingresso un oggetto \classname{message.Message} e restituisce un valore booleano  pari a \inglese{true} se l'operazione è andata a buon fine, \inglese{false} altrimenti. Il flusso principale inizia definendo le seguenti variabili:
	\begin{itemize}
		\item viene inizializzata una variabile ti tipo boolean nominata flag, a \inglese{false};
		\item si crea un istanza di \texttt{Session} session;
		\item si crea un istanza di \texttt{Transaction} transaction;
	\end{itemize}
	Quindi nel metodo deve essere definito un blocco try catch finally:
	\begin{itemize}
		\item nel blocco try:
		\begin{itemize}
			\item util deve essere inizializzato mediante la chiamata \method{getIstance()} di \classname{HibernateUtil};
			\item quindi a partire da \textit{util} si inizializza \textit{factory} mediante una chiamata \method{getFactory()};
			\item analogamente a quanto fatto in precedenza, si inizializza \textit{session} tramite una chiamata \method{openSession()} eseguita a partire da \textit{factory};
			\item transaction viene inizializzata con una chiamata a metodo \method{beginTransaction()} eseguita da session;
			\item quindi si è pronti per eseguire l'istruzione di \textit{update} a partire da \textit{session} e passando come parametro \textit{message};
			\item si esegue il \textit{commit};
			\item si pone \inglese{flag} a \inglese{true};
		\end{itemize}
		\item nel blocco catch: si effettua un \textit{rollback} a partire da \textit{transaction};
		\item nel blocco finally: se session è diverso da null, si chiude mediante una chiamata di tipo \texttt{close()};
	\end{itemize}
	Infine il metodo termina ritornando il valore di \inglese{flag};	
	
	\item{\method{+ insert(message: IMessage): boolean}}\\
	Metodo usato per inserire una chiamata nel database, riceve come parametro d'ingresso un oggetto \classname{message.IMessage} e restituisce un valore booleano  pari a \inglese{true} se l'operazione è andata a buon fine, \inglese{false} altrimenti. Il flusso principale inizia definendo le seguenti variabili:
	\begin{itemize}
		\item viene inizializzata una variabile ti tipo \inglese{boolean} nominata \inglese{flag}, a \inglese{false};
		\item si crea un istanza di \texttt{Session} session;
		\item si crea un istanza di \texttt{Transaction} transaction;
	\end{itemize}
	Quindi nel metodo deve essere definito un blocco \textit{try-catch} finally:
	\begin{itemize}
		\item nel blocco try:
		\begin{itemize}
			\item util deve essere inizializzato mediante la chiamata \method{getIstance()} di \classname{HibernateUtil};
			\item quindi a partire da util si inizializza factory mediante una chiamata \method{getFactory()};
			\item analogamente a quanto fatto in precedenza, si inizializza \textit{session} tramite una chiamata \method{openSession()} eseguita a partire da \textit{factory};
			\item transaction viene inizializzata con una chiamata a metodo \method{beginTransaction()} eseguita da session;
			\item quindi si è pronti per eseguire l'istruzione di \textit{save} a partire da \textit{session} e passando come parametro message;
			\item si esegue il commit;
			\item si pone \textit{flag} a \inglese{true};
		\end{itemize}
		\item nel blocco catch: si effettua un \textit{rollback} a partire da \textit{transaction};
		\item nel blocco finally: se \textit{session} è diverso da \textit{null}, si chiude mediante una chiamata di tipo \texttt{close()};
	\end{itemize}
	Infine il metodo termina ritornando il valore di \textit{flag};
	
	\item{\method{+ getByID(identifier: long): List<IMessage>}}\\
	Metodo usato per interrogare il database ed ottenere una lista d'istanze di \classname{IMessage} aventi come identificativo dell'utente proprietario del messaggio, l'identificativo ricevuto come parametro d'ingresso. Il flusso principale inizia definendo le seguenti variabili:
	\begin{itemize}
		\item si crea un istanza di \texttt{List<IMessage>} messages;
		\item si crea un istanza di \texttt{Query} query;
		\item si crea una stringa hqlQuery impostata per default a:\\
			\verb|"from message as m where m.owner = :id"|
		\item si crea un istanza di \texttt{Session} session;
		\item si crea un istanza di \texttt{Transaction} transaction;
	\end{itemize}
	Quindi nel metodo deve essere definito un blocco try catch finally:
	\begin{itemize}
		\item nel blocco try:
		\begin{itemize}
			\item util deve essere inizializzato mediante la chiamata \method{getIstance()} di \classname{HibernateUtil};
			\item quindi a partire da \textit{util} si inizializza \textit{factory} mediante una chiamata \method{getFactory()};
			\item analogamente a quanto fatto in precedenza, si inizializza \textit{session} tramite una chiamata \method{openSession()} eseguita a partire da \textit{factory};
			\item transaction viene inizializzata con una chiamata a metodo \method{beginTransaction()} eseguita da session;
			\item query viene inizializzata mediante una chiamata \textit{createQuery}, chiamata da \textit{session} e a cui deve essere passata come parametro, la stringa hqlQuery;
			\item quindi si è pronti per eseguire query ed ottenere la lista di \classname{IMessage} desiderata. Tale operazione si effettua richiamando query.list();
			\item si esegue il \textit{commit};
		\end{itemize}
		\item nel blocco catch: si effettua un \textit{rollback} a partire da \textit{transaction};
		\item nel blocco finally: se \textit{session} è diverso da \textit{null}, si chiude mediante una chiamata di tipo \texttt{close()};
	\end{itemize}
	Il programma termina controllando se messages è diversa da \textit{null} e contiene almeno un elemento. Nel caso il programma termina ritornando la lista cosi ottenuta. Altrimenti termina ritornando \textit{null}.
	
\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.abook}\label{sec:abook}

\classsection{IUserData}

\subsubsection*{Funzione}
Interfaccia rappresentante il comportamento di un generico utente del sistema. L'interfaccia dovrà definire dei metodi di tipo \textit{get} e \textit{set} per i dati d'interesse.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \classname{AddressBookEntry}: l'interfaccia definisce dei metodi per la manipolazione di dati \classname{AddressBookEntry}.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{org.softwaresynthesis.mytalk.server.IMyTalkObject}: interfaccia da estendere. Ogni oggetto che implementerà l'interfaccia \classname{IUserData} dovrà essere in grado di convertire il proprio contenuto informativo in formato \textit{Json}.
\end{itemize}


\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce l'identificatore univoco di uno \classname{IUserData}.
	\item{\method{+ getEmail(): String}}\\
	Restituisce l'indirizzo e-mail con cui uno \classname{IUserData} si è registrato nel sistema \caName.
	\item{\method{+ setEmail(mail: String): void}}\\ 
	Imposta l'indirizzo e-mail con cui si registra nel sistema \caName uno \classname{IUserData}.
	\item{\method{+ getPassword(): String}}\\
	Restituisce la password di accesso al sistema \caName di uno \classname{IUserData}.
	\item{\method{+ setPassword(password: String): void}}\\
	Imposta la password di accesso al sistema di uno \classname{IUserData}.
	\item{\method{+ getQuestion(): String}}\\
	Restituisce la domanda segreta, scelta da uno \classname{IUserData}, per il recupero della \textit{password} smarrita di accesso al sistema \caName.
	\item{\method{+ setQuestion(question: String): void}}\\
	Imposta la domanda segreta, scelta da uno \classname{IUserData}, per il recupero della \textit{password} smarrita di accesso al sistema \caName.
	\item{\method{+ getAnswer(): String}}\\
	Restituisce la risposta alla domanda per il recupero della \textit{password} smarrita di accesso al sistema \caName.
	\item{\method{+ setAnswer(answer: String): void}}\\
	Imposta la risposta alla domanda segreta per il recupero della \textit{password} di accesso al sistema \caName.
	\item{\method{+ getName(): String}}\\
	Restituisce il nome di uno \classname{IUserData}.
	\item{\method{+ setName(name: String): void}}\\
	Imposta il nome di uno \classname{IUserData}.
	\item{\method{+ getSurname(): String}}\\
	Restituisce il cognome di uno \classname{IUserData}.
	\item{\method{+ setSurname(surname: String): void}}\\
	Imposta il cognome di uno \classname{IUserData}.
	\item{\method{+ getPicturePath(): String}}\\
	Restituisce una stringa con il percorso dell'immagine del profilo di uno \classname{IUserData}.
	\item{\method{+ setPicturePath(path: String): void}}\\
	Imposta il percorso dell'immagine profilo di uno \classname{IUserData}.
	\item{\method{+ getAddressBook(): Set<AddressBookEntry>}}\\
	Metodo che ritorna il la rubrica dell'utente sotto forma d'insieme di \classname{AddressBookEntry}.
	\item{\method{+ addAddressBookEntry(entry: AddressBookEntry): void}}\\
	Metodo usato per aggiungere una nuova \classname{AddressBookEntry} all'insieme di \inglese{entry} che costituisce la rubrica utente.
\end{description}

\classsection{IGroup}

\subsubsection*{Funzione}
Interfaccia rappresentante un gruppo di una rubrica utente del sistema \caName.

\subsubsection*{Relazioni d'uso}

Nessuna relazione evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
		\item \texttt{org.softwaresynthesis.mytalk.server.IMyTalkObject}: interfaccia da estendere. Ogni oggetto che implementerà l'interfaccia \classname{IGroup} dovrà essere in grado di convertire il proprio contenuto informativo in formato \textit{Json}.
\end{itemize}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce l'identificativo univoco di uno gruppo di una rubrica utente.
	\item{\method{+ getName(): String}}\\
	Restituisce il nome di un gruppo di una rubrica utente.
	\item{\method{+ setName(name: String): void}}\\
	Imposta il nome di un gruppo di una rubrica utente.
\end{description}

\classsection{IAddressBookEntry}

\subsubsection*{Funzione}
Interfaccia rappresentante una \textit{entry} di una rubrica utente del sistema mytalk.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \classname{IUserData}: l'interfaccia \classname{IAddressBookEntry} definisce più metodi che restituiscono oggetti aventi tipo di ritorno \classname{IUserData}, essi sono i metodi \inglese{get} per ottenere il ``proprietario'' della rubrica e per ottenere l'utente registrato nella rubrica. Analogamente \classname{IUserData} viene usato come parametro d'ingresso per i metodi \inglese{set} collegati ai metodi già citati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
		\item \texttt{org.softwaresynthesis.mytalk.server.IMyTalkObject}: interfaccia da estendere. Ogni oggetto che implementerà l'interfaccia \classname{IAddressBookEntry} dovrà essere in grado di convertire il proprio contenuto informativo in formato \textit{Json}.
\end{itemize}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce l'identificativo univoco di una \inglese{entry} di una rubrica utente del sistema \caName.
	\item{\method{+ getEntry(): IUserData}}\\
	Restituisce un istanza di un oggetto avente tipo \classname{IUserData} rappresentante un contatto della rubrica.
	\item{\method{+ setEntry(contact: IUserData): void}}\\
	Imposta l'utente \classname{IUserData} (passato come parametro d'ingresso) come contatto della rubrica.
	\item{\method{+ getGroup(): IGroup}}\\
	Restituisce il gruppo a cui appartiene lo \classname{IUserData} registrato nella rubrica.
	\item{\method{+ setGroup(group: IGroup): void}}\\
	Imposta il gruppo di appartenenza dello \classname{IUserData} registrato nella rubrica.
	\item{\method{+ getOwner(): IUserData}}\\
	Restituisce lo \classname{IUserData} possessore dell'\inglese{entry} corrente della rubrica
	\item{\method{+ setOwner(owner: IUserData ): void}}\\
	Imposta l'utente \classname{IUserData} possessore della \inglese{entry} della rubrica.
\end{description}

\classsection{UserData}

\subsubsection*{Funzione}
Implementazione dell'interfaccia \classname{IUserData}. Un istanza della classe dovrà rappresentare un generico utente del sistema definendone gli attributi e i metodi per impostare ed ottenere il contenuto dei medesimi.

\subsubsection*{Relazioni d'uso}

Nessuna relazione evidenziata

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
		\item{IUserData}: interfaccia da implementare.
\end{itemize}

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{-- id: long}}
	Attributo che definisce il codice identificativo con il quale l'utente è registrato nel database del sistema.
	\item{\memberdata{-- mail: String}}
	Attributo che definisce l'indirizzo e-mail con il quale l'utente si è registrato nel sistema.
	\item{\memberdata{-- password: String}}
	Attributo che definisce la password per il \inglese{login} dell'utente nel sistema.
	\item{\memberdata{-- question: String}}
	Attributo che definisce la domanda segreta usata dall'utente in caso di smarrimento della password.
	\item{\memberdata{-- answer: String}}
	Attributo che definisce la risposta alla domanda segreta definita nell'attributo \memberdata{question}.
	\item{\memberdata{-- name: String}}
	Attributo che definisce il nome dell'utente.
	\item{\memberdata{-- surname: String}}
	Attributo che definisce il cognome dell'utente.
	\item{\memberdata{-- path: String}}
	Attributo che definisce il percorso (sul server) in cui è memorizzata l'immagine del profilo dell'utente.
	\item{\memberdata{-- addressBook: Set<AddressBookEntry>}}
	Attributo che definisce l'insieme di \classname{AddressBookEntry} che costituiscono la rubrica dell'utente.
	
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce l'identificatore univoco di un utente, ritornando l'attributo \memberdata{id}.
	\item{\method{\# setId(id: long): void}}\\
	Imposta l'indirizzo \textit{id} con cui l'utente si registra nel sistema \caName. Il metodo sovrascrive il contenuto dell'attributo \memberdata{id} con il valore tipo \texttt{long} ricevuto come parametro d'ingresso. ritornando l'attributo \memberdata{id}.
	\item{\method{+ getEmail(): String}}\\
	Restituisce l'indirizzo e-mail con cui uno l'utente si è registrato nel sistema \caName, ritornando il contenuto dell'attributo \memberdata{mail}.
	\item{\method{+ setEmail(mail: String): void}}\\ 
	Imposta l'indirizzo e-mail con cui l'utente si registra nel sistema \caName. Il metodo non fa altro che sovrascrivere il contenuto dell'attributo \memberdata{mail} con il valore tipo \texttt{String} ricevuto come parametro d'ingresso.
	\item{\method{+ getPassword(): String}}\\
	Restituisce la password dell'utente, ritornando il valore contenuto nell'attributo \memberdata{password}.
	\item{\method{+ setPassword(password: String): void}}\\
	Imposta la password di accesso al sistema, sovrascrivendo il contenuto dell'attributo \memberdata{password} con il valore di tipo \texttt{String} ricevuto come parametro d'ingresso.
	\item{\method{+ getQuestion(): String}}\\
	Restituisce la domanda segreta, scelta dall'utente, per il recupero della password di accesso al sistema \caName. Nello specifico il metodo restituisce il contenuto dell'attributo \memberdata{question}.
	\item{\method{+ setQuestion(question: String): void}}\\
	Imposta la domanda segreta da inserire in caso di smarrimento della password. Il metodo sovrascrive il contenuto dell'attributo \memberdata{question} con il valore tipo \texttt{String} ricevuto come parametro d'ingresso
	\item{\method{+ getAnswer(): String}}\\
	Restituisce la risposta alla domanda per il recupero della password (smarrita) di accesso al sistema \caName. Il metodo ritorna il contenuto dell'attributo \memberdata{answer}.
	\item{\method{+ setAnswer(answer: String): void}}\\
	Imposta la risposta alla domanda segreta per il recupero della password. Il metodo sovrascrive il contenuto dell'attributo \memberdata{answer} con il valore tipo \texttt{String} passato come parametro d'ingresso.
	\item{\method{+ getName(): String}}\\
	Restituisce il nome dell'utente ritornando il contenuto dell'attributo \memberdata{name}.
	\item{\method{+ setName(name: String): void}}\\
	Imposta il nome dell'utente sovrascrivendo il contenuto dell'attributo \memberdata{name} con il valore tipo \texttt{String} passato al metodo come parametro d'ingresso.
	\item{\method{+ getSurname(): String}}\\
	Restituisce il cognome dell'utente restituendo il contenuto dell'attributo \memberdata{surname}.
	\item{\method{+ setSurname(surname: String): void}}\\
	Imposta il cognome dell'utente sovrascrivendo il contenuto dell'attributo \memberdata{surnamename} con il valore tipo \texttt{String} passato al metodo come parametro d'ingresso.
	\item{\method{+ getPicturePath(): String}}\\
	Restituisce una stringa con il percorso dell'immagine del profilo dell'utente, restituendo il contenuto dell'attributo \memberdata{path}.
	\item{\method{+ setPicturePath(path: String): void}}\\
	Imposta il percorso dell'immagine profilo di un utente, sovrascrivendo il contenuto dell'attributo \memberdata{path} con il valore tipo \texttt{String} passato al metodo come parametro d'ingresso.
	\item{\method{+ getState(): State}}\\
	Restituisce lo stato in cui si trova l'utente, ritornando il contenuto dell'attributo \memberdata{state}.
	\item{\method{+ setState(state: State): void}}\\
	Imposta lo stato in cui si trova l'utente, sovrascrivendo il contenuto dell'attributo \memberdata{state} con il valore ricevuto come parametro d'ingresso.
	\item{\method{+ getAddressBook(): Set<AddressBookEntry>}}\\
	Metodo che ritorna il contenuto di \memberdata{addressBook}.
	\item{\method{+ addAddressBookEntry(entry: AddressBookEntry): void}}\\
	Metodo usato per aggiungere ad \memberdata{addressBook} una nuova \classname{AddressBookEntry} passata come parametro d'ingresso.
	\item{\method{+ toJson(): String}}\\
	Metodo usato per ritornare il contenuto di un istanza di \classname{UserData} sotto forma di stringa formattata in \textit{Json}. La stringa ritornata deve corrispondere al seguente formato:\\\\
	\verb|{name:"mio_nome",surname:"mio_cognome",email:"mia_mail"|\\\verb|,picturePath:"mia_immagine",id:"mio_id"}|\\
	
	dove i valori tra virgolette rappresentano il contenuto dei rispettivi campi dati contenuti nella classe.
\end{description}

\classsection{Group}

\subsubsection*{Funzione}
Implementazione dell'interfaccia \classname{IGroup}.

\subsubsection*{Relazioni d'uso}

Nessuna relazione evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \classname{IGroup}: interfaccia d'implementazione.
\end{itemize}


\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{-- id: long}}
	Attributo del codice identificativo del gruppo.
	\item{\memberdata{-- name: String}}:
	Attributo del nome del gruppo.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce l'identificativo univoco di uno gruppo di una rubrica utente.
	\item{\method{+ getName(): String}}\\
	Restituisce il nome di un gruppo di una rubrica utente.
	\item{\method{+ setName(name: String): void}}\\
	Imposta il nome di un gruppo di una rubrica utente.
	\item{\method{+ toJson(): String}}\\
	Metodo usato per ritornare il contenuto di un istanza di \classname{Group} sotto forma di stringa formattata in \textit{Json}. La stringa ritornata deve corrispondere al seguente formato:\\\\
	\verb|{id:"mio_id",name:"mio_nome"}|\\
	
	dove i valori tra virgolette rappresentano il contenuto dei rispettivi campi dati contenuti nella classe.
\end{description}

\classsection{AddressBookEntry}

\subsubsection*{Funzione}
Implementazione dell'interfaccia IAddressBookEntry.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \classname{IUserData}: usata per definire gli attributi destinati a identificare il possessore dell'istanza di \classname{AddressBookEntry} e il relativo contatto in essa registrato.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \classname{IAddressBookEntry}: interfaccia d'implementazione della classe.
\end{itemize}

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{-- id: long}}
	Attributo del codice identificativo della classe.
	\item{\memberdata{-- group: IGroup}}
	Attributo destinato a identificare il gruppo a cui appartiene il contatto \classname{IUserName} registrato nella classe. Si ricorda che il contatto può anche non appartenere ad alcun gruppo.
	\item{\memberdata{-- contact: IUserData}}
	Attributo destinato ad identificare il contatto registrato nell'istanza di \classname{AddressBookEntry}.
	\item{\memberdata{-- owner: IUserData}}:
	Attributo destinato ad identificare il possessore dell'istanza di \classname{AddressBookEntry}.
	\item{\memberdata{-- blocked: boolean}}
	Attributo booleano necessario per bloccare il contatto. Tale blocco avviene impostando l'attributo a \textit{true}.
\end{itemize}


\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce l'identificativo univoco della \inglese{entry} di una rubrica utente del sistema \caName, nello specifico il contenuto dell'attributo \memberdata{id}.
	\item{\method{+ getEntry(): IUserData}}\\
	Restituisce il contenuto dell'attributo \memberdata{contact}.
	\item{\method{+ setEntry(contact: IUserData): void}}\\
	Imposta l'utente \classname{IUserData} (passato come parametro d'ingresso) come contatto della rubrica, nello specifico il contenuto dell'attributo \memberdata{contact}.
	\item{\method{+ getGroup(): IGroup}}\\
	Restituisce il gruppo a cui appartiene lo \classname{IUserData} registrato nella rubrica, nello specifico il contenuto dell'attributo \memberdata{group}.
	\item{\method{+ setGroup(group: IGroup): void}}\\
	Imposta il gruppo di appartenenza dello \classname{IUserData} registrato nella rubrica, nello specifico il contenuto dell'attributo \memberdata{group}.
	\item{\method{+ getOwner(): IUserData}}\\
	Restituisce lo \classname{IUserData} possesore di questa \inglese{entry} della rubrica, nello specifico il contenuto dell'attributo \memberdata{owner}.
	\item{\method{+ setOwner(owner: IUserData ): void}}\\
	Imposta l'utente \classname{IUserData} possessore della \textit{entry} della rubrica, nello specifico il contenuto dell'attributo \memberdata{owner}.
	\item{\method{+ toJson(): String}}\\
	Metodo usato per ritornare il contenuto di un istanza di \classname{AddressBookEntry} sotto forma di stringa formattata in \textit{Json}. La stringa ritornata deve corrispondere al seguente formato:\\\\
	\verb|{id:"mio_id",contact:"mio_contatto",group:"mia_gruppo",blocked:"bloccato"}|\\
	
	dove i valori tra virgolette rappresentano il contenuto dei rispettivi campi dati contenuti nella classe.

\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.abook.servlet}\label{sec:call}

%TODO da verificare

\classsection{AddressBookDoAddContactServlet}

\subsubsection*{Funzione}
\textit{Servlet} che ha il compito di aggiungere alla rubrica un nuovo contatto.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doPost()}. Usata per scrivere l'output della \inglese{servlet}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{javax.servlet.http.HttpServlet}: classe estesa da \classname{LoginManager}.
	\item \texttt{javax.servlet.http.HttpServletRequest}:  classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in ingresso alla \inglese{servlet}).
	\item \texttt{javax.security.auth.login.LoginContext}: classe usata in \method{doPost()} per eseguite la \textit{logout} dal sistema.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe per usata per la comunicazione con la servlet (inoltra i dati in uscita dalla chiamata a \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpSession}: classe usata per definire una sessione HTTP.
	\item \classname{org.softwaresynthesis.mytalk.server.dao.UserDataDAO}: classe usata per comunicare tramite Hibernate con la tabella UserData della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{\underline{-- \{frozen\} serialVersionUID: long}}}
	Attributo contenente l'id per la serializzazione dei dati. Il valore di creazione deve essere \texttt{10012L}.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ AddressBookDoAddContactServlet()}}\\
	Costruttore pubblico della \inglese{servlet}. Richiama il costruttore della classe padre (chiamata a \texttt{super}).
	
	\item{\method{\# doGet(request HttpServletRequest, response HttpServletResponse): void}}\\
	Metodo usato per eseguire la richiesta di aggiungere un nuovo contatto all'interno della rubrica (eseguito in risposta ad una richiesta HTTP con metodo \texttt{GET}). Poiché si intende gestire in modo univoco una richiesta a tale \inglese{servlet} (indifferentemente dalla tipologia d'invio dati) il metodo reindirizza il flusso principale al metodo \method{doPost()}.
	
	\item{\method{\# doPost(request HttpServletRequest, response HttpServletResponse): void}}\\	
	Metodo usato per eseguire la richiesta di aggiungere un nuovo contatto all'interno della rubrica (eseguito in risposta ad una richiesta HTTP con metodo \texttt{POST}). Il flusso principale inizia  con la creazione di un oggetto \classname{dao.UserDataDAO} avente nome UserDAO. Quindi viene aperto un blocco try catch in cui si salva in un istanza di tipo \texttt{HttpSession}, l'oggetto ritornato da una chiamata \verb|request.getSession(false)|. I passi successivi sono (nell'ordine):
	\begin{itemize}
		\item salvare in attributo di tipo long, contactID, l'id dell'utente. Tale id dovrà essere ottenuto con una chiamata:\\
		\verb|request.getParameter("contactId")|;\\
		
		\item si crea un istanza di tipo \classname{IUserData} a partire da una chiamata a metodo:\\
		\verb|session.getAttribute("user")|;
		
		\item si crea un istanza di tipo \classname{IUserData} che conterrà ``l'utente'' che dovrà essere registrato nella rubrica del chiamante. L'oggetto dovrà essere istanziato in seguito ad una chiamata:\\
		\verb|userDAO.getByID(contactId)|;
	\end{itemize}
	Quindi se il contatto (che dovrò andare a registrare) è stato correttamente istanziato (contatto != null) allora il flusso principale procede creando e impostando un istanza di \classname{AddressBookEntry}. Il metodo termina ``scrivendo'' \inglese{true} all'interno di un istanza di \texttt{PrintWriter} creata a partire da \texttt{response.getWriter()} ed eseguendo il metodo \method{addAddressBookEntry()} (passando l'entry creata in precedenza) a partire dall'istanza che rappresenta l'utente richiedente.
	
	Se invece si è osservato che l'oggetto contenente il contatto da aggiungere, ha valore uguale a null, allora il metodo termina scrivendo \inglese{false} all'intero della dello stesso \texttt{PrintWriter} già citato.
\end{description}

%TODO da verificare

\classsection{AddressBookDoRemoveContactServlet}

\subsubsection*{Funzione}
\textit{Servlet} richiamata dal \textit{client} per eseguire l'eliminazione di un contatto presente nella propria rubrica.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doPost()}. Usata per scrivere l'output della \inglese{servlet}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{javax.servlet.http.HttpServlet}: classe estesa da \classname{LoginManager}.
	\item \texttt{javax.servlet.http.HttpServletRequest}:  classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in ingresso alla \inglese{servlet}).
	\item \texttt{javax.security.auth.login.LoginContext}: classe usata in \method{doPost()} per eseguite la logout dal sistema.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in uscita dalla chiamata a \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpSession}: classe usata per definire una sessione HTTP.
	\item \classname{org.softwaresynthesis.mytalk.server.dao.UserDataDAO}: classe usata per comunicare tramite Hibernate con la tabella UserData della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{\underline{-- \{frozen\} serialVersionUID: long}}}
	Attributo contenente l'id per la serializzazione dei dati, il valore di creazione deve essere \texttt{10013L}.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ AddressBookDoRemoveContactServlet()}}\\
	Costruttore pubblico della \inglese{servlet}, richiama il costruttore della classe padre (chiamata a \texttt{super}).
	
	\item{\method{\# doGet(request HttpServletRequest, response HttpServletResponse): void}}\\
	Metodo usato per eseguire la richiesta di eliminazione di un contatto presente all'interno della rubrica (eseguito in risposta ad una richiesta HTTP con metodo \texttt{GET}). Poiché si intende gestire in modo univoco una richiesta a tale \inglese{servlet} (indifferentemente dalla tipologia d'invio dati) il metodo reindirizza il flusso principale al metodo \method{doPost()}.
	
	\item{\method{\# doPost(request HttpServletRequest, response HttpServletResponse): void}}\\	
	Metodo usato per eseguire la richiesta di eliminazione di un contatto presente all'interno della rubrica (eseguito in risposta ad una richiesta HTTP con metodo \texttt{POST}). Tale metodo deve creare un istanza di \texttt{AddressBookEntry} con i dati relativi alla \textit{entry} da eliminare, quindi richiamerà il metodo \method{removeAddressBookEntry()} a partire dalle due istanze di \texttt{IUserData} (quella che rappresenta l'utente richiedete e quella che rappresenta l'utente da eliminare) passando come parametro l'\textit{entry} definita in precedenza. Più nello specifico Il flusso principale inizia  con la creazione di un oggetto \classname{dao.UserDataDAO} avente nome UserDAO, quindi viene aperto un blocco \textit{try-catch} in cui si salva in un istanza di tipo \texttt{HttpSession}, l'oggetto ritornato da una chiamata \verb|request.getSession(false)|. I passi successivi sono (nell'ordine):
	\begin{itemize}
		\item salvare in attributo di tipo long, contactID, l'id dell'utente. Tale id dovrà essere ottenuto con una chiamata:\\
		\verb|request.getParameter("contactId")|;\\
		
		\item si crea un istanza di tipo \classname{IUserData} a partire da una chiamata a metodo:\\
		\verb|session.getAttribute("user")|;
		
		\item si crea un istanza di tipo \classname{IUserData} che conterrà ``l'utente'' che dovrà essere eliminato dalla rubrica del chiamante. L'oggetto dovrà essere istanziato in seguito ad una chiamata:\\
		\verb|userDAO.getByID(contactId)|;
	\end{itemize}
	Quindi se il contatto (che dovrò andare a cancellare dalla lista) è stato correttamente istanziato (\texttt{contatto != null}) allora il flusso principale procede creando e impostando un istanza di \classname{AddressBookEntry}. Quindi a partire dall'oggetto che rappresenta l'utente richiedente, viene richiamato il metodo \method{removeAddressBookEntry()}. Il metodo termina ``scrivendo'' \inglese{true} all'interno di un istanza di \texttt{PrintWriter} creata a partire da \texttt{response.getWriter()}.
	
	Se invece si è osservato che l'oggetto contenente il contatto da rimuovere, ha valore uguale a \textit{null}, allora il metodo termina impostando \inglese{false} all'intero della dello stesso \texttt{PrintWriter} già citato.
\end{description}

%TODO da verificare

\classsection{AddressBookDoCreateGroupServlet}

\subsubsection*{Funzione}
\inglese{Servlet} richiamata dal \textit{client} per creare un nuovo gruppo nella propria rubrica.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doPost()}. Usata per scrivere l'output della \inglese{servlet}.
	\item \texttt{javax.servlet.ServletException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{javax.servlet.http.HttpServlet}: classe estesa da \classname{LoginManager}.
	\item \texttt{javax.servlet.http.HttpServletRequest}:  classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in ingresso alla \inglese{servlet}).
	\item \texttt{javax.security.auth.login.LoginContext}: classe usata in \method{doPost()} per eseguite la logout dal sistema.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in uscita dalla chiamata a \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpSession}: classe usata per definire una sessione HTTP.
	\item \classname{org.softwaresynthesis.mytalk.server.dao.UserDataDAO}: classe usata per comunicare tramite Hibernate con la tabella UserData della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{\underline{-- \{frozen\} serialVersionUID: long}}}
	Attributo contenente l'id per la serializzazione dei dati. Il valore di creazione deve essere \texttt{10015L}.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ AddressBookDoCreateGroupServlet()}}\\
	Costruttore pubblico della \inglese{servlet}. Richiama il costruttore della classe padre (chiamata a \texttt{super}).
	
	\item{\method{\# doGet(request HttpServletRequest, response HttpServletResponse): void}}\\
	Metodo usato per eseguire la richiesta di creazione di un gruppo (eseguito in risposta ad una richiesta HTTP con metodo \texttt{GET}). Poiché si intende gestire in modo univoco una richiesta a tale \inglese{servlet} (indifferentemente dalla tipologia d'invio dati) il metodo reindirizza il flusso principale al metodo \method{doPost()}.
	
	\item{\method{\# doPost(request HttpServletRequest, response HttpServletResponse): void}}\\	
	Metodo usato per eseguire la richiesta di creazione di un gruppo (eseguito in risposta ad una richiesta HTTP con metodo \texttt{POST}). Nell'ordine proposto, devono essere eseguite le seguenti operazioni:
	\begin{itemize}
		\item creazione di un oggetto \classname{dao.GroupDAO} avente nome groupDAO;
		\item creazione di un oggetto \texttt{HttpSession} avente nome session;
		\item creazione di un oggetto \classname{abook.IGroup} avente nome group;
		\item creazione di un oggetto \classname{abook.IUserData} avente nome user;
		\item creazione di un oggetto \texttt{PrinterWriter} avente nome writer;
		\item creazione di due stringhe, name e result;
	\end{itemize}
	A questo punto viene creato un blocco \textit{try-catch}. Il blocco \textit{catch} imposta la stringa \textit{result} a \inglese{false}, il blocco \textit{try} dovrà invece seguire il seguente iter:
	\begin{itemize}
		\item si imposta \textit{session} con il valore ritornato da una chiamata:\\
		\verb|request.getSession(false)|;
		\item si imposta la variabile user con il valore presente nell'attributo \textit{user} di sessione (usare l'istruzione \verb|session.getAttribute("user")|;
		\item impostare name con il contenuto del parametro \textit{groupName} presente nell'oggetto request;
		\item verificare se \inglese{name} è \textit{null} o vuoto. Nel caso procedere impostando \textit{result} a \textit{false} e uscendo dal blocco \textit{try}.
		\item altrimenti, se \inglese{name} contiene un nome valido si crea un nuovo gruppo (salvandolo nella variabile group), e impostando il nome e l'utente proprietario.
		\item richiamare \method{insert()} a partire dall'istanza groupDAO, passando come parametro group (che ora conterrà in gruppo da inserire nel database). Viene impostato \textit{result} a \inglese{true},
	il metodo termina scrivendo su \inglese{write} (usando l'omonimo metodo) il valore contenuto in \textit{result}. 		
	\end{itemize}
	
\end{description}

%TODO da verificare

\classsection{AddressBookDoDeleteGroupServlet}

\subsubsection*{Funzione}
\inglese{Servlet} richiamata dal \textit{client} per eliminare un gruppo da una rubrica.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doPost()}. Usata per scrivere l'output della \inglese{servlet}.
	\item \texttt{javax.servlet.ServletException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{javax.servlet.http.HttpServlet}: classe estesa da \classname{LoginManager}.
	\item \texttt{javax.servlet.http.HttpServletRequest}:  classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in ingresso alla \inglese{servlet}).
	\item \texttt{javax.security.auth.login.LoginContext}: classe usata in \method{doPost()} per eseguite la logout dal sistema.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in uscita dalla chiamata a \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpSession}: classe usata per definire una sessione HTTP.
	\item \classname{org.softwaresynthesis.mytalk.server.dao.UserDataDAO}: classe usata per comunicare tramite Hibernate con la tabella UserData della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{\underline{-- \{frozen\} serialVersionUID: long}}}
	Attributo contenente l'id per la serializzazione dei dati. Il valore di creazione deve essere \texttt{10015L}.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ AddressBookDoDeleteGroupServlet()}}\\
	Costruttore pubblico della \inglese{servlet}. Richiama il costruttore della classe padre (chiamata a \texttt{super}).
	
	\item{\method{\# doGet(request HttpServletRequest, response HttpServletResponse): void}}\\
	Metodo usato per eseguire la richiesta di eliminazione di un gruppo (eseguito in risposta ad una richiesta HTTP con metodo \texttt{GET}). Poiché si intende gestire in modo univoco una richiesta a tale \inglese{servlet} (indifferentemente dalla tipologia d'invio dati) il metodo reindirizza il flusso principale al metodo \method{doPost()}.
	
	\item{\method{\# doPost(request HttpServletRequest, response HttpServletResponse): void}}\\	
	Metodo usato per eseguire la richiesta di eliminazione di un gruppo (eseguito in risposta ad una richiesta HTTP con metodo \texttt{POST}). Nell'ordine proposto, devono essere eseguite le seguenti operazioni:
	\begin{itemize}
		\item creazione di un'istanza di \classname{dao.AddressBookEntryDAO} denominata entryDAO;
		\item creazione di un \classname{dao.GroupDAO} denominata groupDAO.
		\item creazione di un'istanza di \classname{abook.IGroup} denominata group;
		\item creazione di un istanza di \classname{abook.IAddressBookEntry} denominata entry;
		\item creazione di un istanza di \texttt{Iterator<IAddressBookEntry>} denominata iterator;
		\item creazione di un istanza di \texttt{PrintWriter} denominata writer;
		\item creazione di un \texttt{Set<IAddressBookEntry>} denominato entrys;
		\item creazione di una stringa denominata result (utilizzata per registrare il messaggio da stampare sul writer);
	\end{itemize} 
	A questo punto deve essere definito un blocco \textit{try-catch}. Dentro il blocco \textit{catch} si  imposta \textit{result} con il valore \inglese{false}. Per quanto riguarda il blocco \textit{try}, il programmatore dovrà definire il seguente iter:
	\begin{itemize}
		\item salvare in group il valore ritornato da una chiamata \method{getByID} a cui passo l'identificativo del gruppo (\texttt{request.getParameter("groupId")}) a partire dall'oggetto groupDAO.
		\item quindi si esegue una verifica sul contenuto di group. Se \texttt{group == null} allora si imposta \textit{result} a \inglese{false}. Altrimenti si carica in \textit{entry} l'oggetto ritornato da una chiamata \method{getAddressBook()} a partire da group.
		\item a tal punto (sempre dentro al costrutto condizionale \texttt{if(group != null))} si crea un iteratore tramite \texttt{entrys.iterator()} e ciclando con tale iteratore si va a modificare la voce ``gruppo'' di tutti i contati che nella mia rubrica appartengono a tale gruppo (cosi facendo l'eliminazione del gruppo non porterà all'eliminazione dei contatti presenti in tale gruppo).
		\item dunque si esegue la chiamata:
		\verb|groupDAO.delete(group)|\\
		e si imposta \textit{result} a \inglese{true}.
	\end{itemize}
	Il metodo termina scrivendo su \textit{writer} il contenuto di \textit{result}.
	
\end{description}

%TODO da verificare

\classsection{AddressBookDoInsertInGroupServlet}

\subsubsection*{Funzione}
\inglese{Servlet} richiamata dal \textit{client} per inserire un utente nella propria rubrica, all'interno di un gruppo ben determinato.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doPost()}. Usata per scrivere l'output della \inglese{servlet}.
	\item \texttt{javax.servlet.ServletException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{javax.servlet.http.HttpServlet}: classe estesa da \classname{LoginManager}.
	\item \texttt{javax.servlet.http.HttpServletRequest}:  classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in ingresso alla \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in uscita dalla chiamata a \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpSession}: classe usata per definire una sessione HTTP.
	\item \classname{abook.IAddressBookEntry}:Interfaccia che definisce il comportamento di una generica \inglese{entry} della rubrica utente. La classe che verrà descritta crea istanze di tipo \classname{abook.IAddressBookEntry}.
	\item \classname{abook.IGroup}:
Interfaccia che definisce il comportamento di un gruppo generico. La classe che qui si descrive crea istanze di tipo \classname{abook.IGroup}.
	\item \classname{abook.IUserData}:Interfaccia che definisce il comportamento di un utente generico. La classe che qui si descrive crea istanze di tipo \classname{abook.IUserData}.
	\item \classname{abook.AddressBookEntry}: classe usata per comunicare tramite \textit{Hibernate} con la tabella AddressBookEntry della base di dati.
	\item \classname{dao.GroupDAO}: classe usata per comunicare tramite \textit{Hibernate} con la tabella Group della base di dati.
	\item \classname{dao.UserDataDAO}: classe usata per comunicare tramite \textit{Hibernate} con la tabella UserData della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{\underline{-- \{frozen\} serialVersionUID: long}}}
	Attributo contenente l'id per la serializzazione dei dati, il valore di creazione deve essere \texttt{10015L}.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ AddressBookDoInsertInGroupServlet()}}\\
	Costruttore pubblico della \inglese{servlet}, richiama il costruttore della classe padre (chiamata a \texttt{super}).
	
	\item{\method{\# doGet(request HttpServletRequest, response HttpServletResponse): void}}\\
	Metodo usato per eseguire la richiesta di aggiungere un contatto in un gruppo (eseguito in risposta ad una richiesta HTTP con metodo \texttt{GET}). Poiché si intende gestire in modo univoco una richiesta a tale \inglese{servlet} (indifferentemente dalla tipologia d'invio dati) il metodo reindirizza il flusso principale al metodo \method{doPost()}.
	
	\item{\method{\# doPost(request HttpServletRequest, response HttpServletResponse): void}}\\	
	Metodo usato per eseguire la richiesta di aggiungere un contatto in un gruppo (eseguito in risposta ad una richiesta HTTP con metodo \texttt{POST}). Nell'ordine proposto, devono essere eseguite le seguenti operazioni:
	\begin{itemize}
		\item creazione di un istanza di \classname{GroupDAO} denominata groupDAO;
		\item creazione di una sessione \texttt{HttpSession} avente nome session;
		\item creazione degli oggetti rappresentanti la realtà della rubrica su cui opero: un \texttt{IAddressBookEntry} entry, \texttt{IGroup} group, \texttt{IUserData} user e \texttt{IUserData} friend;
		\item creazione di due identificativi di tipo long: contactId e groupId.
		\item creazione di un \texttt{PrintWriter} denominato \textit{writer} e di una stringa \textit{result} usata con lo scopo di memorizzare il contenuto testuale da scrivere sul writer come messaggio di notifica della \inglese{servlet};
		\item creazione di un istanza \texttt{UserDataDAO} userDAO.
	\end{itemize}
	Dopo questa fase di creazione delle variabili il metodo deve definire un costrutto \textit{try-catch}. All'interno del blocco catch dovrà essere predisposta la memorizzazione della parola ``\inglese{false}''. Passando invece alla definizione del blocco \textit{try}, al suo interno si dovranno predisporre le seguenti istruzioni:
	\begin{itemize}
		\item inizializzazione di session al valore ottenuto da una chiamata:\\
		\verb|request.getSession(false)|
		\item istanziazione di user a partire dal valore contenuto nella \textit{request}. Per la precisione si dovrà usare un istruzione del tipo:\\
		\verb|session.getAttribute("user")|
		\item con una procedura analoga alla precedente definisco il contenuto di contactID. Usare \verb|getParameter("contactId")| a partire dall'oggetto \textit{request};
		\item istruzione analoga alla precedente usata per istanziare il contenuto di groupId (nome del parametro da ottenere: groupId);
		\item inizializzare friend con una chiamata \method{getById} passando come parametro contactId.
		\item inizializzare group con una chiamata \method{getById} passando come parametro groupId.
		\item il metodo controlla se \texttt{group!=null}. Nel caso il flusso principale prosegue come segue: inizializzazione di \textit{entry} e modifica dei dati stessi di \textit{entry} mediante le chiamate a metodo dei vari ``set'' che la costituiscono. Nello specifico si intende impostare l'istanza in modo che definisca un contatto in rubrica non bloccato e registrato nel gruppo \textit{group}. Il possessore sarà user e il contatto registrato friend. Quindi viene eseguito l'\inglese{update} tramite una chiamata:\\
		\verb|userDAO.update(user)|
		result viene impostato a \textit{true} e il programma esce dal costrutto condizionale.
		\item se \textit{group} non era diverso da \textit{null} allora si entra nel ramo else del costrutto condizionale già citato. Result viene impostato a false e il metodo esce dal ramo else.
	\end{itemize}
	Il metodo termina scrivendo su \textit{writer} il contenuto di \textit{result}.
	
\end{description}

%TODO da verificare

\classsection{AddressBookDoRemoveFromGroupServlet}

\subsubsection*{Funzione}
\inglese{Servlet} richiamata dal \textit{client} per inserire un utente nella propria rubrica, all'interno di un gruppo ben determinato.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doPost()}. Usata per scrivere l'output della \inglese{servlet}.
	\item \texttt{javax.servlet.ServletException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{javax.servlet.http.HttpServlet}: classe estesa da \classname{LoginManager}.
	\item \texttt{javax.servlet.http.HttpServletRequest}:  classe usata per la comunicazione con la \inglese{servlet} (inoltra i dati in ingresso alla \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in uscita dalla chiamata a \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpSession}: classe usata per definire una sessione HTTP.
	\item \classname{abook.IAddressBookEntry}:Interfaccia che definisce il comportamento di una generica \inglese{entry} della rubrica utente. La classe che verrà descritta crea istanze di tipo \classname{abook.IAddressBookEntry}.
	\item \classname{abook.IGroup}:
Interfaccia che definisce il comportamento di un gruppo generico. La classe che verrà descritta crea istanze di tipo \classname{abook.IGroup}.
	\item \classname{abook.IUserData}:Interfaccia che definisce il comportamento di un utente generico. La classe che verrà descritta crea istanze di tipo \classname{abook.IUserData}.
	\item \classname{abook.AddressBookEntry}: classe usata per comunicare tramite \textit{Hibernate} con la tabella AddressBookEntry della base di dati.
	\item \classname{dao.GroupDAO}: classe usata per comunicare tramite \textit{Hibernate} con la tabella Group della base di dati.
	\item \classname{dao.UserDataDAO}: classe usata per comunicare tramite \textit{Hibernate} con la tabella UserData della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{\underline{-- \{frozen\} serialVersionUID: long}}}
	Attributo contenente l'id per la serializzazione dei dati. Il valore di creazione deve essere \texttt{10014L}.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ AddressBookDoRemoveFromGroupServlet()}}\\
	Costruttore pubblico della \inglese{servlet}. Richiama il costruttore della classe padre (chiamata a \texttt{super}).
	
	\item{\method{\# doGet(request HttpServletRequest, response HttpServletResponse): void}}\\
	Metodo usato per eseguire la richiesta di rimuovere un contatto da un gruppo (eseguito in risposta ad una richiesta HTTP con metodo \texttt{GET}). Poiché si intende gestire in modo univoco una richiesta a tale \inglese{servlet} (indifferentemente dalla tipologia d'invio dati) il metodo reindirizza il flusso principale al metodo \method{doPost()}.
	
	\item{\method{\# doPost(request HttpServletRequest, response HttpServletResponse): void}}\\	
	Metodo usato per eseguire la richiesta di rimuovere un contatto da un gruppo (eseguito in risposta ad una richiesta HTTP con metodo \texttt{POST}). Nell'ordine proposto, devono essere eseguite le seguenti operazioni:
	\begin{itemize}
		\item creazione degli oggetti necessari al completamento dell'operazione:
		\begin{itemize}
			\item \classname{GroupDAO} groupDAO;
			\item \texttt{HttpSession} session;
			\item \classname{IAddressBookEntry} entry;
			\item \classname{IGroup} group;
			\item \classname{IUserData} friend;
			\item \classname{IUserData} user;
			Long contactIdl;
			Long groupId;
			\item \classname{PrintWriter} writer;
			String result;
			\item \classname{UserDataDAO} userDAO;
		\end{itemize}
		
		\item quindi il metodo procede definendo un blocco \textit{try-catch}. Nel ramo \textit{catch} si imposta \textit{result} a \inglese{false}. Passando invece alla definizione del ramo \textit{try}, in esso devono essere definiti i seguenti punti:
		\begin{itemize}
			\item session viene impostato mediante una chiamata a metodo:
			\verb|request.getSession(false)|;
			\item user e groupID vengono impostate ottenendo l'omonimo attributo da \textit{request} (usare il metodo \texttt{getParameter(nome\_parametro)};
			\item impostare friend e group a partire dai relativi tipi di istanze DAO e facendosi restituire i dati presenti nel database tramite una chiamata a metodo \method{getByID} a cui passa i relativi id (contactId e groupid);
			\item avvia un costrutto condizionale dotato di ramo \textit{else}, se \texttt{group!=null} allora il metodo procede nel ramo \textit{if} andando ad impostare \textit{entry} con i relativi parametri, in modo da ricreare l'istanza \classname{IAddressBookEntry} da rimuovere dal database per mezzo del metodo \method{removeAddressBookEntry()} a cui passa \textit{entry}. 
			\item altrimenti, se \texttt{group == null} allora entra nel ramo else del costrutto condizionale e procede impostando \textit{result} a \inglese{false}.
		\end{itemize}
	\end{itemize}
	Il metodo termina scrivendo su \textit{writer} il contenuto di \textit{result}.
	
\end{description}

%TODO da verificare

\classsection{AddressBookDoBlockServlet}

\subsubsection*{Funzione}
\inglese{Servlet} richiamata dal \inglese{client} per bloccare un contatto presente nella propria rubrica.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doPost()}. Usata per scrivere l'output della \inglese{servlet}.
	\item \texttt{javax.servlet.ServletException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{javax.servlet.http.HttpServlet}: classe estesa da \classname{LoginManager}.
	\item \texttt{javax.servlet.http.HttpServletRequest}:  classe usata per la comunicazione con la \inglese{servlet} (inoltra i dati in ingresso alla \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in uscita dalla chiamata a \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpSession}: classe usata per definire una sessione HTTP.
	\item \classname{abook.IAddressBookEntry}:Interfaccia che definisce il comportamento di una generica \inglese{entry} della rubrica utente. La classe che verrà descritta crea istanze di tipo \classname{abook.IAddressBookEntry}.
	\item \classname{abook.IUserData}:Interfaccia che definisce il comportamento di un utente generico. La classe che verrà descritta crea istanze di tipo \classname{abook.IUserData}.
	\item \classname{dao.UserDataDAO}: classe usata per comunicare tramite \textit{Hibernate} con la tabella UserData della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{\underline{-- \{frozen\} serialVersionUID: long}}}
	Attributo contenente l'id per la serializzazione dei dati, il valore di creazione deve essere \texttt{10014L}.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ AddressBookDoRemoveFromGroupServlet()}}\\
	Costruttore pubblico della \inglese{servlet}. Richiama il costruttore della classe padre (chiamata a \texttt{super}).
	
	\item{\method{\# doGet(request HttpServletRequest, response HttpServletResponse): void}}\\
	Metodo usato per eseguire la richiesta di bloccare un contatto presente in una rubrica utente (eseguito in risposta ad una richiesta HTTP con metodo \texttt{GET}). Poiché si intende gestire in modo univoco una richiesta a tale \inglese{servlet} (indifferentemente dalla tipologia d'invio dati) il metodo reindirizza il flusso principale al metodo \method{doPost()}.
	
	\item{\method{\# doPost(request HttpServletRequest, response HttpServletResponse): void}}\\	
	Metodo usato per eseguire la richiesta di bloccare un contatto presente in una rubrica utente (eseguito in risposta ad una richiesta HTTP con metodo \texttt{POST}). Nell'ordine proposto, devono essere eseguite le seguenti operazioni:
	\begin{itemize}
		\item creazione degli oggetti necessari al completamento dell'operazione:
		\begin{itemize}
			\item \classname{GroupDAO} groupDAO;
			\item \texttt{HttpSession} session;
			\item \classname{IAddressBookEntry} entry;
			\item \classname{IUserData} friend;
			\item \classname{IUserData} user;
			Long contactIdl;
			\item \texttt{Iterator<IAddressBookEntry>} iterator;
			\item \texttt{Set<IAddressBookEntry>} entrys;
			\item \classname{PrintWriter} writer;
			String result;
			\item \classname{UserDataDAO} userDAO;
		\end{itemize}
		
		\item quindi il metodo procede definendo un blocco \textit{try-catch}. Nel ramo \textit{catch} si imposta \textit{result} a \inglese{false}. Passando invece alla definizione del ramo \textit{try} devono essere definiti i seguenti punti:
		\begin{itemize}
			\item \textit{session} viene impostato mediante una chiamata a metodo:
			\verb|request.getSession(false)|;
			\item \textit{user} viene impostato ottenendo l'omonimo attributo da \textit{request} (usare il metodo \texttt{getParameter(``user'')};
			\item impostare \textit{friend} a partire dal relativo tipo di istanza DAO e facendo restituire i dati presenti nel database tramite una chiamata a metodo \method{getByID} a cui passa il parametro \textit{contactId};
			\item avvia un costrutto condizionale dotato di ramo else. Se \texttt{friend!=null} il metodo procede nel ramo \textit{if} andando a scaricare l'elenco delle \textit{entry} a partire da \textit{user}. Quindi utilizzando l'iteratore \textit{iterator} va a scorrere tale set di \textit{entry} e quando verifica la presenza del contatto \textit{friend} all'interno, modifica l'\textit{entry} attualmente selezionata richiamando il metodo \method{setBlocked(true)}. Quindi prima di uscire dal costrutto \textit{if}, viene eseguita un operazione di \textit{update} a partire da user e si memorizza nella variabile \textit{result} il valore \inglese{true}.
			\item altrimenti, se \texttt{friend == null} allora entra nel ramo else del costrutto condizionale e procede impostando \textit{result} a \inglese{false}.
		\end{itemize}
	\end{itemize}
	Il metodo termina scrivendo su \textit{writer} il contenuto di \textit{result}.
	
\end{description}

%TODO da verificare

\classsection{AddressBookDoUnblockServlet}

\subsubsection*{Funzione}
\inglese{Servlet} richiamata dal \textit{client} per sbloccare un contatto presente nella propria rubrica.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doPost()}. Usata per scrivere l'\textit{output} della \inglese{servlet}.
	\item \texttt{javax.servlet.ServletException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{javax.servlet.http.HttpServlet}: classe estesa da \classname{LoginManager}.
	\item \texttt{javax.servlet.http.HttpServletRequest}:  classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in ingresso alla \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per la comunicazione con la inglese{servlet} (inoltra i dati in uscita dalla chiamata a \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpSession}: classe usata per definire una sessione HTTP.
	\item \classname{abook.IAddressBookEntry}:Interfaccia che definisce il comportamento di una generica \inglese{entry} della rubrica utente. La classe che verrà descritta crea istanze di tipo \classname{abook.IAddressBookEntry}.
	\item \classname{abook.IUserData}:Interfaccia che definisce il comportamento di un utente generico. La classe che verrà descritta crea istanze di tipo \classname{abook.IUserData}.
	\item \classname{dao.UserDataDAO}: classe usata per comunicare tramite \textit{Hibernate} con la tabella UserData della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{\underline{-- \{frozen\} serialVersionUID: long}}}
	Attributo contenente l'id per la serializzazione dei dati, il valore di creazione deve essere \texttt{10019L}.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ AddressBookDoUnblockServlet()}}\\
	Costruttore pubblico della \inglese{servlet}, richiama il costruttore della classe padre (chiamata a \texttt{super}).
	
	\item{\method{\# doGet(request HttpServletRequest, response HttpServletResponse): void}}\\
	Metodo usato per eseguire la richiesta di sbloccare un contatto presente in una rubrica utente (eseguito in risposta ad una richiesta HTTP con metodo \texttt{GET}). Poiché si intende gestire in modo univoco una richiesta a tale \inglese{servlet} (indifferentemente dalla tipologia d'invio dati) il metodo reindirizza il flusso principale al metodo \method{doPost()}.
	
	\item{\method{\# doPost(request HttpServletRequest, response HttpServletResponse): void}}\\	
	Metodo usato per eseguire la richiesta di sbloccare un contatto presente in una rubrica utente (eseguito in risposta ad una richiesta HTTP con metodo \texttt{POST}). Nell'ordine proposto, devono essere eseguite le seguenti operazioni:
	\begin{itemize}
		\item creazione degli oggetti necessari al completamento dell'operazione:
		\begin{itemize}
			\item \classname{GroupDAO} groupDAO;
			\item \texttt{HttpSession} session;
			\item \classname{IAddressBookEntry} entry;
			\item \classname{IUserData} friend;
			\item \classname{IUserData} user;
			Long contactIdl;
			\item \texttt{Iterator<IAddressBookEntry>} iterator;
			\item \texttt{Set<IAddressBookEntry>} entrys;
			\item \classname{PrintWriter} writer;
			String result;
			\item \classname{UserDataDAO} userDAO;
		\end{itemize}
		
		\item quindi il metodo procede definendo un blocco \textit{try-catch}. Nel ramo \textit{catch} si imposta \textit{result} a \inglese{false}. Passando invece alla definizione del ramo \textit{try}, in esso devono essere definiti i seguenti punti:
		\begin{itemize}
			\item \textit{session} viene impostato mediante una chiamata a metodo:
			\verb|request.getSession(false)|;
			\item user viene impostata ottenendo l'omonimo attributo da \textit{request} (usare il metodo \texttt{getParameter(``user'')};
			\item impostare\textit{friend} a partire dal relativo tipo di istanza DAO e facendo restituire i dati presenti nel database tramite una chiamata a metodo \method{getByID} a cui passa il parametro \textit{contactId};
			\item avvia un costrutto condizionale dotato di ramo else. Se \texttt{friend!=null} il metodo procede nel ramo \textit{if} andando a scaricare l'elenco delle \textit{entry} a partire da \textit{user}. Quindi utilizzando l'iteratore \textit{iterator} va a scorrere tale set di \textit{entry} e quando verifica la presenza del contatto \textit{friend\textit} all'interno, modifica l'\textit{entry} attualmente selezionata richiamando il metodo \method{setBlocked(false)}. Quindi prima di uscire dal costrutto \textit{if}, viene eseguita un operazione di \textit{update} a partire da \textit{user} e si memorizza nella variabile \textit{result} il valore \inglese{true}.
			\item altrimenti, se \texttt{friend == null} allora entra nel ramo else del costrutto condizionale e procede impostando \textit{result} a \inglese{false}.
		\end{itemize}
	\end{itemize}
	Il metodo termina scrivendo su \textit{writer} il contenuto di \textit{result}.
	
\end{description}

%TODO da verificare

\classsection{AddressBookDoSearchServlet}

\subsubsection*{Funzione}
\inglese{Servlet} richiamata dal \textit{client} per effettuare una ricerca sulla propria rubrica. La ricerca consiste nell'individuare tutti i contatti che contengono nei campi \textit{name}, \textit{surname} o \textit{email} la parola ricercata. Per eseguire questa procedura di ricerca ci si avvale del metodo \method{searchGeneric(nome\_parametro)} della classe \classname{UserDataDAO}.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doPost()}. Usata per scrivere l'output della \inglese{servlet}.
	\item \texttt{java.util.List}: usata per memorizzare la lista di \classname{IUserData} da restituire in seguito alla richiesta di ricerca.
	\item \texttt{javax.servlet.ServletException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{javax.servlet.http.HttpServlet}: classe estesa da \classname{LoginManager}.
	\item \texttt{javax.servlet.http.HttpServletRequest}:  classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in ingresso alla \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in uscita dalla chiamata a \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpSession}: classe usata per definire una sessione HTTP.
	\item \classname{abook.IUserData}:Interfaccia che definisce il comportamento di un utente generico. La classe che verrà descritta crea istanze di tipo \classname{abook.IUserData}.
	\item \classname{dao.UserDataDAO}: classe usata per comunicare tramite \textit{Hibernate} con la tabella UserData della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{\underline{-- \{frozen\} serialVersionUID: long}}}
	Attributo contenente l'id per la serializzazione dei dati, il valore di creazione deve essere \texttt{100110L}.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ AddressBookDoSearchServlet()}}\\
	Costruttore pubblico della \inglese{servlet}, richiama il costruttore della classe padre (chiamata a \texttt{super}).
	
	\item{\method{\# doGet(request HttpServletRequest, response HttpServletResponse): void}}\\
	Metodo usato per eseguire una ricerca generica sui contatti presenti nella rubrica del \textit{client} (eseguito in risposta ad una richiesta HTTP con metodo \texttt{GET}). Poiché si intende gestire in modo univoco una richiesta a tale \inglese{servlet} (indifferentemente dalla tipologia d'invio dati) il metodo reindirizza il flusso principale al metodo \method{doPost()}.
	
	\item{\method{\# doPost(request HttpServletRequest, response HttpServletResponse): void}}\\	
	Metodo usato per eseguire una ricerca generica sui contatti presenti nella rubrica del \textit{client} (eseguito in risposta ad una richiesta HTTP con metodo \texttt{POST}). Nell'ordine proposto, devono essere eseguite le seguenti operazioni:
	\begin{itemize}
		\item creazione degli oggetti necessari al completamento dell'operazione:
		\begin{itemize}
			\item \classname{IUserData} entry;
			\item \texttt{List<IUserData>} users;
			\item \texttt{Iterator<IUserData>} iterator;
			\item \texttt{Set<IAddressBookEntry>} entrys;
			\item \classname{PrintWriter} writer;
			\item String result e String parameter;
			\item \classname{UserDataDAO} userDAO;
		\end{itemize}
		
		\item quindi il metodo procede definendo un blocco \textit{try-catch}. Nel ramo \textit{catch} si imposta \textit{result} a \inglese{false}. Passando invece alla definizione del ramo \textit{try}, in esso devono essere definiti i seguenti punti:
		\begin{itemize}
			\item parameter viene impostato con il valore del parametro da ricercare. Tale operazione è da eseguirsi con l'istruzione:\\
			\verb|request.getParameter("param")|;
			\item quindi il metodo procede effettuando la ricerca del parametro. Tale operazione si svolge sfruttando le specifiche della classe \classname{UserDataDAO}. Nello specifico deve essere eseguita l'istruzione:\\
			\verb|users = userDAO.searchGeneric(parameter)|;
			\item a questo punto si dovrà predisporre un iteratore per scorrere la lista \textit{users};
			\item si imposta \textit{result} al valore ``{'' e si entra in un ciclo \inglese{while} che potrà terminare solo quando l'iteratore già citato avrà raggiunto l'ultimo elemento ispezionabile;
			\item dentro al ciclo \inglese{while} si procederà con la formattazione della stringa \textit{result} al fine di restituire al \textit{client} un formato sul quale possa operare. Nello specifico la stringa \textit{result} dovrà contenere (per ogni istanza di IUserData presente in \textit{users}):\\
			
			\verb|\"ID_della_entry":{"name":"NOME_UTENTE",|\\
			\verb|"surname":"COGNOME_UTENTE,"email":EMAIL_UTENTE",|\\
			\verb|"id":"ID_UTENTE","picturePath":"PATH_IMG",|\\
			\verb|"state":"STATO","block":"BLOCCATO/SBLOCCATO"},|\\
			
			Si osservi che in quanto è riportato in precedenza, ciò che è scritto in maiuscolo corrisponde al valore effettivo di quel parametro, quindi per esempio la parola NOME\_UTENTE sarà di fatto sostituita dall'effettivo nome dell'istanza \classname{IUserData} attualmente sotto esame. Per ottenere tali valori ricorrerà ai metodi: \texttt{getName()}, \texttt{getSurname()}, \texttt{getMail()}, \texttt{getId()}, \texttt{getPath()} richiamabili a partire dall'\textit{entry} attualmente sotto esame.
			\item al termine di tale procedura la stringa \textit{result} è pronta per essere restituita al \textit{client}, quindi si aggiunge a \textit{result} il valore ``}'', usato come carattere di terminazione.
		\end{itemize}
	\end{itemize}
	Il metodo termina scrivendo su \textit{writer} il contenuto di \textit{result}.
	
\end{description}

%TODO da verificare

\classsection{AddressBookGetContactsServlet}

\subsubsection*{Funzione}
\inglese{Servlet} richiamata dal \textit{client} per scaricare la lista dei contatti presenti nella propria rubrica.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doPost()}. Usata per scrivere l'output della \inglese{servlet}.
	\item \texttt{java.util.Set}: usata per memorizzare l'insieme di \classname{IUserData} da restituire in seguito alla richiesta di ricerca.
	\item \texttt{javax.servlet.ServletException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{javax.servlet.http.HttpServlet}: classe estesa da \classname{LoginManager}.
	\item \texttt{javax.servlet.http.HttpServletRequest}:  classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in ingresso alla \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in uscita dalla chiamata a \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpSession}: classe usata per definire una sessione HTTP.
	\item \classname{abook.IAddressBookEntry}:Interfaccia che definisce il comportamento di una \inglese{entry} della rubrica utente.
	\item \classname{abook.IUserData}:Interfaccia che definisce il comportamento di un utente generico. La classe che verrà descritta crea istanze di tipo \classname{abook.IUserData}.
	\item \classname{dao.UserDataDAO}: classe usata per comunicare tramite Hibernate con la tabella UserData della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{\underline{-- \{frozen\} serialVersionUID: long}}}
	Attributo contenente l'id per la serializzazione dei dati, il valore di creazione deve essere \texttt{10010L}.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ AddressBookGetContactsServlet()}}\\
	Costruttore pubblico della \inglese{servlet}. Richiama il costruttore della classe padre (chiamata a \texttt{super}).
	
	\item{\method{\# doGet(request HttpServletRequest, response HttpServletResponse): void}}\\
	Metodo usato per eseguire la richiesta di download della lista dei contatti utente (eseguito in risposta ad una richiesta HTTP con metodo \texttt{GET}). Poiché si gestisce in modo univoco una richiesta a tale \inglese{servlet} (indifferentemente dalla tipologia d'invio dati) il metodo reindirizza il flusso principale al metodo \method{doPost()}.
	
	\item{\method{\# doPost(request HttpServletRequest, response HttpServletResponse): void}}\\	
	Metodo usato per eseguire la richiesta di download della lista dei contatti (eseguito in risposta ad una richiesta HTTP con metodo \texttt{POST}). Nell'ordine proposto, devono essere eseguite le seguenti operazioni:
	\begin{itemize}
		\item creazione degli oggetti necessari al completamento dell'operazione:
		\begin{itemize}
			\item \texttt{HttpSession} session;
			\item \classname{IUserData} user;
			\item \classname{IUserData} friend;
			\item \texttt{Iterator<IAddressBookEntry>} iterator;
			\item \texttt{Set<IAddressBookEntry>} entrys;
			\item \classname{PrintWriter} writer;
			\item String result;
			\item \classname{IAddressBookEntry} entry;
		\end{itemize}
		
		\item quindi il metodo procede definendo un blocco \textit{try-catch}. Nel ramo \textit{catch} si imposta \textit{result} a \inglese{null}. Passando invece alla definizione del ramo \textit{try}, devono essere definiti i seguenti punti:
		\begin{itemize}
			\item session viene impostata tramite una chiamata a metodo del tipo:\\
			\verb|session = request.getSession(false)|;
			\item quindi il metodo procede impostando user a partire dalla sessione precedentemente creata. Tale operazione richiede l'uso del metodo \method{getAttribute(``user''};
			\item viene inizializzato l'insieme \textit{contacts} tramite una chiamata \method{getAddressBook()} richiamata a partire dalla variabile \textit{user};
			\item a questo punto si dovrà predisporre un iteratore per scorrere l'insieme \textit{contacts};
			\item si imposta \textit{result} al valore ``{'' e si entra in un ciclo \inglese{while} che potrà terminare solo quando l'iteratore già citato avrà raggiunto l'ultimo elemento ispezionabile;
			\item dentro al ciclo \inglese{while}, dopo aver impostato \textit{entry} al valore \texttt{next()} dell'iteratore, viene salvato in friend il contatto ritornato da una chiamata a \textit{entry}.\method{getContact()}. Si procederà  poi con la formattazione della stringa result al fine di restituire al \textit{client} un formato sul quale possa operare. Nello specifico la stringa result dovrà contenere (per ogni istanza di IUserData presente in users):\\
			
			\verb|\"ID_della_entry":{"name":"NOME_UTENTE",|\\
			\verb|"surname":"COGNOME_UTENTE,"email":EMAIL_UTENTE",|\\
			\verb|"id":"ID_UTENTE","picturePath":"PATH_IMG",|\\
			\verb|"state":"STATO","block":"BLOCCATO/SBLOCCATO"},|\\
			
			Si osservi che in quanto è riportato in precedenza, ciò che è scritto in maiuscolo corrisponde al valore effettivo di quel parametro. Quindi per esempio la parola NOME\_UTENTE sarà di fatto sostituita dall'effettivo nome dell'istanza \classname{IUserData} attualmente sotto esame. Per ottenere tali valori si ricorre ai metodi: \texttt{getName()}, \texttt{getSurname()}, \texttt{getMail()}, \texttt{getId()}, \texttt{getPath()} richiamabili a partire da friend.
			\item al termine di tale procedura la stringa \textit{result} è pronta per essere restituita al \textit{client}. Quindi si aggiunge a \textit{result} il valore ``}'', usato come carattere di terminazione.
		\end{itemize}
	\end{itemize}
	Il metodo termina scrivendo su \textit{writer} il contenuto di \textit{result}.
	
\end{description}

%TODO da verificare

\classsection{AddressBookGetGroupsServlet}

\subsubsection*{Funzione}
\inglese{Servlet} richiamata dal \textit{client} per scaricare la propria rubrica, provvista di gruppi e contatti in essi presenti.

\subsubsection*{Relazioni d'uso}

\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doPost()}. Usata per scrivere l'output della \inglese{servlet}.
	\item \texttt{java.util.List}: usata per memorizzare l'insieme di \classname{IGroup} da restituire in seguito alla richiesta di ricerca.
	\item \texttt{java.util.Set}: usata per memorizzare l'insieme di \classname{IAddressBookEntry} da restituire in seguito alla richiesta di ricerca.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{javax.servlet.http.HttpServlet}: classe estesa da \classname{LoginManager}.
	\item \texttt{javax.servlet.http.HttpServletRequest}:  classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in ingresso alla \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in uscita dalla chiamata a \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpSession}: classe usata per definire una sessione HTTP.
	\item \classname{abook.IAddressBookEntry}:Interfaccia che definisce il comportamento di una \inglese{entry} della rubrica utente.
	\item \classname{abook.IUserData}:Interfaccia che definisce il comportamento di un utente generico. La classe che verrà descritta crea istanze di tipo \classname{abook.IUserData}.
		\item \classname{abook.IGroup}:Interfaccia che definisce il comportamento di un gruppo generico. La classe che verrà descritta crea istanze di tipo \classname{abook.IGroup}.
	\item \classname{dao.GroupDAO}: classe usata per comunicare tramite \textit{Hibernate} con la tabella Group della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{\underline{-- \{frozen\} serialVersionUID: long}}}
	Attributo contenente l'id per la serializzazione dei dati. Il valore di creazione deve essere \texttt{10010L}.
\end{itemize}

\subsubsection*{Metodi}

\begin{description}
	\item{\method{+ AddressBookGetContactsServlet()}}\\
	Costruttore pubblico della \inglese{servlet}. Richiama il costruttore della classe padre (chiamata a \texttt{super}).
	
	\item{\method{\# doGet(request HttpServletRequest, response HttpServletResponse): void}}\\
	Metodo usato per eseguire la richiesta di download della rubrica di un utente (eseguito in risposta ad una richiesta HTTP con metodo \texttt{GET}). Poiché si intende gestire in modo univoco una richiesta a tale \inglese{servlet} (indifferentemente dalla tipologia d'invio dati) il metodo reindirizza il flusso principale al metodo \method{doPost()}.
	
\item{\method{\# doPost(request HttpServletRequest, response HttpServletResponse): void}}\\	
	Metodo usato per eseguire la richiesta di download della lista dei contatti utente (eseguito in risposta ad una richiesta HTTP con metodo \texttt{POST}). Nell'ordine proposto, devono essere eseguite le seguenti operazioni:
	\begin{itemize}
		\item creazione degli oggetti necessari al completamento dell'operazione:
		\begin{itemize}
			\item \texttt{HttpSession} session;
			\item \classname{GroupDAO} groupDAO;
			\item \classname{IAddressBookEntry} entry;
			\item \classname{IGroup} group;
			\item \classname{IUserData} user;
			\item \texttt{Iterator<IAddressBookEntry>} entryIter;
			\item \texttt{Iterator<IGroup>} groupIter;
			\item \texttt{Set<IAddressBookEntry>} addentrys;
			\item \classname{PrintWriter} writer;
			\item String result;
		\end{itemize}
		
		\item quindi il metodo procede definendo un blocco \textit{try-catch}. Nel ramo catch si imposta \textit{result} a \inglese{false}. Passando invece alla definizione del ramo \textit{try}, in esso devono essere definiti i seguenti punti:
		\begin{itemize}
			\item session viene impostata tramite una chiamata a metodo del tipo:\\
			\verb|session = request.getSession(false)|;
			\item quindi il metodo procede impostando user a partire dalla sessione precedentemente creata. Tale operazione richiede l'uso del metodo \method{getAttribute(``user'')};
			\item viene inizializzato l'oggetto groupDAO;
			\item si inizializza la lista groups dei gruppi. Tale operazione deve essere eseguita mediante l'istruzione:\\
			\verb|groupDAO.getByOwner(user.getId())|
			\item il metodo definisce un costrutto condizionale \textit{if-else} basato sulla condizione \texttt{groups != null}. Nel ramo \textit{else} il metodo non fa altro che impostare \textit{result} a \inglese{false}. Nel ramo \textit{if} saranno definite le seguenti istruzioni:	
			\begin{itemize}
				\item predisporre un iteratore per scorrere l'insieme groups (inizializzazione di groupIter);
				\item si imposta \textit{result} al valore ``\{'' e si entra in un ciclo \inglese{while} che potrà terminare solo quando l'iteratore già citato avrà raggiunto l'ultimo elemento ispezionabile;
				\item all'interno del ciclo si estrae dall'iteratore il gruppo attualmente in esame e si salva sull'oggetto group;
				\item a partire da group, tramite una chiamata \method{getAddressBook()}, si ottiene la lista di entry di quel gruppo e la si slava in addEntry;
				\item si definisce un nuovo iteratore addEntry.\method{iterator()} e lo si memorizza in entryIter;
				\item si ``scrive'' dentro a \textit{result}, i dati inerenti il gruppo in esame (name, id) e si aggiunge la stringa ``contacts:['';
				\item si entra in un nuovo ciclo \inglese{while} che cicla sulle \textit{entry} dell'iteratore entryIter. All'interno di tale ciclo si estraggono le \textit{entry} che costituiscono i contatti del gruppo in esame e si riporta in result l'id di tali contatti (usare metodo \method{getId()});
				\item all'uscita del ciclo \inglese{while} più interno si concatena al contenuto di \textit{result} la stringa ``]\}'';
				\item all'uscita del ciclo \inglese{while} più esterno si concatena al contenuto di \textit{result} la stringa ``\}'';
			\end{itemize}
		\end{itemize}
	\end{itemize}
	Il metodo termina scrivendo su \textit{writer} il contenuto di \textit{result}.	
	
\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.call}\label{sec:call}

\classsection{ICall}

\subsubsection*{Funzione}
Interfaccia che rappresenta una chiamata effettuata dal sistema \caName. Gli oggetti che implementano tale interfaccia vengono usati per rappresentare lo storico delle chiamate di un utente.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.util.Date}: tipo utilizzato per definire la data d'inizio e fine di una chiamata.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce l'identificativo univoco della chiamata.
	\item{\method{+ getStartDate(): Date}}\\
	Restituisce un istanza di \texttt{java.util.Date} di avvio della chiamata.
	\item{\method{+ setStartDate(startDate: Date): void}}\\
	Imposta la data di avvio della chiamata.
	\item{\method{+ getEndDate(): Date}}\\
	Restituisce la data in cui termina la chiamata
	\item{\method{+ setEndDate(endDate: Date): void}}\\
	Imposta la data in cui termina la chiamata.
\end{description}

\classsection{Call}

\subsubsection*{Funzione}
Classe che implementa l'interfaccia \classname{ICall}.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.util.Date}: tipo utilizzato per definire la data d'inizio e fine di una chiamata.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \classname{ICall} interfacci d'implementazione.
\end{itemize}

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{-- id: long}}
	Attributo contenente il codice identificativo della chiamata.
	\item{\memberdata{-- startDate: Date}}
	Attributo di tipo \texttt{java.util.Date} contenente la data (compresa l'ora) d'inizio della chiamata.
	\item{\memberdata{-- endDate: Date}}
	Attributo di tipo \texttt{java.util.Date} contenente la data (compresa l'ora) in cui la chiamata è terminata.
\end{itemize}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce l'identificativo univoco della chiamata ritornando il contenuto dell'attributo \memberdata{id}.
	\item{\method{+ getStartDate(): Date}}\\
	Restituisce il contenuto del campo \memberdata{startDate}.
	\item{\method{+ setStartDate(startDate: Date): void}}\\
	Imposta la data di avvio della chiamata, sovrascrivendo il contenuto \memberdata{startData}.
	\item{\method{+ getEndDate(): Date}}\\
	Restituisce il contenuto del campo \memberdata{endDate}.
	\item{\method{+ setEndDate(endDate: Date): void}}\\
	Imposta la data di avvio della chiamata, sovrascrivendo il contenuto \memberdata{endData}.
\end{description}

\classsection{ICallList}

\subsubsection*{Funzione}
Interfaccia rappresentante una \textit{entry} di uno storico chiamate di un utente del sistema mytalk.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \classname{IUserData}: l'interfaccia \classname{ICallList} definisce più metodi che restituiscono oggetti aventi tipo di ritorno \classname{IUserData}, essi sono i metodi \inglese{get} per ottenere l'utente che ha effettuato la chiamta. Analogamente \classname{IUserData} viene usato come parametro d'ingresso per i metodi \inglese{set} collegati ai metodi già citati.
	\item \classname{ICall}: l'interfaccia \classname{ICallList} definiscono metodi che restituiscono oggetti aventi tipo di ritorno \classname{ICall}.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{org.softwaresynthesis.mytalk.server.IMyTalkObject}: interfaccia da estendere. Ogni oggetto che implementerà l'interfaccia \classname{ICallList} dovrà essere in grado di convertire il proprio contenuto informativo in formato \textit{Json}.
\end{itemize}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce l'identificativo univoco di una \inglese{entry} di uno storico chiamate.
	
	\item{\method{+ setIdCall(call: ICall): void}}\\
	Imposta l'id della chiamta \classname{ICall} (passato come parametro d'ingresso).
	\item{\method{+ getIdCall(): IUserData}}\\
	Restituisce un id di un oggetto avente tipo \classname{ICall} rappresentante una chiamata effettuata dall'utente.
	
	\item{\method{+ setIdUser(contact: IUserData): void}}\\
	Imposta l'id dell'utente \classname{IUserData} (passato come parametro d'ingresso) come l'utente che ha effettuato la chiamata.
	\item{\method{+ getIdUser(): IUserData}}\\
	Restituisce l'id di oggetto avente tipo \classname{IUserData} rappresentante l'utente che ha effettuato la chiamata.
	
	\item{\method{+ setCaller(caller: boolean): void}}\\
	Imposta l'utente che ha effettuato la chiamata come chiamante se il parametro ricevuto ha valore true.
	\item{\method{+ getCaller(): boolean}}\\
	Ritorna un valore di tipo bool se l'utente della chiamata è colui che l'ha iniziata o meno.
\end{description}




\classsection{CallList}

\subsubsection*{Funzione}
Classe che implementa l'interfaccia \classname{ICallList}.

\subsubsection*{Relazioni d'uso}

Nessuna relazione evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{call.ICallList}: interfaccia implementata dalla classe.
\end{itemize}

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{-- id: long}}
	Attributo contenente il codice identificativo dello storico chiamata.
	\item{\memberdata{-- idCall: long}}
	Attributo contenente il codice identificativo della chiamata.
	\item{\memberdata{-- idUser: long}}
	Attributo contenente il codice identificativo dell'utente partecipante alla chiamata.
	\item{\memberdata{-- caller: boolean}}
	Attributo che identifica se l'utente è il chiamante o meno.
\end{itemize}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce il valore dell'attributo \memberdata{id}.
	
	\item{\method{+ setIdCall(call: Long): void}}\\
	Imposta il valore dell'attributo \memberdata{idCall} con il valore ricevuto da parametro ``call''.
	\item{\method{+ getIdCall(): Long}}\\
	Restituisce il valore dell'attributo \memberdata{idCall}.
	
	\item{\method{+ setIdUser(contact: Long): void}}\\
	Imposta il valore dell'attributo \memberdata{idUser} con il valore ricevuto da parametro ``contact''.
	\item{\method{+ getIdUser(): Long}}\\
	Restituisce il valore dell'attributo \memberdata{idUser}.
	
	\item{\method{+ setCaller(caller: boolean): void}}\\
	Imposta il valore dell'attributo \memberdata{caller} con il valore ricevuto da parametro ``caller''.
	\item{\method{+ getCaller(): boolean}}\\
	Restituisce il valore dell'attributo \memberdata{caller}.
\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.call.servlet}\label{sec:callServlet}

\classsection{DownloadCallHistoryServlet}

\subsubsection*{Funzione}
\inglese{Servlet} da richiamare per effettuare il download della lista che rappresenta lo storico delle chiamate effettuate e ricevute dell'utente. I dati vengono ritornati sotto forma di stringa in formato JSON.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doPost()}. Usata per scrivere l'output della \inglese{servlet}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}:  classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in ingresso alla \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in uscita dalla chiamata a \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpSession}: classe usata per definire una sessione HTTP.
	\item \classname{call.ICall}: usata per definire un oggetto rappresentante una chiamata.
	\item \classname{abook.IUserData}: usata per definire un utente generico, che ha partecipato alla chiamata.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
		\item \texttt{javax.servlet.http.HttpServlet}: classe estesa da \classname{DownloadCallHistoryServlet}.
\end{itemize}

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{\underline{-- {frozen} serialVersionUID: long}}}\\
  Utilizzato come ID univoco per identificare un oggetto serializzabile. Tale ID deve essere impostato al valore 10021L.
\end{description}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ DownloadCallHistoryServlet()}}\\
	Costruttore della classe. Richiama il costruttore della classe padre \texttt{HttpServlet}.
	
	\item{\method{\# doGet(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Metodo di delega che richiama \method{doPost()} passando gli stessi dati in input.
	
	\item{\method{\# doPost(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Metodo usato per accedere alla funzionalità della \inglese{servlet}. Il procedimento da definire passa attraverso 3 step essenziali:
	\begin{itemize}
		\item \texttt{Inizializzazione}: il metodo definisce ed apre una nuova sessione a partire dalla richiesta request passata come parametro;
		\item \texttt{Elaborazione dati}: il metodo interroga il database attraverso le classi DAO e per ogni oggetto \classname{ICall} in cui si evidenzia che uno dei due partecipanti è il client (\classname{IUserData}) che ha inoltrato la richiesta a tale \inglese{servlet}, viene aggiunta alla stringa result da ritornare, i dati di tale chiamata. Nello specifico la formattazione della stringa di ritorno, dovrà descrivere la seguente logica:\\
		
		\verb|{name:"NOME_UTENTE",start="DATA_INIZIO",end="DATA_FINE"}|\\
		
		Si consideri che la dove vi è un nome in maiuscolo, vi dovrà essere il dato inerente estrapolato dall'istanza \classname{ICall} presa in considerazione.
		\item \texttt{Restituzione risultato}: dopo aver elaborato i dati, la \inglese{servlet} dovrà scrivere nel \texttt{PrintWriter} associato alla request:
			\begin{itemize}
				\item una stringa formattata come sopra, se l'utente ha effettuato o ricevuto almeno una chimata;
				\item null, altrimenti.
			\end{itemize}
	\end{itemize}

\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.message}\label{sec:message}

\classsection{IMessage}

\subsubsection*{Funzione}
Interfaccia che rappresenta un messaggio di segreteria del sistema \caName.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.util.Date}: tipo utilizzato per definire la data in cui è stato registrato un messaggio.
	\item \classname{abook.IUserData}: usata per rappresentare il mittente e il destinatario del messaggio di segreteria.
\end{itemize}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce l'identificativo univoco del messaggio.
	\item{\method{+ getSender(): IUserData}}\\
	Restituisce un istanza di tipo classname{abook.IUserData} che rappresenta il mittente del messaggio.
	\item{\method{+ setSender(sender: IUserData): void}}\\
	Imposta il mittente del messaggio.
	\item{\method{+ getReceiver(): IUserData}}\\
	Restituisce un istanza di tipo classname{abook.IUserData} che rappresenta il destinatario del messaggio.
	\item{\method{+ setReceiver(receiver: IUserData): void}}\\
	Imposta il destinatario del messaggio.
	\item{\method{+ isNew(): boolean}}\\
	Restituisce un valore booleano che identifica lo stato del messaggio (``già letto'' se il valore ritornato è \textit{true}, ``da leggere'' se il valore ritornato è \textit{false}).
	\item{\method{+ setNew(status: boolean): void}}\\
	Imposta il messaggio come ``già ascoltato'' o come ``da ascoltare''.
	\item{\method{+ isVideo(): boolean}}\\
	Restituisce un booleano che determina se si tratta di un messaggio audio oppure audio-video.
	\item{\method{+ setVideo(video: boolean): void }}\\	
	Imposta il messaggio come messaggio audio-video o come messaggio contenente solamente una traccia audio.
	\item{\method{+ getDate(): Date}}\\
	Restituisce la data in cui il mittente ha lasciato il messaggio nella segreteria del destinatario.
	\item{\method{+ setDate(date: Date): void}}\\
	Imposta la data in cui il mittente ha lasciato il messaggio nella segreteria del destinatario.
\end{description}

\classsection{Message}

\subsubsection*{Funzione}
Classe che implementa l'interfaccia \classname{IMessage}.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.util.Date}: tipo utilizzato per definire la data in cui è stato registrato un messaggio.
	\item \classname{abook.IUserData}: usata per rappresentare il mittente e il destinatario del messaggio di segreteria.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \classname{message.IMessage}: interfaccia d'implementazione.
\end{itemize}

\subsubsection*{Attributi}

\begin{itemize}
	\item{\memberdata{-- id: long}}
	Attributo contenente il codice identificativo del messaggio.
	\item{\memberdata{-- sender: IUserData}}
	Attributo contenente lo \classname{IUserData} che rappresenta il destinatario del messaggio.
	\item{\memberdata{-- receiver: IUserData}}
	Attributo contenente lo \classname{IUserData} che rappresenta il destinatario del messaggio.
	\item{\memberdata{-- status: boolean}}
	Attributo contenente un valore booleano che identifica se il messaggio è stato visionato/ascoltato o meno. L'attributo se impostato a \textit{true}, designa il messaggio come \textit{ascoltato}. Invece se impostato a \textit{false} identifica il messaggio come \textit{ancora da ascoltare}.
	\item{\memberdata{-- video: boolean}}
	Attributo che stabilisce se il messaggio contiene o meno una traccia video. Si ricorda che ogni messaggio contiene (di \inglese{default}) una traccia audio. Se tale attributo è impostato a \textit{true} allora il messaggio contiene una traccia video.
	\item{\memberdata{-- date: Date}}
	Attributo che definisce l'orario di invio del messaggio.
\end{itemize}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ getId(): Long}}\\
	Restituisce l'identificativo univoco del messaggio, ritornando il contenuto di \memberdata{id}.
	\item{\method{+ getSender(): IUserData}}\\
	Restituisce un istanza di tipo classname{abook.IUserData} che rappresenta il mittente del messaggio. Nello specifico il metodo ritorna l'attributo \memberdata{sender}.
	\item{\method{+ setSender(sender: IUserData): void}}\\
	Imposta il mittente del messaggio, sovrascrivendo il contenuto dell'attributo \memberdata{sender}.
	\item{\method{+ getReceiver(): IUserData}}\\
	Restituisce un istanza di tipo classname{abook.IUserData} che rappresenta il destinatario del messaggio. Nello specifico il metodo ritorna l'attributo \memberdata{receiver}.
	\item{\method{+ setReceiver(receiver: IUserData): void}}\\
	Imposta il destinatario del messaggio, sovrascrivendo il contenuto dell'attributo \memberdata{receiver}.
	\item{\method{+ isNew(): boolean}}\\
	Metodo che ritorna il contenuto dell'attributo \memberdata{status}.
	\item{\method{+ setNew(status: boolean): void}}\\
	Imposta il messaggio come ``già ascoltato'' o come ``da ascoltare'', sovrascrivendo il contenuto dell'attributo \memberdata{status}.
	\item{\method{+ isVideo(): boolean}}\\
	Restituisce il contenuto dell'attributo \memberdata{video}.
	\item{\method{+ setVideo(video: boolean): void }}\\	
	Metodo usato per impostare la ``natura'' del messaggio, impostando il contenuto dell'attributo \memberdata{video} mettendolo a \textit{true} se il messaggio contiene una traccia video, oppure a \textit{false} se non la contiene.
	\item{\method{+ getDate(): Date}}\\
	Restituisce la data in cui il mittente ha lasciato il messaggio nella segreteria del destinatario, ritornando il contenuto dell'attributo \memberdata{date}.
	\item{\method{+ setDate(date: Date): void}}\\
	Imposta la data in cui il mittente ha lasciato il messaggio nella segreteria del destinatario, sovrascrivendo il contenuto dell'attributo \memberdata{date}.

\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.message.servlet}\label{sec:messageServlet}

\classsection{InsertMessageServlet}

\subsubsection*{Funzione}
\inglese{Servlet} da richiamare per inserire un messaggio nella segreteria di un utente.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doPost()}. Usata per scrivere l'output della \inglese{servlet}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{javax.servlet.http.HttpServlet}: classe estesa da \classname{InsertMessageServlet}.
	\item \texttt{javax.servlet.http.HttpServletRequest}:  classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in ingresso alla \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in uscita dalla chiamata a \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpSession}: classe usata per definire una sessione HTTP.
	\item \classname{call.IMessage}: usata per definire un oggetto rappresentante un messaggio in segreteria.
	\item \classname{abook.IUserData}: usata per definire un utente generico, che ha partecipato alla chiamata.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{javax.servlet.http.HttpServlet}: classe estesa da \classname{InsertMessageServlet}.
\end{itemize}

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{\underline{-- {frozen} serialVersionUID: long}}}\\
  Utilizzato come ID univoco per identificare un oggetto serializzabile. Tale ID deve essere impostato al valore 10022L.
\end{description}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ InsertMessageServlet()}}\\
	Costruttore della classe. Richiama il costruttore della classe padre \texttt{HttpServlet}.
	
	\item{\method{\# doGet(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Metodo di delega che richiama \method{doPost()} passando gli stessi dati in input.
	
	\item{\method{\# doPost(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Metodo usato per accedere alla funzionalità della \inglese{servlet}. Il procedimento da definire passa attraverso 3 step essenziali:
	\begin{itemize}
		\item \texttt{Inizializzazione}: il metodo definisce ed apre una nuova sessione a partire dalla richiesta request passata come parametro;
		\item \texttt{Elaborazione dati}: il metodo procede creando un \classname{IMessage} con i dati forniti dalla request e dopo aver aperto una \texttt{transaction} verso il database, esegue l'operazione \method{save()} sul relativo oggetto DAO. Al termine sarà necessario procedere con un operazione di \texttt{commit}. Nel realizzare il metodo, il programmatore incaricato dovrà tenere in considerazione la possibilità di fallimento durante l'esecuzione delle operazioni mediante la \texttt{transaction}. Ciò andrà gestito mediante un operazione di \texttt{rollback} atta ad eliminare una possibile inconsistenza dei dati.
		\item \texttt{Restituzione risultato}: dopo aver elaborato i dati, la \inglese{servlet} dovrà scrivere nel \texttt{PrintWriter} associato alla request:
			\begin{itemize}
				\item ``\inglese{true}'' se l'operazione è andata a buon fine;
				\item ``\inglese{false}'' altrimenti.
			\end{itemize}
	\end{itemize}

\end{description}

\classsection{DeleteMessageServlet}

\subsubsection*{Funzione}
\inglese{Servlet} da richiamare per eliminare un messaggio nella segreteria dell'utente che la richiama.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doPost()}. Usata per scrivere l'output della \inglese{servlet}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}:  classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in ingresso alla \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in uscita dalla chiamata a \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpSession}: classe usata per definire una sessione HTTP.
	\item \classname{call.IMessage}: usata per definire un oggetto rappresentante un messaggio in segreteria.
	\item \classname{abook.IUserData}: usata per definire un utente generico, che ha partecipato alla chiamata.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{javax.servlet.http.HttpServlet}: classe estesa da \classname{DeleteMessageServlet}.
\end{itemize}

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{\underline{-- {frozen} serialVersionUID: long}}}\\
  Utilizzato come ID univoco per identificare un oggetto serializzabile. Tale ID deve essere impostato al valore 10022L.
\end{description}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ DeleteMessageServlet()}}\\
	Costruttore della classe. Richiama il costruttore della classe padre \texttt{HttpServlet}.
	
	\item{\method{\# doGet(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Metodo di delega che richiama \method{doPost()} passando gli stessi dati in input.
	
	\item{\method{\# doPost(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Metodo usato per accedere alla funzionalità della \inglese{servlet}. Il procedimento da definire passa attraverso 3 step essenziali:
	\begin{itemize}
		\item \texttt{Inizializzazione}: il metodo definisce ed apre una nuova sessione a partire dalla richiesta request passata come parametro;
		\item \texttt{Elaborazione dati}: il metodo procede creando un \classname{IMessage} con i dati forniti dalla request e dopo aver aperto una \texttt{transaction} verso il database, esegue un operazione di ricerca dell'instanza appena creata all'interno della lista di \classname{IMessage} ottenuta dal db. Quindi se si verifica che tale istanza è effettivamente presente nel database, il metodo esegue l'operazione \method{delete()} sul relativo oggetto DAO. Al termine sarà necessario procedere con un operazione di \texttt{commit}. Nel realizzare il metodo, il programmatore incaricato dovrà tenere in considerazione la possibilità di fallimento durante l'esecuzione delle operazioni mediante la \texttt{transaction}. Ciò andrà gestito mediante un operazione di \texttt{rollback} atta ad eliminare una possibile inconsistenza dei dati.
		\item \texttt{Restituzione risultato}: dopo aver elaborato i dati, la \inglese{servlet} dovrà scrivere nel \texttt{PrintWriter} associato alla request:
			\begin{itemize}
				\item ``\inglese{true}'' se l'operazione è andata a buon fine;
				\item ``\inglese{false}'' altrimenti (compreso non solo il caso di errore dovuto ad un problema di connessione verso il db, ma anche quello relativo al mancato match del elemento ricercato con quelli presenti nel database).
			\end{itemize}
	\end{itemize}

\end{description}

\classsection{UpdateStatusMessageServlet}

\subsubsection*{Funzione}
\inglese{Servlet} da richiamare per modificare lo stato di un messaggio. L'idea alla base è che un messaggio può trovarsi uno dei seguenti due stati:
\begin{itemize}
	\item letto;
	\item non letto;
\end{itemize}
La \inglese{servlet} permette di effettuare una transizione di stato da ``non letto'' a ``letto''.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doPost()}. Usata per scrivere l'output della \inglese{servlet}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}:  classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in ingresso alla \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in uscita dalla chiamata a \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpSession}: classe usata per definire una sessione HTTP.
	\item \classname{call.IMessage}: usata per definire un oggetto rappresentante un messaggio in segreteria.
	\item \classname{abook.IUserData}: usata per definire un utente generico, che ha partecipato alla chiamata.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{javax.servlet.http.HttpServlet}: classe estesa da \classname{UpdateStatusMessageServlet}.
\end{itemize}

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{\underline{-- {frozen} serialVersionUID: long}}}\\
  Utilizzato come ID univoco per identificare un oggetto serializzabile. Tale ID deve essere impostato al valore 10023L.
\end{description}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ UpdateStatusMessageServlet()}}\\
	Costruttore della classe. Richiama il costruttore della classe padre \texttt{HttpServlet}.
	
	\item{\method{\# doGet(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Metodo di delega che richiama \method{doPost()} passando gli stessi dati in input.
	
	\item{\method{\# doPost(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Metodo usato per accedere alla funzionalità della \inglese{servlet}. Il procedimento da definire passa attraverso 3 step essenziali:
	\begin{itemize}
		\item \texttt{Inizializzazione}: il metodo definisce ed apre una nuova sessione a partire dalla richiesta request passata come parametro;
		\item \texttt{Elaborazione dati}: il metodo procede creando un \classname{IMessage} con i dati forniti dalla request e dopo aver aperto una \texttt{transaction} verso il database, esegue un operazione di ricerca dell'instanza appena creata all'interno della lista di \classname{IMessage} ottenuta dal db. Quindi se si verifica che tale istanza è effettivamente presente nel database, il metodo esegue l'operazione \method{update()} sul relativo oggetto DAO, andando a modificare lo stato in di lettura del messaggio. Al termine sarà necessario procedere con un operazione di \texttt{commit}. Nel realizzare il metodo il programmatore incaricato dovrà tenere in considerazione la possibilità di fallimento durante l'esecuzione delle operazioni mediante la \texttt{transaction}. Ciò andrà gestito mediante un operazione di \texttt{rollback} atta ad eliminare una possibile inconsistenza dei dati.
		\item \texttt{Restituzione risultato}: dopo aver elaborato i dati, la \inglese{servlet} dovrà scrivere nel \texttt{PrintWriter} associato alla request:
			\begin{itemize}
				\item ``\inglese{true}'' se l'operazione è andata a buon fine;
				\item ``\inglese{false}'' altrimenti.
			\end{itemize}
	\end{itemize}

\end{description}

\classsection{DownloadMessageListServlet}

\subsubsection*{Funzione}
\inglese{Servlet} da richiamare per scaricare la lista di messaggi attualmente presenti nella propria segreteria.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doPost()}. Usata per scrivere l'output della \inglese{servlet}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}:  classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in ingresso alla \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in uscita dalla chiamata a \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpSession}: classe usata per definire una sessione HTTP.
	\item \classname{call.IMessage}: usata per definire un oggetto rappresentante un messaggio in segreteria.
	\item \classname{abook.IUserData}: usata per definire un utente generico, che ha partecipato alla chiamata.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{javax.servlet.http.HttpServlet}: classe estesa da \classname{DownloadMessageListServlet}.
\end{itemize}

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{\underline{-- {frozen} serialVersionUID: long}}}\\
  Utilizzato come ID univoco per identificare un oggetto serializzabile. Tale ID deve essere impostato al valore 10024L.
\end{description}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ DownloadMessageListServlet()}}\\
	Costruttore della classe. Richiama il costruttore della classe padre \texttt{HttpServlet}.
	
	\item{\method{\# doGet(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Metodo di delega che richiama \method{doPost()} passando gli stessi dati in input.
	
	\item{\method{\# doPost(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Metodo usato per accedere alla funzionalità della \inglese{servlet}. Il procedimento da definire passa attraverso 3 step essenziali:
	\begin{itemize}
		\item \texttt{Inizializzazione}: il metodo definisce ed apre una nuova sessione a partire dalla richiesta request passata come parametro;
		\item \texttt{Elaborazione dati}: quindi esegue un operazione di download degli oggetti \classname{IMessage} il cui possessore è l'utente che ha fatto richiesta di \inglese{download}. in seguito a tale operazione, sarà necessario popolare e formattare la stringa di ritorno come segue: per ogni messaggio presente nella lista si dovrà riportare la dicitura:\\
		
		\verb|{name:"NOME_UTENTE",state="LETTO/NON LETTO"|\\
		\verb|,url="INDIRIZZO_MESSAGGIO",data="DATA_REGISTRAZIONE_MESSAGGIO"}|\\
	
		\item \texttt{Restituzione risultato}: dopo aver elaborato i dati, la \inglese{servlet} dovrà scrivere nel \texttt{PrintWriter} associato alla request:
			\begin{itemize}
				\item la sequenza
				\item null, altrimenti.
			\end{itemize}
	\end{itemize}

\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.authentication}\label{sec:authentication}

\classsection{ISecurityStrategy}

\subsubsection*{Funzione}
Interfaccia che identifica il comportamento di una strategia generica di crittografia dei dati.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione d'uso evidenziata.

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ encrypt(plainText: String): String}}\\
	Cripta la stringa di testo ricevuta come parametro e la restituisce al chiamante.\\\\
	Il metodo può solleva eccezioni:
	\begin{itemize}
		\item \exception{IOException}: l'implementazione di tale metodo dovrà predisporre il lancio di un eccezione qualora il messaggio passato al metodo (plainText) sia vuoto.
	\end{itemize}
	\item{\method{+ decrypt(encryptedText: String)}}\\
	Decripta la stringa di testo ricevuta come parametro e la restituisce al chiamante.\\\\
	Il metodo può sollevare eccezioni:
	\begin{itemize}
		\item \exception{IOException}: l'implementazione di tale metodo dovrà predisporre il lancio di un eccezione qualora il messaggio passato al metodo (plainText) sia vuoto.
	\end{itemize}
\end{description}

\classsection{AESAlgorithm}

\subsubsection*{Funzione}
Implementazione della strategia di codifica/decodifica con l'uso dell'algoritmo AES a 128bit.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.security.Key}: usata per creare un istanza di una chiave durante il processo di criptazione.
	\item \texttt{javax.crypto.Cipher}: usata per creare un istanza di un oggetto di criptazione che implementa l'algoritmo AES a 128 bit.
	\item \texttt{javax.crypto.spec.SecretKeySpec}: usata dall'algoritmo di per costruire una chiave segreta a partire da un array di byte.
	\item \texttt{sun.misc.BASE64Encoder}: utilizzata per eseguire una trasformazione da stringa a byte.
	\item \texttt{sun.misc.BASE64Decoder}: utilizzata per eseguire una trasformazione da byte in stringa.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \classname{ISecurityStrategy}: interfaccia d'implementazione.
\end{itemize}

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{-- \{frozen\} \underline{keyValue}: byte[]}}\\
  Array di byte usato per definire il valore della chiave su cui si basa l'algoritmo AES di criptazione. La chiave effettiva sarà creata a partire da tale attributo, per mezzo della classe \texttt{javax.crypto.spec.SecretKeySpec}.
  \item{\memberdata{-- \{frozen\} \underline{algorithm}: String}}\\
  Stringa costante che identifica il nominativo dell'algoritmo usato, e che dovrà essere specificato durante l'uso di \texttt{javax.crypto.Cipher}. l'attributo avrà valore ``AES''.
\end{description}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{- generateKey(): Key}}\\
	Metodo che restituisce una chiave di tipo \texttt{java.security.Key}, a partire dall'array \memberdata{keyValue}. Per fare ciò, il metodo usa il costruttore di \texttt{javax.crypto.spec.SecretKeySpec}.
	Il metodo può sollevare eccezioni:
	\begin{itemize}
		\item \exception{Exception}: il metodo può sollevare un'eccezione generica.
	\end{itemize}
	\item{\method{+ encrypt(plainText: String): String}}\\
	Metodo usato per criptare un testo di tipo \texttt{String} passato come parametro d'ingresso. Il metodo usa una chiave ottenuta a partire dal metodo \method{generateKey()} in associazione alla classe \texttt{javax.crypto.Cipher} per criptare il testo tramite l'algoritmo AES.
	\begin{itemize}
		\item \exception{Exception}: il metodo solleva un'eccezione.
	\end{itemize}
	\item{\method{+ decrypt(encryptedText: String)}}\\
	Decripta la stringa di testo ricevuta come parametro, attuando una procedura inversa a quella presentata nel metodo \method{encrypt(plainText: String)}\\\\
	Il metodo può sollevare eccezioni:
	\begin{itemize}
		\item \exception{Exception}: il metodo può sollevare un'eccezione generica.
	\end{itemize}
\end{description}

\classsection{PrincipalImpl}

\subsubsection*{Funzione}
Oggetto che permette di identificate univocamente uno \texttt{IUserData} memorizzato nel database del sistema \caName.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.Serializable}: interfaccia d'implementazione usata per rendere serializzabili le istanze della classe.
	\item \texttt{java.security.Principal}: interfaccia d'implementazione usata per rendere caratterizzate le istanze della classe.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{-- \{frozen\} \underline{serialVersionUID}: long}}\\
  Identificativo univoco per la classe, usato al fine di rendere l'oggetto serializzabile.
  \item{\memberdata{-- mail: String}}\\
  Attributo che rappresenta l'indirizzo e-mail dell'utente.
\end{description}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ PrincipalImpl(mail: String)}}\\
	Classe costruttore. crea un oggetto \texttt{PrincipalImpl} che permette di determinare univocamente lo \texttt{IUserData} che ha effettuato il login.
	\item{\method{+ getName(): String}}\\
	Restituisce l'elemento identificativo (mail dell'utente) dello \texttt{IUserData} che ha effettuato la procedura di login.
	\item{\method{+ equals(obj: Object): boolean}}\\
	Verifica l'uguaglianza di due oggetti \texttt{PrincipalImpl} sulla base di un confronto tra gli indirizzi mail degli utenti confrontati.
	\item{\method{+ hashCode(): int}}\\
	Restituisce il codice hash dell'oggetto di invocazione.				\item{\method{+ toString(): String}}\\
	Restituisce l'istanza dell'oggetto sotto forma di stringa. In particolare evidenziando l'indirizzo e-mail dell'utente.
\end{description}

\classsection{IAuthenticationData}

\subsubsection*{Funzione}
Interfaccia che identifica il comportamento di un oggetto adatto alla definizione dei dati di autenticazione di un utente.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
Nessuna relazione evidenziata.

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ getUsername(): String}}\\
Restituisce lo username fornito in input dall'utente durante la procedura di login.
	\item{\method{+ getPassword(): String}}\\
Restituisce la password fornita in input dall'utente durante la procedura di login
\end{description}

\classsection{AuthenticationData}

\subsubsection*{Funzione}
Oggetto contenente i dati di accesso utilizzati da un utente che vuole accedere al sistema \caName.

\subsubsection*{Relazioni d'uso}

Nessuna relazione evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \classname{IAuthenticationData}: interfaccia da implementare.
\end{itemize}

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{-- username: String}}\\
	Attributo contenente l'username dell'utente che richiede l'autenticazione.
  \item{\memberdata{-- password: String}}\\
	Attributo contenente la password dell'utente che richiede l'autenticazione.
\end{description}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ AuthenticationData(username: String, password: String)}}\\
	Costruttore pubblico che per creare un istanza di \texttt{AuthenticationData}, si basa sulla password e lo username dell'utente da autenticare.

	\item{\method{+ getUsername(): String}}\\
	Metodo che restituisce lo username dell'oggetto di autenticazione.
	
	\item{\method{+ getPassword(): String}}\\
	Metodo che Restituisce la password dell'utente che sta effettuando la procedura di login.

	\item{\method{+ hashCode(): int}}\\
	Restituisce il codice hash di questa istanza.
	
	\item{\method{+ equals(Object obj): boolean}}\\
	Determina l'uguaglianza di due istanze, effettuando un confronto tra l'oggetto stesso da cui è chiamato il metodo, e un Object \textit{obj} ricevuto come parametro d'ingresso.
	
	\item{\method{+ toString: String}}\\
	Metodo che Restituisce l'istanza sotto forma di stringa. Si osservi che il metodo non dovrà ritornare la password, ma solo lo username dell'utente da autenticare.

\end{description}

\classsection{AuthenticationModule}

%TODO definire questa parte tramite intervista a Mene.

\subsubsection*{Funzione}
Modulo di autenticazione utilizzato dal sistema \caName.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException}: la classe è in grado di sollevare eccezioni relative a operazioni di IO.
	\item \texttt{java.security.Principal}: cinterfaccia che definisce i dati di autenticazione di un utente.
	\item \texttt{java.util.Map}: parametri passati ad \method{iniziaile()}.
	\item \texttt{java.util.Set}: la classe può definire istanze di Set, per memorizzare i dati trattati.
	\item \texttt{javax.security.auth.callback.Callback}: vettore utilizzato per contenere i dati di autenicazione.
	\item \texttt{javax.security.auth.callback.CallbackHandler}: parametri passati ad \method{iniziaile()}.
	\item \texttt{javax.security.auth.callback.NameCallback}: oggetto che contiene il name dell'utente da autenticare.
	\item \texttt{javax.security.auth.callback.PasswordCallback}: oggetto che contiene la password dell'utente da autenticare
	\item \texttt{javax.security.auth.callback.UnsupportedCallbackException}: la classe è in grado di sollevare eccezioni relative a operazioni di UnsupportedCallback.
	\item \texttt{javax.security.auth.login.FailedLoginException}: la classe è in grado di sollevare eccezioni relative a operazioni di FailedLoginException.
	\item \texttt{javax.security.auth.login.LoginException}: la classe è in grado di sollevare eccezioni relative a operazioni di LoginException.
	\item \texttt{javax.security.auth.Subject}: definisce il soggetto da autenticare.
	\item \classname{abook.IUserData}: la classe interagisce con istanze di oggetti identificabili come utenti.
	\item \classname{dao.UserDataDAO}: utilizzata per modificare il contenuto del database. Nello psecifico viene usata per interagire con la tabella UserData.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{javax.security.auth.spi.LoginModule}: interfaccia d'implementazione.
\end{itemize}

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{-- login: boolean}}\\
  Attributo che determina se il login è avvenuto oppure no.
  \item{\memberdata{-- commit: boolean}}\\
  Attributo che determina se il commit è già stato eseguito.
  \item{\memberdata{-- handler: CallbackHandler}}\\
  Oggetto utilizzato per il caricamento delle credenzialie.
  \item{\memberdata{-- password: char[]}}\\
  Attributo che che contiene la password immessa dall'utente.
  \item{\memberdata{-- username: String}}\\
   Attributo che che contiene lo username immesso dall'utente.
  \item{\memberdata{-- principal: Principal}}\\
  Contiene la caratteristica autenticativa del subject. Nel sistema MyTalk tale proprietà è riservata al campo mail.
  \item{\memberdata{-- subject: Subject}}\\
  Attributo che definisce il soggetto da autenticare.
\end{description}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ initialize(subject: Subject, handler: CallbackHandler, sharedState: Map, option: Map): void }}\\
	Il metodo ha il compito di inizializzare gli attributi privati della classe con i parametri d'input.

	\item{\method{+ login(): boolean throws LoginException}}\\
	Metodo richiamato per verificare un riscontro tra i dati passati per l'autenticazione e i dati presenti nel database. Il metodo deve appoggiarsi alla classe \classname{UserDataDAO} per le operazione di estrazione dati dal database.
	
	\item{\method{+ commit(): boolean throws LoginException}}\\
	Metodo richiamato direttamente dal framework se il login va a buon fine. Il suo scopo è quellodi inizializzare il subject con i relativi principle.
	
	\item{\method{+ abort(): boolean throws LoginException}}\\
	Metodo usato per bloccare la procedura di login.
	
	\item{\method{+ logout(): boolean throws LoginException}}\\
	Metodo per il logout del sistema. Il suo scopo è quello di eliminare il principle e il subject.

\end{description}

\classsection{CredentialLoader}

\subsubsection*{Funzione}
Permette di caricare le credenziali di autenticazione, fornite dall'utente, per preparare la fase di login.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{javax.security.auth.callback.Callback}: usato durante la procedura di inserimento dati.
	\item \texttt{javax.security.auth.callback.NameCallback}: tipo di dato richiesto in ingresso per completare la parte di login.
	\item \texttt{javax.security.auth.callback.PasswordCallback}: tipo di dato richiesto in ingresso per completare la parte di login.
	\item \texttt{java.io.IOException}: eccezione che può essere sollevata dal metodo \texttt{handle} definito dall'interfaccia \texttt{javax.security.auth.callback.CallbackHandler}.
	\item \texttt{javax.security.auth.callback.UnsupportedCallbackException}: eccezione che può essere sollevata dal metodo \texttt{handle} definito dall'interfaccia \texttt{javax.security.auth.callback.CallbackHandler}.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{javax.security.auth.callback.CallbackHandler}: Interfaccia implementata dalla classe.
\end{itemize}

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{-- credential: AuthenticationData}}\\
  Attributo contenente i dati da autenticare per la login dell'utente.
  \item{\memberdata{-- security: ISecurityStrategy}}\\
  Attributo che contiene un oggetto che definisce un algoritmo di criptazione per i dati. Necessario per criptare i dati di autenticazione.
\end{description}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ CredentialLoader(credential: AuthenticationData, security: ISecurityStrategy)}}\\
	Costruttore pubblico. Crea un istanza con le credenziali fornite dall'utente (fornite in fase di login).

	\item{\method{+ handle(callbacks: Callback[]): void}}\\
	Effettua il caricamento e crittografa delle credenziali fornite dall'utente per la fase di login\\\\
	Il metodo può sollevare eccezioni:
	\begin{itemize}
		\item \exception{IOException}
		\item \exception{UnsupportedCallbackException}
	\end{itemize}

\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.authentication.servlet}\label{sec:autservlet}

%TODO da rivedere nella definizione dei metodi! 
\classsection{LogoutServlet}

\subsubsection*{Funzione}
\inglese{Servlet} da richiamare per effettuare il logout dal sistema.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doPost()}. Usata per scrivere l'output della \inglese{servlet}.
	\item \texttt{javax.servlet.ServletException}: eccezione sollevabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}:  classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in ingresso alla \inglese{servlet}).
	\item \texttt{javax.security.auth.login.LoginContext}: classe usata in \method{doPost()} per eseguite la logout dal sistema.
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe per usata per la comunicazione con la \inglese{servlet} (inoltra i dati in uscita dalla chiamata a \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpSession}: classe usata per definire una sessione HTTP.
	\item \classname{abook.IUserData}: usata per definire un utente.
	\item \classname{dao.UserDataDAO}: usata per comunicare tramite Hibernate con la tabella UserData della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{javax.servlet.http.HttpServlet}: classe estesa da \classname{LogoutServlet}.
\end{itemize}

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{\underline{-- {frozen} serialVersionUID: long}}}\\
  Utilizzato come ID univoco per identificare un oggetto serializzabile.
\end{description}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ LogoutServlet()}}\\
	Costruttore della classe. Richiama il costruttore della classe padre \texttt{HttpServlet}.
	
	\item{\method{\# doGet(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Metodo di delega che richiama \method{doPost()} passando gli stessi dati in input.
	
	\item{\method{\# doPost(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Metodo che costituisce il kernel logico di risposta della \inglese{servlet}. Il metodo inizia caricando i parametri ricevuti mediante \texttt{HttpServletRequest}. Una chiamata a tale \inglese{servlet} corrisponde ad una richiesta di logout e si attua impostando a false la sessione contenuta nell'oggetto HttopServletRequest request. Il metodo procede con la creazione di un istanza  di \texttt{LoginContext} denominata context. Quindi viene effettuata la memorizzazione dell'oggetto ritornato da una chiamata:
\\
\verb|session.getAttribute("LoginContext");|
\\

L'oggetto cosi ottenuto dovrà essere controllato, ovvero si dovrà accertare che il tipo dinamico è conforme al tipo \texttt{LoginContext} (il programmatore dovrà obbligatoriamente usare   la primitiva \texttt{istanceof}). Quindi si sovrascrive il contenuto di context con quanto ottenuto dalla chiamata a metodo sopracitata, e si richiama il metodo \texttt{logout()} a partire dall'oggetto context. Il metodo termina invalidando la sessione richiamando il metodo \texttt{invalidate()} di HttpSession.

\end{description}

\classsection{LoginServlet}

\subsubsection*{Funzione}
\inglese{Servlet} da richiamare per effettuare l'autenticazione dell'utente.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doPost()}. Usata per scrivere l'output della \inglese{servlet}.
	\item \texttt{javax.security.auth.login.LoginContext}: classe usata in \method{doPost()} per avviare la login dell'utente.
	\item \texttt{javax.servlet.ServletException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}:  classe usata per la comunicazione con la \inglese{servlet} (inoltra i dati in ingresso alla \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per la comunicazione con la \inglese{servlet} (inoltra i dati in uscita dalla chiamata a \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpSession}: classe usata per definire una sessione HTTP.
	\item \classname{abook.IUserData}: usata per definire un utente.
	\item \classname{dao.UserDataDAO}: usata per comunicare tramite Hibernate con la tabella \texttt{UserData} della base di dati.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{javax.servlet.http.HttpServlet}: classe estesa da \classname{LoginServlet}.
\end{itemize}

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{\underline{-- {frozen} serialVersionUID: long}}}\\
  Utilizzato come ID univoco per identificare un oggetto serializzabile.
\end{description}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ LoginServlet()}}\\
	Costruttore della classe. Richiama il costruttore della classe padre \texttt{HttpServlet}.
	
	\item{\method{\# doGet(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Metodo che richiama \method{doPost()} passando gli stessi dati in input.
	
	\item{\method{\# doPost(request: HttpServletRequest, response: HttpServletResponse): void}}\\

Metodo che costituisce il kernel logico di risposta della \inglese{servlet}. Il metodo inizia caricando i parametri ricevuti mediante \texttt{HttpServletRequest}. Una chiamata a tale metodo corrisponde ad una richiesta di login e si attua impostando due campi String con i dati ottenuti da una chiamata a \texttt{getParameter(``username'')} e \texttt{getParameter(``password'')} . Quindi si crea un istanza di \texttt{HttpSession} tramite il metodo \texttt{getSession(true)} del parametro request. Il metodo prosegue controllando se l'username e la password precedentemente ottenute hanno valore diverso da null. Nel caso il flusso principale continua creando un'istanza di \classname{AutenthicationData} (denominata credential) a partire dai parametri username e password. Quindi si carica la path del file di configurazione in un apposita stringa \texttt{pathFileConfig}, tramite la chiamata a metodo:\\
	
\verb|System.getenv("MyTalkConfiguration") + "\\LoginConfiguration.conf"|.\\

Il flusso principale prosegue all'interno di un blocco \texttt{try-catch} creando:
	\begin{itemize}
		\item[•] un \classname{CredentialLoader} (loader);
		\item[•] un \classname{LoginContext} (context);
		\item[•] un \classname{dao.UserDataDao} (user);
	\end{itemize}
Quindi tramite context si esegue il login e si impostano gli attributi di sessione come segue: 

\texttt{session.setAttribute("LoginContext", context);}

Infine si carica in user un istanza di \classname{dao.UserDataDAO} ottenuta dalla chiamata a metodo \method{UserDataDAO.getByEmail()}, e restituendo user in un formato di formattazione \texttt{Json} (\texttt{user.toJson()}).

\end{description}

\classsection{RegisterServlet}

\subsubsection*{Funzione}
\inglese{Servlet} da richiamare per effettuare la registrazione al sistema MyTalk.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{java.io.PrintWriter}: classe istanziata all'interno del metodo \method{doPost()}. Usata per scrivere l'output della \inglese{servlet}.
	\item \texttt{javax.servlet.ServletException}: eccezione richiamabile dai metodi \method{doPost()} e \method{doGet()}.
	\item \texttt{javax.servlet.http.HttpServletRequest}:  classe usata per la comunicazione con la \inglese{servlet} (inoltra i dati in ingresso alla \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpServletResponse}: classe usata per la comunicazione con la \inglese{servlet} (inoltra i dati in uscita dalla chiamata a \inglese{servlet}).
	\item \texttt{javax.servlet.http.HttpSession}: classe usata per definire una sessione HTTP.
	\item \classname{abook.IUserData}: usata per definire un utente.
	\item \classname{dao.UserDataDAO}: usata per comunicare tramite Hibernate con la tabella \texttt{UserData} della base di dati.
	\item \classname{authentication.ISecurityStrategy}: usata per criptare/decriptare i dati da inviare/ricevere
	\item \classname{authentication.AESAlgorithm}: implementazione di \classname{authentication.ISecurityStrategy} usata dalla classe descritta.
	
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{javax.servlet.http.HttpServlet}: classe estesa da \classname{RegisterServlet}.
\end{itemize}

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{\underline{-- {frozen} serialVersionUID: long}}}\\
  Utilizzato come ID univoco per identificare un oggetto serializzabile. Tale ID deve essere impostato a ``10002L''.
\end{description}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ RegisterServlet()}}\\
	Costruttore della classe. Richiama il costruttore della classe padre \texttt{HttpServlet}.
	
	\item{\method{\# doGet(request: HttpServletRequest, response: HttpServletResponse): void}}\\
	Metodo che richiama \method{doPost()} passando gli stessi dati in input.
	
	\item{\method{\# doPost(request: HttpServletRequest, response: HttpServletResponse): void}}\\

Metodo che costituisce il kernel logico di risposta della \inglese{servlet}. Il metodo inizia caricando i parametri ricevuti mediante \texttt{HttpServletRequest}. Una chiamata a tale metodo corrisponde ad una richiesta di registrazione al sistema e si attua impostando i dati di registrazione:
	\begin{itemize}
		\item name;
		\item username;
		\item mail;
		\item password;
		\item path immagine;
		\item domanda segreta;
		\item risposta alla domanda segreta;
	\end{itemize}
	Per eseguire tali operazioni, il metodo predispone delle opportune variabili di tipo String e crea uno \classname{abook.IUserData} user. Quindi all'interno di un blocco try catch viene impostata una strategia di criptaggio dei dati (creando un istanza di \classname{authentication.AESAlgorithm}). Quindi vengono caricati i dati di registrazione nelle variabili precedentemente create. Per eseguire tali operazioni è necessario usare l'istruzione:\\
	
	\verb|request.getParameter("NOME_PARAMTERO")|\\
	
	dove i nomi dei parametri sono:
	\begin{itemize}
		\item username (usata per l'indirizzo mail);
		\item name;
		\item surname;
		\item password;
		\item answer;
		\item question;
		\item picturePath;
	\end{itemize}
	Il passo successivo (sempre dentro il blocco try) consiste nel creare un istanza di \classname{dao.UserDataDAO} userDAO, e nell'eseguire un operazione di userDAO.\method{insert()} passando come parametro user (l'utente precedentemente creato). Il blocco try termina impostando result a ``\inglese{true}''.
	
	Per quanto riguarda il blocco catch, in esso viene impostato result a ``\inglese{false}''.
	
	Il metodo termina scrivendo in un \texttt{PrintWriter} il valore di result.
\end{description}


\subsection{Package org.softwaresynthesis.mytalk.server.connection}\label{sec:connection}

\classsection{PushInbound}

\subsubsection*{Funzione}
Classe per la definizione di un apposito canale di comunicazione client-server. La classe è un'estensione di \texttt{org.apache.catalina.websocket.MessageInbound} che verrà usata poi in \classname{ChannelServlet}. Si osservi che l'associazione tra un istanza di \classname{PushInbound} e un utente del sistema è univoca: fintanto che connesso un utente ha un proprio \classname{PushInbound} presente sul server.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.io.IOException}: Eccezione che può sollevare il metodo \method{OnTextMessage()}.
	\item \texttt{java.nio.CharBuffer}: tipologia di \textit{buffer} usata per memorizzare il messaggio ricevuto come parametro d'ingresso.
	\item \texttt{java.util.Iterator}: usata per scorrere il contenuto dell'insieme di \classname{AddressBookEntry}
	\item \texttt{java.util.Set}: struttura dati usata per memorizzare le \inglese{entry} (\classname{AddressBookEntry}) che costituiscono la rubrica dell'utente.
	\item \texttt{com.google.gson.*}: converte i dati interni in una stringa formato json.
	\item \classname{State}: classe interna utilizzata per rappresentare lo stato dell'utente a cui è associata l'istanza di \classname{PushInbound}. Un utente ha uno stato fintanto che è connesso (quindi fintanto che esiste sul server un'istanza di \classname{PushInbound}  ad esso associata). Gli stati possibili sono: \texttt{available} (utente connesso e libero, quindi disposto a ricevere chiamate) e \texttt{occupied} (utente connesso ma attualmente occupato in un'altra conversazione).
	\item \classname{abook.AddressBookEntry}: usata per definire la rubrica dell'utente, richiamata dal metodo \method{onTextMessage} nel momento in cui si presenta la necessità di aggiornare lo stato dell'utente e renderlo visibile ai suoi contatti.
	\item \classname{abook.IUserData}: usata per riferire un istanza della classe ad un particolare utente.
	\item \classname{dao.UserDataDAO}: usata per riferire un istanza della classe ad un particolare utente.

\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{org.apache.catalina.websocket.MessageInbound}: classe da estendere, aggiunge alla classe \classname{PushInbound} le funzionalità necessarie per renderla un ``canale di comunicazione'' utilizzabile dai client.
\end{itemize}

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{-- id: Long}}\\
  Identificativo di tipo \textit{Long} del canale di comunicazione associato ad un client univoco.
  \item{\memberdata{-- state: State}}\\
  Attributo usato per memorizzare lo stato dell'utente ``proprietario'' del \classname{PushInbound}.
\end{description}

%TODO da rivedere.

\subsubsection*{Metodi}
\begin{description}

	\item{\method{+ setId(n: Long): void}}\\
	Metodo per impostare il valore contenuto nell'attributo \memberdata{id}.
	
	\item{\method{+ getId(): Long}}\\
	Metodo che ritorna il contenuto dell'attributo \memberdata{id}.
	
	\item{\method{+ onTextMessage(message: CharBuffer): void}}\\
	Metodo invocato al momento della ricezione di un messaggio da parte del client. Il metodo riceve in input un oggetto di tipo \texttt{CharBuffer} contenente il messaggio inviato dal client.
Inizialmente il metodo crea un istanza per ognuno dei seguenti oggetti:
	\begin{itemize}
		\item[•]\texttt{Gson}: tipo di \textit{Json} definito da \textit{Google};
		\item[•]\texttt{JsonParser}: \textit{parser} usato per scorrere il contenuto di una stringa \textit{Json};
		\item[•]\texttt{JsonArray}: array popolato a partire dal \inglese{parsing} della stringa di messaggio data in input.
	\end{itemize}
	
	Prima di procedere si voglia considerare quanto segue: il metodo dopo aver ``segmentato'' il messaggio ricevuto in input, si occupa di esaminarne il contenuto che può essere di 5 tipologie, ciascuna identificata tramite un valore intero positivo da 1 a 5. Tale valore deve essere salvato nell'istanza di \texttt{JsonArray}
	Detto ciò, tornando a definire il flusso principale del metodo, si osservi che:

	\begin{itemize}
		\item[•]Se la richiesta inoltrata è del tipo 1: il metodo prende in lettura il messaggio e imposta il contenuto di \memberdata{id} con il valore letto mediante procedura di \inglese{parsing} analoga a quella definita al passo precedente. Per farlo utilizza il metodo \texttt{fromJson} richiamato dall'istanza \texttt{gsonObj} di tipo \texttt{Gson} creata al passo precedente. A tale metodo passa il contenuto dell'array e in particolare ciò che è salvato nella posizione 1 (utilizzo di metodo \texttt{get(int i)}).
		\item[•]Se la richiesta inoltrata è del tipo 2: il metodo procede con le istruzioni necessarie a scambiare i dati per la chiamata. Nello specifico viene salvato in un attributo di tipo \texttt{Long}, l'\texttt{id} del client che desidero chiamare, quindi ricerco l'oggetto \texttt{PushInbound} associato al client che desidero contattare, e gli inoltro il messaggio ricevuto come parametro d'ingresso.
		\item[•]Se la richiesta inoltrata è del tipo 3: il metodo comunica al client ``destinatario'' della chiamata, l'\texttt{id} del client chiamante. La procedura è analoga a quella identificata nel punto precedente, con la specifica che il messaggio inoltrato è l'identificativo del cliente che desidera avviare la chiamata.
		\item[•]Se la richiesta inoltrata è del tipo 4: il metodo si occupa dell'eliminazione della \textit{webSocket}, contattando l'istanza \classname{ChannelServlet} associata a questo \texttt{PushInbound}.
		\item[•]Se la richiesta inoltrata è del tipo 5: il metodo viene usato per modificare lo stato dell'utente, con il valore passato tramite messaggio. Dopo la ricezione del messaggio, il metodo cambia il valore del campo \texttt{state} con il valore ricevuto come parametro d'ingresso. Quindi procede ricavando la lista degli utenti nella rubrica dell'utente che ha cambiato stato e comunica loro che è avvenuto un cambiamento di stato.
	\end{itemize}
\end{description}

\classsection{ChanelServlet}

\subsubsection*{Funzione}
\inglese{Servlet} per la gestione delle connessioni. Richiamata dai client per ottenere le informazioni necessarie a stabilire una comunicazione client-client.

\subsubsection*{Relazioni d'uso}
\begin{itemize}
	\item \texttt{java.util.Vector}: vettore usato per memorizzare i \texttt{PushInBound} creati all'interno della classe.
	\item \texttt{javax.servlet.ServletConfig}: classe per la configura della \inglese{servlet}. 
	\item \texttt{javax.servlet.ServletException}: eccezione richiesta per la firma del metodo \method{init} (metodo richiesto per implementazione dell'interfaccia \texttt{javax.servlet.Servlet}.
	\item \texttt{javax.servlet.annotation.WebServlet}: necessaria per definire la \inglese{servlet} come \texttt{WebServlet}.
	\item \texttt{javax.servlet.http.HttpServletRequest}: necessaria per definire le richieste inoltrate alla classe (richieste a \inglese{servlet}).
	\item \classname{org.apache.catalina.websocket.StreamInbound}: classe utilizzata per definire un canale di comunicazione server-client.
	\item \classname{org.apache.catalina.websocket.WebSocketServlet}: classe da estendere per utilizzare i metodi di comunicazione tramite \inglese{webSocket}.
\end{itemize}

\subsubsection*{Classi estese ed interfacce implementate}
\begin{itemize}
	\item \texttt{javax.servlet.Servlet}: interfaccia d'implementazione. Necessaria per definire la classe come \inglese{servlet}.
\end{itemize}

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{\underline{-- \{frozen\} serialVersionUID: long}}}\\
  Utilizzato come ID univoco per identificare un oggetto serializzabile.
  \item{\memberdata{-- \{frozen\} clients: Vector<PushInbound>}}\\
  Vettore contenente i canali di comunicazione server-client. Un canale di comunicazione \texttt{PushInbound} viene creato dal Server al momento dell'autenticazione di un utente (al quale poi viene associato).
\end{description}

\subsubsection*{Metodi}
\begin{description}
	\item{\method{+ ChannelServlet()}}\\
	Costruttore della \textit{servlet}. Richiama \method{super()}.
	
	\item{\method{\# createWebSocketInbound(subProtocol: String, request: HttpServletRequest): StreamInbound}}\\
	Metodo per la creazione di una \textit{websocket}. Il metodo ha anche il compito di salvare nel vettore di connessioni attive e la ritorna al client. Nello specifico il server segue l'iter:
	
	\begin{itemize}
		\item[1)] creazione di un \textit{PushInbound};
		\item[2)] aggiungo l'oggetto creato al punto precedente, al vettore di \textit{PushInbound} \memberdata{clients};
		\item[3)] il metodo termina ritornando l'istanza di \textit{PushInbound} creata al punto 1.
	\end{itemize}
	
	\item{\method{\underline{ + findClient(n: Long): PushInbound}}}\\
	Metodo per la ricerca di una connessione client dato l'identificativo dell'utente, esegue una ricerca (mediante ciclo \inglese{for}) all'interno del vettore \memberdata{clients} e ad ogni iterazione verifica se l'istanza i-esima presa in esame ha un campo id che corrisponde a quello dato in input come parametro di ricerca.
Il metodo termina ritornando il \textit{PushInbound} associato al client, se si verifica l'effettiva esitenza di un client con \texttt{id} uguale a quello passato in input, \texttt{null} altrimenti.
	
	\item{\method{\underline{ + removeClient(c: PushInbound): void}}}\\
	Metodo per la rimozione di un oggetto \texttt{PushInbound} dal vettore \memberdata{clients}. Il metodo esegue una ricerca tramite ciclo \inglese{for} (analoga a quella eseguita nel metodo \method{findClient}. Se la ricerca ha esito positivo il metodo termina eseguendo la rimozione dell'istanza dall'oggetto \memberdata{clients} tramite la chiamata a metodo \texttt{remove}.
\end{description}

\clearpage

\section{Specifica sotto-architettura \texttt{clientpresenter}}\label{sec:clientpresenterarchitecture}

La sotto-architettura \texttt{clientpresenter}, a livello di definizione di prodotto, richiede una trattazione speciale a causa del particolare dominio tecnologico coinvolto. Essa è infatti definita con il linguaggio JavaScript che pur essendo definito come linguaggio orientato agli oggetti non permette di definire classi, a ciò si aggiunge un ulteriore particolarità di JavaScript: è debolmente tipizzato.

In ragione di ciò, al fine di facilitare al programmatore la comprensione del progetto (pensando quindi alle varie entità come a classi) senza però confonderlo in fase di stesura del codice, si è stabilito di adoperare la seguente terminologia:

\begin{description}
	\item{\scshape\bfseries Attributi}: saranno definiti con una sintassi simile a quella già usata per la parte server, pertanto al nome dell'attributo sarà associato il tipo ``logico'' che idealmente rappresenta. Dal momento che in JavaScript non esiste il controllo dei tipi, si è stabilito di attenersi a una notazione simile a quella utilizzata per lo strumento di generazione automatica della documentazione JSDoc. In particolare i tipi legali consentiti sono:
	\begin{itemize}
	  \item \texttt{HTMLElement} che corrispondono a nodi DOM già esistenti nella pagina HTML che definisce l'interfaccia utente oppure modificati (a \textit{run-time}) sulla base di informazioni ottenute dal server e che saranno indicati come:
	  	\begin{verbatim}
				(+, -) attributo: HTMLElement
			\end{verbatim}
	
    \item \texttt{String} se l'attributo è destinato a contenere esclusivamente valori di tipo \textit{String} che sarà segnato nel documento come:
			
			\begin{verbatim}
				(+, -) attributo: String
			\end{verbatim}
			
			\item \texttt{Array}, se l'attributo è un \inglese{array}, che in JavaScript non chiede di essere definito per tipo di valori contenibili che nel presente documento sarà segnalato come:
			
			\begin{verbatim}
				(+, -) attributo: Array
			\end{verbatim}
			
			\item \texttt{Number}, che è da considerarsi come il supertipo di tutti i tipi numerici e che sarà menzionato nel presente documento come:
			\begin{verbatim}
			  (+, -) attributo: Number
			\end{verbatim}
			
			\item \texttt{Boolean}, che rappresenta un valore booleano e che sarà indicato nel presente documento come:
			\begin{verbatim}
			  (+, -) attributo: Boolean
			\end{verbatim}
			
			\item \texttt{Object}, che è da intendersi come un oggetto generico JavaScript, dotato una serie di proprietà per ciascuna delle quali è definito un valore e che sarà rappresentato come:
			\begin{verbatim}
			  (+, -) attributo: Object
			\end{verbatim}
	\end{itemize}
		
Per quanto riguarda l'accessibilità degli attributi, invece, saranno distinti i due casi di accessibilità pubblica e accessibilità privata, indicati nel presente documento con un formalismo analogo a quello utilizzato per la parte server.

Nell'attività di codifica, i programmatori dovranno attenersi alle seguenti pratiche:
\begin{itemize}
  \item gli attributi pubblici saranno assimilati a proprietà dell'oggetto creato tramite la funzione costruttore accessibili all'esterno, e dovranno pertanto essere specificati come:
  \begin{verbatim}
    this.attributo = new ClassName();
  \end{verbatim}
  
  \item gli attributi privati invece, dal momento che saranno visibili solo all'interno del costruttore e di tutte le funzioni annidate all'interno di esso -- vale a dire i metodi della classe -- dovranno essere dichiarati come variabili locali secondo la consueta sintassi JavaScript:
  \begin{verbatim}
    var attributo = new ClassName();
  \end{verbatim}
\end{itemize}
		
	\item{\scshape\bfseries Metodi}: la sintassi usata dal programmatore per definire un metodo in JavaScript dipende dalla natura pubblica o privata del metodo stesso, in particolare:
	\begin{itemize}
	
\item Metodi pubblici: essendo i metodi pubblici delle proprietà che l'oggetto espone verso l'esterno, essi dovranno essere specificati mediante la forma
\begin{verbatim}
  this.doSomething = function(arg0, arg1, ...) {
          ...corpo del metodo...
  }
\end{verbatim}

\item Metodi privati: essendo utilizzabili solo all'interno di altri metodi della classe essi possono essere definite come funzioni annidate all'interno del costruttore della classe stessa, secondo la consueta sintassi
\begin{verbatim}
  function doSomething(arg0, arg1, ...) {
        ...corpo del metodo...
  }
\end{verbatim}

La sintassi utilizzata all'interno del presente documento, in ogni caso, rimane quella che è stata definita in precedenza e prevede i marcatori \verb|+| per i metodi pubblici e \verb|-| per i metodi privati.
	\end{itemize}
\end{description}

\subsection{Package \texttt{org.softwaresynthesis.mytalk.clientpresenter.guicontrol}}\label{sec:guicontrol}

\classsection{LoginPanelPresenter}

\subsubsection*{Funzione}
\inglese{Presenter} incaricato di gestire il pannello di \textit{login}, ha il compito di recuperare i dati inseriti dall'utente (username e password) dall'interfaccia grafica, controllare se assumono dei valori legali e in seguito passarli al server per eseguire l'autenticazione.

Il \inglese{presenter} si occupa inoltre di gestire il caso in cui l'autenticazione non può essere portata a termine per errori nei dati di input e fornisce infine le funzionalità per il recupero della password.

\subsubsection*{Relazioni d'uso}

Nessuna relazione evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}

\item{\memberdata{-- thisPanel: HTMLElement}}\\
Attributo che definisce il contenuto del nodo DOM inerente alla schermata di \inglese{login}, nello specifico tale nodo corrisponde ad un \verb+<div>+ il cui valore identificativo è uguale a \texttt{LoginPanel}.

\end{description}

\subsubsection*{Metodi}
\begin{description}

\item{\method{-- testCredentials(data: String): void}}\\
Il metodo prende come parametro una stringa JSON ricevuta dal server che, in caso di dati di autenticazione andata a buon fine, corrisponde a una forma serializzata dell'oggetto che rappresenta l'utente autenticato ed è invece uguale alla stringa \verb+null+ in caso contrario.

Il metodo ha il compito di deserializzare i dati dell'utente tramite la funzione di libreria \verb+JSON.parse(data)+ e, nel caso in cui questa sia valutata positivamente -- vale a dire non è né \verb+null+ né \verb+undefined+ -- sollevare un evento avente come nome la stringa \verb'login' e come proprietà \verb+user+ un riferimento al nuovo utente creato.

In caso di autenticazione non andata a buon fine, invece, dovrà essere aggiornata in modo opportuno la vista per segnalare la condizione di errore.

\item{\method{+ getSecretQuestion(username: String): String}}\\
Il metodo a il compito di richiedere al server tramite una chiamata AJAX sincrona la domanda segreta associata all'utente che ha come nome identificativo la stringa passata come parametro, e restituirla al chiamante.

Al suo interno dovrà essere creata pertanto una nuova istanza di \verb+XMLHttpRequest+ destinata all'indirizzo del \inglese{front controller} presente sul server, e dovrà essere inviata  passando al metodo \verb+send+ la stringa:
\begin{verbatim}
  "operation=question&username=" + encodeURIComponent(username)
\end{verbatim}

Dal momento che il testo della risposta ricevuta dal server contiene la domanda segreta, sarà infine sufficiente restituire il valore ottenuto con \verb+request.responseText+.
	
\item{\method{-- hasAnsweredCorrectly(username: String, answer: String): void}}\\
Il metodo ha il compito di inviare la risposta ottenuta tramite l'interfaccia grafica al server per verificare se corrisponde al valore memorizzato nel database del sistema in fase di registrazione iniziale. In particolare, il metodo ha il compito di inviare una richiesta AJAX sincrona all'indirizzo del \inglese{front controller} la cui intestazione è la stringa
\begin{verbatim}
  "operation=answer&username=" + encodeURIComponent(username) +
                     "&answer=" + encodeURIComponent(answer))
\end{verbatim}

Una volta ricevuta la risposta, poiché questa già corrisponde alla stringa \verb+true+ o \verb+false+ che rappresentano le costanti booleane in formato JSON, sarà sufficiente restituirne la valutazione ottenuta con la consueta funzione \verb+parse+.

\item{\method{+ getUsername(): String}}\\
Metodo che ha il compito di recuperare tramite l'interfaccia della vista il nome utente inserito dall'utente, quindi effettuare un controllo preliminare per assicurare che il valore rientri all'interno del dominio dei valori legali.

Il controllo dovrà essere effettuato mediante un'opportuna espressione regolare del tipo
\begin{verbatim}
    ^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$
\end{verbatim}
e, nel caso in cui il valore non corrispondesse, il metodo dovrà sollevare un'eccezione contenente il testo ``indirizzo email non valido''. Dal momento che il metodo restituisce una stringa, in caso di valore accettabile quest'ultimo dovrà essere restituito al chiamante.

\item{\method{+ getPassword(): String}}\\
Metodo che ha il compito di recuperare tramite l'interfaccia della vista la password inserita dall'utente. Prima di restituire il valore ottenuto al chiamante, il metodo ha il compito di verificare che il valore sia valido e che, in particolare, non sia \verb+undefined+ oppure uguale alla stringa vuota. In simili circostanze, il metodo solleva un'eccezione contenente esattamente il testo ``password non specificata''.

\item{\method{+ login(data: Object): String}}\\
Il metodo prende come parametro un oggetto dotato delle due proprietà \verb+usename+ e \verb+password+ sulla base delle quali avrà il compito di costruire la \inglese{query string} da inviare al server per la verifica delle credenziali.

Il metodo dovrà pertanto costruire una \verb+XMLHttpRequest+ da inviare all'indirizzo del \inglese{front controller} presente sul server con la stringa
\begin{verbatim}
    operation=login&username=" + encodeURIComponent(data.username) +
                  "&password=" + encodeURIComponent(data.password)
\end{verbatim}
quindi invocare il già visto metodo \verb+testCredentials+ con il testo della risposta. Il valore da restituire al chiamante è proprio la stringa di \inglese{query} che è stata trasmessa al server.

\item{\method{+ onShowLoginPanel(): void}}\\
Questo gestore di evento ha il compito di provocare la visualizzazione del pannello di login. Questo dovrà essere ottenuto sollevando un nuovo evento tramite il quale tutti i pannelli presenti sono rimossi (\verb'removeAllPanel') quindi demandando alla vita il compito di costruirsi e caricare il relativo \inglese{template}.

\item{\method{+ onRemoveLoginPanel() : void}}\\
Questo gestore di evento ha il compito di provocare la distruzione del pannello di autenticazione, richiamando il metodo opportuno della vista corrispondente, vale a dire \verb+destroy()+.

\item{\method{+ onLogin(user: Object): void}}\\
Questo gestore di evento incapsula il comportamento del \inglese{presenter} nel momento in cui è sollevato un evento avente come identificativo la stringa \verb'login'.

Il metodo ha il compito di memorizzare all'interno del client i dati di autenticazione (in particolare, il valore numerico ID necessario all'identificazione del client da parte del server e degli altri client), avviare la connessione al server e provocare la visualizzazione della \inglese{home screen} dell'applicativo.

\end{description}

\classsection{RegisterPanelPresenter}

\subsubsection*{Funzione}
\inglese{Presenter} incaricato di gestire il \inglese{form} di registrazione al sistema.

\subsubsection*{Relazioni d'uso}

Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{-- thisPanel: HTMLElement}}\\
  Elemento HTML (da intendersi come nodo DOM) controllato da questo Presenter, che corrisponde a un elemento \verb'<div>' avente identificativo uguale a \verb'RegisterPanel'.
\end{description}

\subsubsection*{Metodi}
\begin{description}

	\item{\method{+ getSurname(): String}}\\
	Metodo che estrae dalla \inglese{form} il valore del cognome del nuovo utente e lo restituisce.
	
	\item{\method{+ getName(): String}}\\
	Metodo che estrae dalla \inglese{form} il valore del nome del nuovo utente e lo restituisce.
	
	\item{\method{+ getAnswer(): String}}\\
	Metodo che estrae dal \inglese{form} la risposta alla domanda segreta associata al nuovo utente e la restituisce se specificata, mentre in caso contrario solleva un'eccezione avente come messaggio esattamente la stringa ``risposta alla domanda segreta non specificata''.
		
	\item{\method{+ getQuestion(): String}}\\
	Metodo che estrae dalla \inglese{form} la domanda segreta associata al nuovo utente e la restituisce se presente, mentre in caso contrario solleva un'eccezione avente come messaggio esattamente la stringa ``domanda segreta non specificata''.
	
	\item{\method{+ getPassword(): String}}\\
	Metodo che estrae dalla \inglese{form} la \textit{password} associata al nuovo utente e la restituisce se presente, mentre in caso contrario solleva un'eccezione avente come messaggio esattamente la stringa ``password non specificata''.
	
	\item{\method{+ getUsername(): String}}\\
	Metodo che estrae dalla \inglese{form} lo \textit{username} del nuovo utente (per \textit{username} si intende l'indirizzo email dell'utente). Il metodo dovrà verificare che la mail restituita corrisponda all'espressione regolare:
\begin{verbatim}
	  ^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$
\end{verbatim}
	
Se la mail è valida il metodo termina ritornandone il valore, mentre nel caso in cui non sia un indirizzo ben formato o non sia stato specificato il metodo solleva delle eccezioni aventi come messaggio, rispettivamente, ``indirizzo email non valido'' e ``indirizzo email non specificato''.
	
	\item{\method{+ getPicturePath(): String}}\\
	Metodo che estrae dal \inglese{form} il percorso dell'immagine del nuovo profilo utente e lo restituisce.
	
	\item{\method{+ register(userData: Object): void}}\\
	Metodo che invia i dati ricevuti al \inglese{front controller} del server per la creazione di un nuovo account utente. Tale metodo inizia creando un istanza di \texttt{XMLHttpRequest} sincrona da inviare all'indirizzo del server. Il metodo dovrà estrarre le proprietà obbligatorie \verb'username', \verb'password', \verb'question', \verb'answer' e quelle facoltative \verb'name', \verb'surname' e \verb'picturePath'.
	
	Dopo averle opportunamente codificate per per la trasmissione con la funzione di libreria \verb'encodeURIComponent' queste ultime dovranno essere inserite in un oggetto \verb'FormData' da utilizzare per inviare la richiesta al server. Una volta ricevuta la riposta dal server, il metodo dovrà effettuare la deserializzazione del testo ad essa associato e, se questo contiene un oggetto utente legale, sollevare un evento con nome identificativo \verb'login'.
	
	\item{\method{+ onShowRegistrationPanel(): void}}\\
	Questo gestore di evento ha il compito di provocare la visualizzazione del pannello di registrazione. Ciò dovrà essere ottenuto sollevando un nuovo evento tramite il quale tutti i pannelli presenti sono rimossi (\verb'removeAllPanel') quindi demandando alla vista il compito di costruirsi e caricare il relativo \inglese{template}.
	
	\item{\method{+ onRemoveRegistrationPanel(): void}}\\
	Questo gestore di evento ha il compito di provocare la distruzione del pannello di registrazione, richiamando il metodo opportuno della vista corrispondente, vale a dire \verb+destroy()+.

\end{description}

\classsection{CallHistoryPanelPresenter}

\subsubsection*{Funzione}
\inglese{Presenter} incaricato alla visualizzazione e alla gestione dello storico chiamate dell'utente.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
  \item{\memberdata{-- calls: Array}}\\
  Array enumerativo che conterrà tutte le chiamate effettuate dall'utente recuperate dal server.
  \item{\memberdata{-- thisPanel: HTMLElement}}\\
  Elemento HTML, da intendersi come nodo DOM, che rappresenta la vista controllata da questo \inglese{presenter} e che corrisponde a un elemento \verb'<div>' avente come nome identificativo la stringa \verb'CallHistroryPanel'.
\end{description}

\subsubsection*{Metodi}
\begin{description}

  \item{\method{-- getCalls(): Array}}\\
  Metodo che ha il compito di recuperare tutta la lista delle chiamate effettuate e tracciate nel server, inviando una richiesta AJAX sincrona al \inglese{front controller} che nell'intestazione contiene il parametro \verb'operation' impostato a \verb'getCalls'.
  
  In particolare, il metodo ha il compito di creare una nuova istanza di \verb'XMLHttpRequest' con la \inglese{query string} specificata in precedenza e di inviarla al server quindi ritornare il testo della risposta ottenuta dopo averlo deserializzato e costruito l'array di chiamate corrispondente.
  
  \item{\method{+ displayList(): void}}\\
  Metodo che ha il compito di popolare la lista delle chiamate in cui è coinvolto un determinato utente. Il metodo ha il compito di procurarsi la lista delle chiamate attraverso il server al fine di inizializzare il campo dati privato \verb'calls'.
  
  Quindi, per ognuna delle chiamate che sono state scaricate, ha il compito di aggiornare la vista corrispondente provocando la visualizzazione dei dati della chiamata.
  
  \item{\method{+ onShowCallHistoryPanel(): void}}\\
  Questo gestore di eventi ha il compito di provocare la visualizzazione del pannello contenente lo storico delle chiamate demandando alla vista il compito di costruirsi e caricare il relativo \inglese{template}.

\end{description}

\classsection{SearchResultPanelPresenter}

\subsubsection*{Funzione}
\inglese{Presenter} incaricato di gestire il pannello che visualizza i risultati di ricerca.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
\item{\memberdata{-- thisPanel: HTMLElement}}\\
Riferimento al pannello controllato da questo \inglese{presenter}, vale a dire un elemento \verb'<div>' avente come identificativo la stringa \verb'SearchResultPanel'.
\end{description}

\subsubsection*{Metodi}
\begin{description}
  \item{\method{+ sendSearchRequest(pattern: String): Object}}\\
  Il metodo ha il compito di avviare una ricerca fra gli utenti registrati al sistema a partire dalla stringa \verb'param' come criterio di ricerca (che può corrispondere a parte del nome, del cognome o del nome utente).
  
  A tale scopo il \inglese{presenter} dovrà contattare il server inviando all'indirizzo del\inglese{front controller} una richiesta AJAX sincrona con il metodo POST e avente come \inglese{query string} esattamente la stringa
  \begin{verbatim}
    "operation=search&param=" + pattern
  \end{verbatim}
  
  Dal momento che il server risponde inviando in forma serializzata l'array di contatti desiderato, sarà sufficiente che il metodo restituisca la forma deserializzata del contenuto della risposta, con un'istruzione del tipo:
  \begin{verbatim}
    return JSON.parse(request.responseText);
  \end{verbatim}
  
  \item{\method{+ onShowSearchResultPanel(): void}}\\
  Questo gestore di eventi ha il compito di provocare la visualizzazione del pannello di ricerca caricando il \inglese{template} corrispondente e demandando alla \classname{SearchResultView} di inizializzarsi tramite il metodo \method{display()} preposto a tale scopo.
  
\end{description}

\classsection{MainPanelPresenter}

\subsubsection*{Funzione}
\inglese{Presenter} incaricato di gestire il pannello principale, ossia quello centrale.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
\item{\memberdata{-- thisPanel: HTMLElement}}\\
  Riferimento all'elemento controllato dal \inglese{presenter} vale a dire un \verb'<div>' avente come identificativo la stringa \verb'MainPanel'.
\end{description}

\subsubsection*{Metodi}
\begin{description}
  \item{\method{+ onShowMainPanel(): void}}\\
  Questo gestore di eventi è richiamato nel momento in cui è sollevato un evento avente come nome identificativo la stringa \texttt{showMainPanel} e ha il compito di provocare il caricamento del \inglese{template} del pannello e, in seguito, di demandare al metodo \method{display()} della vista la sua inizializzazione.
  
  \item{\method{+ onRemoveMainPanel(): void}}\\
  Questo gestore di eventi è richiamato nel momento in cui è sollevato un evento con nome identificativo \texttt{removeMainPanel} e ha il compito di richiamare il metodo \method{destroy()} della vista corrispondente.

\end{description}

\classsection{ToolsPanelPresenter}

\subsubsection*{Funzione}
\inglese{Presenter} che ha il compito di gestire il pannello degli strumenti.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
\item{\memberdata{-- thisPanel: HTMLElement}}\\
Riferimento all'elemento HTML, da intendersi come nodo DOM, che corrisponde al pannello degli strumenti e che nello specifico è rappresentato da un elemento \verb'<div>' avente come identificativo la stringa \verb'ToolsPanel'.
\end{description}

\subsubsection*{Metodi}
\begin{description}
  \item{\method{+ onShowToolsPanel(): void}}\\
  Questo gestore di eventi è associato all'evento con identificativo \texttt{showToolsPanel} e ha il compito di provocare la visualizzazione del pannello degli strumenti sulla parte sinistra dell'interfaccia grafica. Il metodo dovrà avere il compito di caricare il \inglese{template} della vista dal server. L'inizializzazione del pannello sarà quindi demandata in un secondo momento alla vista, tramite il metodo \method{initialize} fornito da quest'ultima.
  
  \item{\method{+ onRemoveToolsPanel(): void}}\\
  Questo gestore di eventi viene associato come risposta del \inglese{presenter} nel momento in cui viene sollevato un event con nome identificativo uguale a \verb'removeToolsPanel'. Il metodo dovrà provocare l'eliminazione dall'interfaccia grafica del pannello degli strumenti, demandando alla vista la propria rimozione dall'albero DOM tramite il metodo \method{destroy()} messo a disposizione da quest'ultima.
  
  \item{\method{+ onShowReturnToCommunicationPanelButton(): void}}\\
  Questo gestore di eventi è invocato nel momento in cui si attiva una comunicazione di qualsiasi natura (audio, audio/video o testuale) e provoca l'aggiunta di un nuovo pulsante nel pannello grafico tramite il metodo \method{addCommunicationFunction()} fornito dalla vista. Lo scopo di tale pulsante è permettere di tornare al pannello della comunicazione in un secondo momento, dopo che si è passati alla visualizzazione di un altro pannello.
  
  \item{\method{+ onLogout(): void}}\\
  Questo gestore di eventi viene richiamato al verificarsi dell'evento \verb'logout' e ha il compito di effettuare l'uscita dal sistema. In particolare, nel corpo del metodo dovrà essere creata una nuova \verb'XMLHttpRequest' da inviare all'indirizzo del \inglese{front controller} presente sul server, nella cui \inglese{query string} sarà presente il parametro \verb'operation=logout' per permettere il corretto smistamento della richiesta.
  
  Infine, dal momento che il server risponde con una stringa \verb'true' o \verb'false', il metodo ha il compito di effettuare la deserializzazione con \verb'JSON.parse(request.responseText)' e nel caso in cui il risultato fosse valutato negativamente, provocare la visualizzazione di un generico messaggio d'errore.
\end{description}

\classsection{AccountSettingsPanelPresenter}
\subsubsection*{Funzione}
\inglese{Presenter} incaricato di gestire il pannello delle impostazioni e dei dati personali dell'utente visualizzando i dati inseriti in fase di registrazione e permettendo di modificarli in un secondo momento.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
\item{\memberdata{-- thisPanel: HTMLElement}}\\
Attibuto che rappresenta un riferimento all'elemento HTML, da intendersi come nodo DOM, che rappresenta la radice del pannello associato a questo \inglese{presenter} ed è costituito da un \verb'<div>' avente come identificativo la stringa \verb'AccountSettingsPanel'.
\end{description}

\subsubsection*{Metodi}
\begin{description}

\item{\method{-- hasSomethingChanged(data: Object): Boolean}}\\
L'oggetto passato come parametro in ingresso a questo metodo è costituito dalle proprietà \verb'name', \verb'surname' e \verb'picturePath' che rappresentano gli unici dati utente che sono suscettibili di possibili modifiche. Il metodo dovrà restituire \verb'true' se almeno una di queste proprietà ha un valore diverso rispetto alle informazioni che sono memorizzate nel client  e \verb'false' altrimenti.

\item{\method{+ sendUserData(data: Object): Boolean}}\\
Il metodo ha il compito di gestire la modifica dell'utente ai propri dati verificando innanzitutto se essi hanno subito qualche variazione rispetto a quanto noto in precedenza, mediante una chiamata al metodo \method{hasSomethingChanged}. In caso affermativo, dovrà essere inviata una richiesta all'indirizzo del \inglese{front controller} per trasferire la modifica sui dati salvati sul database del server.

A tale scopo dovrà essere creata una nuova istanza di \verb'XMLHttpRequest' per effettuare una richiesta AJAX sincrona, con particolare attenzione a utilizzare un'istanza di \inglese{form data} dal momento che dovranno essere spediti anche dati di natura non testuale, con una sintassi del tipo:
\begin{verbatim}
  var form = new FormData();
  formData.append("operation", "accountSettings");
        ...altri valori da inviare...
  var request = new XMLHttpRequest();
  request.open("POST", controllerURL, false);
  request.send(form);
\end{verbatim}

Da ultimo, il metodo dovrà restituire il valore ottenuto deserializzando il testo della risposta ottenuta dal server, che è \verb'true' se l'operazione è andata a buon fine e \verb'false' altrimenti.

\item{\method{+ onShowAccountSettingPanel(): void}}\\
Questo gestore di eventi viene attivato al verificarsi dell'evento \verb'showAccountSettingPanel' e determina il caricamento del \inglese{template} che corriponde al pannello delle impostazioni utente, demandando in un secondo momento alla vista il compito di inizializzare il comportamento del pannello mediante il metodo \verb'display()' che essa mette a disposizione.

\end{description}

\classsection{MessagePanelPresenter}

\subsubsection*{Funzione}
\inglese{Presenter} incaricato di gestire i messaggi in segreteria che permette di scaricarli dal server, eliminarli e impostarne lo stato.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
 \item{\memberdata{-- messages: Array}}\\
 Array destinato a contenere la lista dei messaggi della segreteria il cui destinatario è l'utente del client.

 \item{\memberdata{-- thisPanel: HTMLElement}}\\
  Riferimento all'elemento HTML, da intendersi come nodo DOM, che rappresenta il pannello della segreteria ed è concretamente un \verb'<div>' con identificativo uguale a \verb'MessagePanel'.
\end{description}

\subsubsection*{Metodi}
\begin{description}

  \item{\method{-- getMessages(): Array}}\\
  Ottiene i messaggi di segreteria salvati nel server creando una nuova \verb'XMLHttpRequest' da inviare all'indirizzo del \inglese{front controller} del server per realizzare una richiesta AJAX sincrona nella cui \inglese{query string} dovrà obbligatoriamente essere presente il parametro \verb'operation', con una sintassi del tipo:
  \begin{verbatim}
    request.send("operation=getMessages");
  \end{verbatim}
  
  Dal momento che il server risponde con la versione serializzata in JSON della lista di messaggi desiderata, il metodo dovrà limitarsi a restituire il risultato dell'invocazione di \verb'JSON.parse(request.responseText)'.
  
    \item{\method{+ setStatus(message: Object, valueToSet: Boolean}}\\
  Imposta lo stato di un messaggio come ``nuovo'' oppure ``già letto'' a seconda del parametro ricevuto in input. Tale metodo ha il duplice compito di modificare lo stato del messaggio ricevuto come parametro in base al valore di \verb'valuteToSet' e quindi inviare una richiesta AJAX sincrona al server che contiene la \inglese{query string}
  \begin{verbatim}
    "operation=updateMessage&idMessage=" + message.id +
               "&read=" + valueToSet
  \end{verbatim}
  
  Poiché il server restituisce le stringhe \verb'"true"' o \verb'"false"' che corrispondono alla rappresentazione in formato JSON delle omonime costanti letterali del linguaggio, sarà sufficiente che il metodo restituisca il risultato dell'espressione \verb'JSON.parse(request.responseText)'.
  
  \item{\method{+ displayList(): void}}\\
  Tale metodo ha il compito di popolare la vista con i messaggi della segreteria telefonica provvedendo in primo luogo a scaricarli dal server mediante il metodo \method{getMessages()} al fine di inizializzare l'attributo \memberdata{messages}, quindi aggiornare la vista in maniera corrispondente invocando per ognuno dei messaggi scaricati in precedenza il metodo \method{addListItem} messo a disposizione dalla vista.
  
  \item{\method{+ deleteMessage(message: Object) Boolean}}\\
  Elimina un messaggio dalla segreteria inviando all'indirizzo del \inglese{front controller} del server una richiesta AJAX sincrona tramite un'istanza di \verb'XMLHttpRequest' che contiene la \inglese{query string}
  \begin{verbatim}
    "operation=deleteMessage&idMessage=" + message.id
  \end{verbatim}
  
  Poiché il server restituisce le stringhe \verb'"true"' o \verb'"false"' che corrispondono alla rappresentazione in formato JSON delle omonime costanti letterali del linguaggio, sarà sufficiente che il metodo restituisca il risultato dell'espressione \verb'JSON.parse(request.responseText)'. In caso di errore, inoltre, dovrà comparire un messaggio d'errore indicante il motivo.
  
  \item{\method{+ onShowMessagePanel(): void}}\\
  Questo gestore di eventi viene attivato al verificarsi dell'evento \verb'showMessagePanel' e determina il caricamento del \inglese{template} che corrisponde al pannello della segreteria telefonica, demandando in un secondo momento alla vista il compito di inizializzare il comportamento del pannello chiamando il metodo \method{display()} messo a disposizione dalla vista.
  
\end{description}

%********************************************************************
%     QUESTO È IL CONFINE FRA BENE E MALE - SIETE AVVERTITI!
%********************************************************************

\classsection{AddressBookPanelPresenter}

\subsubsection*{Funzione}
Presenter incaricato di gestire il pannello della rubrica, contiene le funzioni associate ai \inglese{widget} grafici della vista relativi a quest'ultima e ha la responsabilità di aggiornare la vista sulla base dei dati ricevuti dal \inglese{server}.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}

  \item{\memberdata{-- element: DOM\_node}}\\
  Attributo che definisce il contenuto del nodo DOM inerente alla rappresentazione della rubrica. Nello specifico tale nodo corrisponde ad un \texttt{div} con id \texttt{AddressBookPanel}.
  \item{\memberdata{-- urlServlet: String}}\\
  Attributo che definisce l'URL dal quale è richiamabile la \textit{servlet} usata per interagire con l'apparato server del sistema.
  \item{\memberdata{-- suffix: String}}\\
Suffisso da concatenare all'url per richiamare le \inglese{servlet} appropriate.  
  \item{\memberdata{-- contacts: Array()}}\\
  Attributo che definisce la lista degli utenti presenti nella rubrica dell'utente che ha effettuato l'autenticazione.
   \item{\memberdata{-- groups: Array()}}\\
  Attributo che definisce la lista dei gruppi presenti nella rubrica dell'utente che ha effettuato l'autenticazione. Pero ogni gruppo sono  elencati i contatti contenuti in esso.
   \item{\memberdata{-- operations: String[]}}\\ 
   \inglese{Array} di stringhe usato per memorizzare i nomi delle istruzioni eseguibili, essi rappresentano una parte del nome della \inglese{servlet} incaricata a risolvere l'operazione descritta (e.g. GetContacts rappresenta l'operazione svolta dalla \inglese{servlet} avente nome: \memberdata{urlServlet} concatenato a ``GetContactsServlet''). I valori con i quali si dovrà caricare \memberdata{operations}) sono:
   \begin{itemize}
   	\item GetContacts;
    \item DoAddContact;
    \item DoDeleteContact;
    \item DoInsertInGroup;
    \item DoRemoveFromGroup;
    \item DoCreateGroup;
    \item DoDeleteGroup;
    \item GetGroups;
    \item DoBlock;
    \item DoUnblock;
    \item DoSearch;
   \end{itemize}

\end{description}

\subsubsection*{Metodi}
\begin{description}	
	
	\item{\method{+ inizialize(): void}}\\
	Metodo per inizializzare  \texttt{AddressBookPanel} e popolarlo con i contatti della rubrica, modifica il DOM creando tre div: divSearch, divSort e divList. Quindi sequenzialmente ne crea il contenuto:
		\begin{itemize}
			\item divSearch: definisce un campo per l'\inglese{input} testuale e un bottone per ricercare nella lista un utente avente avete tra le parole chiave, una con valore uguale a quello inserito nel campo d'\inglese{input}.
			\item divSort: crea delle \inglese{select} per specificare le tipologie di ordinamento attuabili sulla lista degli utenti.
			\item divList: \textit{div} che viene popolato con i nomi degli utenti presenti nella rubrica dell'utente che l'ha richiamata.
		\end{itemize}

Quindi dopo aver creato questi elementi il metodo procede inserendo nel DOM il ``sotto-albero'' cosi creato.

	\item{\method{- getAddressBookContacts(): void}}\\
Metodo che recupera i contatti e i gruppi della propria rubrica dal server usando la tecnologia AJAX. Il metodo crea una variabile contenente un istanza \texttt{XMLHttpRequest()}. Quindi con metodo \inglese{POST} inoltra la richiesta alla \inglese{servlet} il cui indirizzo è generato dalla concatenazione di \memberdata{urlServlet} con \memberdata{operation[1]}. Elabora quindi i dati ottenuti mediante il metodo \texttt{JSON.parse()} e li salva negli \textit{array} \memberdata{contacts} e \memberdata{groups}.
	
	\item{\method{+ setup(): void}}\\
	Inserisce i contatti estratti dal \textit{server} all'interno della lista \texttt{AddressBookList} all'interno di \texttt{AddressBookPanel}.
	
	\item{\method{+ displayContactList(contact: String[]): void}}\\
	Metodo usato per visualizzare la lista dei contatti utente, esso prende il nodo DOM (già esistente) e destinato a contenere la lista dei contatti, popolandolo richiamando il metodo \method{addListItem()}.
	
	\item{\method{-- addListItem(list: DOM\_node, contact: Object(contact): void}}\\

Metodo richiamato da \method{displayContactList()} per visualizzare i contatti presenti della rubrica, crea le variabili contenenti i dati del contatto da attribuire al \textit{tag} di \textit{markup} \texttt{li}. Tali variabili sono quelle tipiche di un oggetto Object(contact) (nome, cognome, email, status e immagine).


\item{\method{-- addOptionToSelect(select: DOM\_element, value: String, text: String): void}}\\
Metodo utilizzato per aggiungere un'opzione all'elemento \memberdata{select} ricevuto come parametro dal metodo. Ha il compito di creare un \texttt{TextNode} ed appenderlo alla \memberdata{select}.

	
	\item{\method{+ addContact(contact: Object(contact)): boolean}}\\
	Metodo per l'aggiunta di un contatto alla rubrica, riceve come parametro un oggetto di tipo contatto da inserire, appunto, nella propria rubrica. 
Per assicurarsi di non introdurre ridondanza ed aggiungere un contatto già presente il metodo esegue due controlli: uno lato \inglese{client} e uno lato \textit{server}. 
Il controllo lato \inglese{client}, si scorre la lista \memberdata{contact} alla ricerca di un \texttt{contact} che cerca un \inglese{match} con il nuovo contatto. Nel caso sia già presente il metodo termina ritornando \inglese{false}. Per eseguire il controllo lato \inglese{server} il metodo contatta il \inglese{server} mediante la \inglese{servlet} \texttt{AddressBookDoAddContatctServlet}, questa verificherà se l'utente avente \texttt{id} \textit{contact} è già presente nella rubrica, nel caso non lo sia si occuperà di creare la nuova istanza di \texttt{AddressBookEntry} e la registrerà nel database, in caso contrario non esegue operazioni. 
La chiamata a \inglese{servlet} ritorna un valore booleano che sarà \textit{true} se l'inserimento ha avuto successo, \textit{false} altrimenti. 
Se l'inserimento ha avuto successo il flusso principale prosegue eseguendo l'aggiornamento della rubrica in locale tramite la chiamata a metodo \method{setup()}. Il metodo termina infine ritornando \textit{true} se è stato aggiunto l'utente, altrimenti solleva un'eccezione.

	\item{\method{+ removeContact(contact: Obj): boolean}}\\
Metodo il cui funzionamento è analogo a quello precedentemente definito, si occupa di eliminare un contatto conoscendone l'\texttt{id} passato per parametro d'ingresso. Il flusso principale esegue due controlli per verificare la presenza dell'utente nella rubrica (analogamente a quanto visto nel caso precedente). 
Dopo tale verifica, se il contatto è realmente presente nella rubrica, la \inglese{servlet} \texttt{AddressBookDoRemoveContactServlet} avrà eseguito la cancellazione come conseguenza al match effettuato in fase di verifica, nel caso il metodo richiama \method{setup()} per rieseguire l'aggiornamento della rubrica. Il metodo ritorna infine \textit{true} se effettivamente il contatto era presente ed è stato eliminato, altrimenti solleva un'eccezione.

	\item{\method{+ addGroup(name: String): boolean}}\\
	Metodo per l'aggiunta di un nuovo gruppo nella rubrica, permette l'aggiunta di gruppi con nomi duplicati (ossia nomi di gruppi già presenti nella rubrica). Il flusso principale richiama la \inglese{servlet} \texttt{AddressBookDoCreateGroupServlet} con il nome del gruppo da creare. Successivamente, se la \inglese{servlet} ha dato \method{setup()} esito positivo, viene richiamata il metodo \inglese{setup} che aggiorna la rubrica locale, altrimenti solleva un'eccezione.
	
	\item{\method{+ deleteGroup(idGroup: int): boolean}}\\
	Metodo per l'eliminazione di un nuovo gruppo presente nella rubrica, riceve come parametro d'ingresso l'\texttt{id} del gruppo da eliminare. Il flusso principale richiama la \inglese{servlet} \texttt{AddressBookDoRemoveGroupServlet} passandogli l'\texttt{id} del gruppo candidato all'eliminazione. Quindi, se la \inglese{servlet} notifica l'effettiva esistenza di un gruppo con tale \texttt{id}, essa si occupa dell'eliminazione e il flusso principale prosegue richiamando il metodo \inglese{setup} se la eliminazione ha avuto buon fine, altrimenti solleva un'eccezione.
	
	\item{\method{+ addContactInGroup(contact: Object(contact), group: Object(contact)): boolean}}\\
	Metodo per l'aggiunta di un contatto in un gruppo ben definito, riceve come parametro d'ingresso il contatto e il gruppo.
Il metodo richiama da prima \method{contactExistInGroup}, successivamente il flusso principale richiama la \inglese{servlet} \texttt{AddressBookDoInsertInGroupServlet} passandogli i parametri d'ingresso, quindi se la \inglese{servlet} notifica l'effettiva esistenza di un gruppo con il nome ricevuto, essa si occupa di aggiungervi il contatto e il flusso principale ritorna al metodo \method{setup()} per aggiornare la rubrica in locale, ritorna infine un \inglese{feedback} booleano a \textit{true} per dare notifica se l'operazione ha avuto buon fine, altrimenti solleva un'eccezione.
	
	\item{\method{+ deleteContactFromGroup(contact: Object(contact), group: Object(group)): boolean}}\\
	Metodo per l'eliminazione di un contatto presente in un gruppo, riceve come parametro d'ingresso il gruppo su cui effettuare la ricerca del contatto da eliminare e il contatto. 
Il metodo richiama da prima \method{contactExistInGroup}, poi Il flusso principale richiama la \inglese{servlet} \texttt{AddressBookDoRemoveFromGroupServlet} passandogli i parametri d'ingresso, la \inglese{servlet} notifica l'effettiva esistenza di un gruppo con il nome ricevuto che contiene il contatto candidato all'eliminazione, essa si occupa dell'eliminazione e il flusso principale ritorna al metodo \method{setup()} per aggiornare la rubrica in locale, ritorna infine un \inglese{feedback} booleano per dare notifica sull'esito dell'operazione: \textit{true}\textit{true} se è stato creato il nuovo gruppo, altrimenti solleva un'eccezione.
	
	\item{\method{- contactExistInGroup(contact: Object(contact), group: Object(group)): boolean}}\\
Metodo che verifica l'esistenza di un contato in un determinato gruppo, restituisce un \inglese{feedback} booleano per confermare o meno l'esistenza dell'utente ricercato nel gruppo designato.

\item{\method{+ applyFilterByString(param: String): array()}}\\
Metodo che data una stringa come parametro d'ingresso filtra la lista di contatti presente in locale. Non richiede interazione con il server, ovvero non vengono richiamate \inglese{servlet}.

In un primo step il programmatore dovrà creare un \inglese{array} atto a contenere l'elenco dei contatti da restituire, quindi il metodo procede con la definizione di un espressione regolare basata sul parametro ricevuto. Per tale operazione la sintassi obbligatoria è:\\

\verb|var pattern = new RegExp(param)|\\

Quindi viene avviato un ciclo \textit{for} che analizza ogni contatto presente in \memberdata{contacts}. Successivamente si effettua un filtraggio sui campi \textit{name, surname, email} del contatto attualmente in esame. Per fare tali operazioni si dovrà usare:\\

\verb|pattern.test(\*elemento su cui ricercare param*\)|\\

Se tale filtraggio da esito positivo, il contatto viene aggiunto all'\textit{array} dei contatti da restituire. Il metodo termina quando, dopo aver eseguito il ciclo \textit{for}, il metodo ritorna l'\textit{array} sopracitato.

\item{\method{+ applyFilterByGroup(idGroup: int): array()}}\\
Metodo che dato un intero come parametro d'ingresso filtra la lista di contatti presente in locale, restituendo un elenco dei contatti appartenenti al gruppo avente id uguale a idGroup, inoltre non deve interagire con il \inglese{server}, ovvero non vengono richiamate \inglese{servlet}. 

Come per \method{applyFilterByString()} anche in questo caso il metodo deve creare un \textit{array} da popolare con i contatti appartenente al gruppo idGroup. Quindi viene eseguito un ciclo \inglese{for} che ispezione tutti i contatti presenti in \memberdata{contacts} e per ogni ciclo il metodo controlla i gruppi in cui compare il contatto i-esimo (tale azione si attua per mezzo di un secondo ciclo innestato), se si verifica una corrispondenza tra l'id del gruppo in esame con l'identificativo idGroup, si aggiunge il contatto all'\textit{array} creato in precedenza. Il metodo termina restituendo l'\textit{array} sopra-citato.

\item{\method{+ showFilter(filteredContacts: Array()): void}}\\
Metodo usato per l'eliminare il contenuto preesistente nella rubrica e visualizza il nuovo contenuto filtrato. Il metodo riceve come parametro un \textit{array} che rappresenta la lista filtrata dei contatti da visualizzare. Per eseguire tali operazioni viene avviato un ciclo \inglese{for} per ogni contatto presente in \memberdata{contacts}. All'interno di tale ciclo deve essere eseguita la seguente istruzione:\\

\verb|addListItem(/*nome della variabile contenente il nodo dom AddressBookList*/,|\\
\verb|filtredContacts[contact])|\\

\item{\method{+ contactAlredyPresent(contact: Object(contact)): boolean}}\\
Metodo che dato un contatto verifica se appartiene alla rubrica. Per compiere tale azione viene da prima riscaricata la rubrica, mediante una chiamata a metodo \method{getAddressBookContacts()}. Quindi si usa un ciclo \inglese{for} per scorrere l'intera lista precedentemente ottenuta e ad ogni ciclo si controlla se il contatto i-esimo ha id uguale a quello del contatto ricevuto come parametro d'ingresso (\texttt{contact.id}). Se tale confronto ha esito positivo, il metodo termina ritornando \inglese{true}, altrimenti il metodo termina al termine del ciclo \inglese{for} ritornando \inglese{false}.

\item{\method{+ blockUser(contact: Object(contact)): boolean}}\\
Metodo utilizzato per bloccare (all'interno della rubrica utente) il contatto contact passato come parametro d'ingresso. Il primo step consiste nell'eseguire il controllo sul parametro ricevuto. Per farlo si osserva il valore ritornato da una chiamata a metodo \method{constactAlradyPresent()} passando come parametro d'ingresso contact. Se il valore di ritorno è \inglese{false} il metodo termina con l'eccezione ``Contatto non presente nella rubrica''. Altrimenti il controllo passa allo step successivo, in cui si verifica se l'attributo blocked di contact è impostato a \inglese{true}. Nel caso il metodo termina con l'eccezione ``Contatto già bloccato''. Se il flusso principale ha superato i test precedenti, allora viene creata un istanza di request \texttt{XMLHttpRequest()} usata per contattare la \inglese{servlet} avente nome:\\

\verb|urlServlet + operations[8] + suffix|\\

Per tale richiesta deve essere associata, all'evento \texttt{onreadystatechange}, una funzione che salva in un array il contenuto di una chiamata:\\

\verb|JSON.parse(request.responseText)|\\

Il flusso principale prosegue aprendo la request cosi definita (uso del metodo \texttt{open("POST", urlServlet + operations[8] + suffix, "true")}) e inviando il contatto mediante una chiamata \texttt{request.send("contactId=" + contact.id)}.

Il metodo termina eseguendo un controllo. Se il risultato result della chiamata a \inglese{servlet} ha valore \inglese{true} allora il metodo termina aggiornando la rubrica mediante una chiamata \method{setup()} e ritornando \inglese{true}. In caso contrario il metodo termina con un eccezione.

\item{\method{+ unlockUser(contact: Object(contact)): boolean}}\\
Metodo usato per sbloccare un utente all'interno di una rubrica. Il metodo ha un funzionamento analogo al precedente, nello specifico vengono attuati gli stessi controlli prima tramite \method{contactAlradyPresent()} e poi tramite la verifica del contenuto del di contact.block. Successivamente si crea una XMLHttpRequest che si appoggia alla \inglese{servlet} definita dalla stringa:\\

\verb|urlServlet + operations[9] + suffix|\\

Tale server ha il compito di sbloccare il contatto \textit{contact}. Quindi il metodo termina eseguendo un controllo sul tipo di risultato. Se l'operazione precedente è avvenuta con successo allora si procede aggiornando la rubrica (chiamata a metodo \method{setup()}), altrimenti il metodo termina con un eccezione.

\item{\method{+ getGroupsWhereContactsIs(contact: Object(contact)): Object(group)}}\\
Tale metodo ha il compito, dato un utente, di ritornare una lista di gruppi in cui esso è presente. Riceve come unico parametro il contatto da ricercare e successivamente vengono ciclati tutti i gruppi e per ogni gruppo si controlla se è inserito il contatto, in caso di match viene aggiunto il gruppo alla lista di gruppi da ritornare.

\end{description}

%TODO da verificare
\classsection{CommunicationPanelPresenter}

\subsubsection*{Funzione}
Questo presenter ha il compito di gestire tutte le comunicazioni che possono avvenire tra persone, quindi sia di natura testuale che di tipo audio - audio/video.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
\item{\memberdata{-- chatElements: HTMLDivElements[]}}\\
  array associativo contenente tutte le chat aperte in un dato momento.
\end{description}

\subsubsection*{Metodi}
\begin{description}
\item{\method{- createLabel(user: Object(contact)): String}}\\
	Metodo che dato un utente (parametro del metodo), restituisce una stringa identificativa per il contatto in questione. Più precisamente, se il contatto contiene sia il nome che il cognome, la stringa restituita sarà composta da questi due elementi, altrimenti in base ai casi solo il nome o il cognome. Nell'ulteriore caso non siano presenti ne il nome ne il cognome, restituisce l'email, campo dati obbligatorio in fase di registrazione e quindi sempre presente.

\item{\method{- createChatItem(user: Object(contact)): DOM\_node}}\\
	Tale metodo restituisce un DOM\_element di tipo <li> contenente l'identificativo dell'utente con cui si sta comunicando (parametro del metodo). All'oggetto restituito viene assegnato un ``id'' corrispondente all'``id'' dell'utente con cui si vuole dialogare. All'evento \textit{onClick} viene collegato l'invocazione del metodo \method{displayChat(user)} che fa visualizzare la chat, viene inoltre creato il bottone per chiudere la chat che con l'evento ``onclick'' richiama il metodo \method{removeChat(user)}.

\item{\method{- createChatElement(user: Object(contact)): DOM\_node}}\\
	Tale metodo restituisce un DOM\_element contenente un \textit{div} che rappresenta l'area di chat. A tale elemento viene assegnato un ``id'' impostato a ``divContainerChat''. Deve essere creato anche una \textit{form} assegnando l'``id'' dell'utente come valore all'attributo ``id'' a tale \textit{form} va aggiunto una \textit{textarea} con \textit{id} impostato a \textit{chatText} dove andrà visualizzata la cronologia della chat; una casella di input con \textit{id} uguale \textit{input}; un bottone per inviare il messaggio assegnandogli all'evento \textit{onClick} l'invocazione del metodo \method{send(user, text)} del \textit{CommunicationPanelPresenter}. Infine viene aggiunta la \textit{form} all'elemento \textit{div} e ritornato.
	
\item{\method{+ displayChat(user: Object(contact)): void}}\\
Provoca la visualizzazione della chat con l'utente (ricevuto da parametro) nel \textit{div} contenitore pertinente.

\item{\method{+ addChat(user: Object(contact)): void}}\\
Provoca l'aggiunta di una chat, con l'utente ricevuto come parametro, andando ad aggiornare il campo privato \textit{chatElements} e visualizzandola nell'elemento ulOpenChat.
	
\item{\method{+ removeChat(user: Object(contact)): void}}\\
Comportamento simile al metodo scritto precedentemente. Viene chiusa una chat aperta con l'utente ricevuto da parametro andando ad eliminare l'elemento corrispondente da \textit{chatElements} e rimuovendo anche il DOM\_element dall'ulOpenChat.

\item{\method{+ appendToChat(user: Object(contact), text: String): void}}\\
Il metodo ha il compito di aggiunge una stringa \textit{text} all'interno dell'area di testo che è associata alla chat con l'utente \textit{user} (parametro del metodo).

\item{\method{+ createPanel(): DOM\_node}}\\
Con l'invocazione di tale metodo, viene inizializzato il pannello costruendo i \inglese{widget} grafici interni e lo restituisce in modo che possa essere inserito all'interno del pannello principale. Più dettagliatamente, deve costruire:
\begin{itemize}
\item div relativo alla chiamata assegnandogli come ``id'' CommunicationPanel;
\item div relativo alla gestione della chiamta assegnandogli come ``id'' divCall;
\item div relativo alla chat testuale assegnandogli come ``id'' divChat;
\item elemento video per la visualizzazione del proprio stream ricavato dalla videocamera con ``id'' myVideo;
\item elemento video per la visualizzazione dello \textit{stream} dell'altro utente con \textit{id} otherVideo;
\item div dove inserire la visualizzazione delle statistiche della chiamata tra cui:
\begin{itemize}
\item elemento ``span'' per byte Ricevuti con \textit{id}= statReceived;
\item elemento ``span'' per byte Inviati con \textit{id}= statSend;
\item elemento ``span'' per il tempo con \textit{id}= timerSpan;
\end{itemize}
\item bottone per la terminazione della chiamata che all'evento \textit{onClick} richiama il metodo \method{endCall()} di communicationcenter;
\item elemento div contenente le chat aperte.
\end{itemize}
Tutti gli elementi sopra descritti andranno poi aggiunti al parametro di ritorno \textit{element} tramite la funzione \method{appendChild()} fornita dai DOM\_element.

\item{\method{+ updateTimer(text: String): void}}\\
Il metodo aggiorna il tempo di comunicazione durante una chiamata. Imposta il campo \textit{value} dello \inglese{span} relativo alla visualizzazione del tempo chiamata con il valore del parametro ricevuto in input (text).

\item{\method{+ updateStats(text: String, isReceivedData: boolean): void}}\\
Il metodo controlla tramite il parametro booleano ricevuto in input (isReceivedData) se bisogna aggiornare lo span relativo ai dati inviati oppure lo span relativo ai dati ricevuti e lo imposta con il valore \textit{text} ricevuto per parametro.

\item{\method{+ getMyVideo(): DOM\_element}}\\
Il metodo ritorna l'elemento DOM con \textit{id} uguale ad ``myVideo''.

\item{\method{+ getOtherVideo(): DOM\_element}}\\
Il metodo ritorna l'elemento DOM con \textit{id} uguale ad ``otherVideo''.

\end{description}

\classsection{ContactPanelPresenter}

\subsubsection*{Funzione}
Presenter incaricato di gestire il pannello che visualizza le informazioni di un singolo contatto.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}

Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
\item{\memberdata{-- element: DOM\_element}}\\
  elemento controllato dal presenter in questione.
\end{description}

\subsubsection*{Metodi}
\begin{description}
\item{\method{- adjustBlockButtonDisplay(contact: Object(contact)): void}}\\
	Il metodo riceve come parametro un contatto (\textit{contact}), successivamente viene controllato se tale utente è bloccato o meno e imposta correttamente la proprietà \textit{style} agli elementi della vista. più dettagliatamente:\\
se il contatto è bloccato:
\begin{itemize}
\item nascondo il bottone per bloccare un utente;
\item mostro il bottone per sbloccare un utente
\end{itemize}
altrimenti\\
\begin{itemize}
\item mostro il bottone per bloccare un utente;
\item nascondo il bottone per sbloccare un utente
\end{itemize}


\item{\method{- buildGroupsDiv(contact Object(contact)): void}}\\
Il metodo, che riceve come parametro un contatto (\textit{contact}, ha il compito di recuperare tutti i gruppi 
 a cui il contatto appartiene e visualizzare nel \textit{div} opportuno una \textit{label} per ogni gruppo trovato indicandone il nome. 

\item{\method{+ createPanel():DOM\_element}}\\
Metodo richiamato quando viene selezionato un contatto dalla rubrica. Inizializza il pannello che mostra le informazioni del contatto selezionato. Più precisamente, verranno creati tanti listItem (<li>) quanti i seguenti elementi:
\begin{itemize}
\item nome;
\item cognome;
\item email;
\item avatar raffigurante l'immagine del contatto;
\item div contenente i gruppi a cui il contatto appartiene;
\item pulsante per la chiamata audio;
\item pulsante per la chiamata video;
\item pulsante per avviare una chat;
\item pulsante per bloccare il contatto;
\item pulsante per sbloccare il contatto.
\end{itemize}
Infine ritorno l'elemento creato.
	
\item{\method{+ display(contact: Object(contact)): void}}\\
Metodo che popola nel corretto modo tutti gli elementi necessari per la visualizzazione di un utente. Prima di tutto quindi si recupereranno tutti gli elementi necessari, ossia:
\begin{itemize}
\item elemento per nome;
\item elemento per cognome;
\item elemento per email;
\item elemento per avatar;
\item pulsante per aggiungere un contatto alla rubrica;
\item pulsante per la chiamata audio;
\item pulsante per la video-chiamata;
\item pulsante per avviare una chat;
\item pulsante per bloccare il contatto;
\item pulsante per sbloccare il contatto.
\end{itemize}
Successivamente si andranno a popolare tali elementi utilizzando le informazioni del contatto passato come parametro (\textit{contact}), infine si imposterà correttamente il comportamento dei bottoni associando le giuste chiamate a metodi del \textit{mediator}, ossia:
\begin{itemize}
\item aggiungi contatto --> onContactAdded(contact.id);
\item blocca contatto --> onBlockContact();
\item sblocca contatto --> onUnlockContact();
\item chiamata audio --> onCall(contact, false);
\item chiamata video --> onCall(contact, true);
\item avvia chat --> onChatStarted(contact);
\end{itemize}

\end{description}

\classsection{PresenterMediator}

\subsubsection*{Funzione}
Presenter incaricato di gestire la collaborazione tra i vari sotto-presenter.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
\item{\memberdata{-- presenters: Array associativo}}\\
  \textit{array} contenente tutti i sotto-presenter.\\
  Presenter di primo livello:
  \begin{itemize}
  \item login --> LoginPanelPresenter;
  \item register --> RegisterPanelPresenter;
  \item addressbook --> AddressBookPanelPresenter;
  \item tools --> ToolsPanelPresenter;
  \item main --> MainPanelPresenter.
  \end{itemize}
  Presenter di secondo livello:
  \begin{itemize}
  \item accountsettingspp --> AccountSettingsPanelPresenter;
  \item communicationpp --> CommunicationPanelPresenter;
  \item contactpp --> ContactPanelPresenter;
  \item callhistorypp --> CallHistoryPanelPresenter;
  \item messagepp --> MessagePanelPresenter;;
  \item searchresultpp --> SearchResultPanelPresenter;
  \item grouppp --> GroupPanelPresenter.
  \end{itemize}
\end{description}

\subsubsection*{Metodi}
\begin{description}
\item{\method{- getCommunicationPP(): CommunicationPanelPresenter}}
Il metodo restituisce l'istanza dell'attributo di tipo  CommunicationPanelPresenter.

\item{\method{+ buildUI(): void}}\\
Tale metodo ha il compito di inizializzare l'interfaccia grafica delegando ai presenter il compito di disegnare gli elementi principali dell'interfaccia, incaricando i presenter di primo livello di creare e popolare i rispettivi pannelli. In particolare, si nasconderanno i seguenti pannelli:
\begin{itemize}
\item register;
\item login;
\item addressbook;
\item main;
\item tools.
\end{itemize}


\item{\method{+ buildLoginUI(): void}}\\
Visualizza l'interfaccia di autenticazione al sistema, che comprende il \textit{form} di \textit{login}. Viene chiamato quindi il metodo \method{initialize()} del LoginPanelPresenter per la sua costruzione.
	
\item{\method{+ buildRegistrationUI(): void}}\\
Visualizza il form di registrazione al sistema, utilizzato dagli utenti che vogliono creare un nuovo account, viene chiamato quindi il metodo \method{initialize()} del RegisterPanelPresenter per la sua costruzione.

\item{\method{+ onContactSelected(contact: Object(contact)): void}}\\
Metodo invocato nel momento in cui viene selezionato un contatto, tale evento invoca il metodo \method{display} del ContactPanelPresenter prendendo come parametro l'oggetto \textit{contact} ricevuto inizialmente. 


\item{\method{+ onContactAdded(contact: Object(contact)): void}}\\
Funzione di \textit{callback} richiamata dai pulsanti di SearchResultPanel che comunica all'AddressBookPanelPresenter di aggiungere un contatto. Riceve come parametro l'utente che si vuole aggiungere (\textit{contact}), questo parametro viene a suo volta passato alla funzione \texttt{addContact()} di addressBookPanelPresenter. In caso di errore, viene segnalato con un \textit{alert}.

\item{\method{+ onContactRemoved(userID: String): void}}\\
Funzione di \textit{callback} richiamata dai pulsanti di SearchResultPanel che comunica all'AddressBookPanelPresenter di rimuovere un contatto. Il metodo riceve come parametro l'utente che si vuole rimuovere (contact). Questo parametro viene a suo volta passato alla funzione \texttt{removeContact()} di addressBookPanelPresenter. In caso di errore, viene segnalato con un \textit{alert}.

\item{\method{+ onGroupAdded(name: String): void}}\\
Funzione di \textit{callback} richiamata dai pulsanti di SearchResultPanel che comunica all'AddressBookPanelPresenter di aggiungere un gruppo. Il metodo riceve come parametro il nome del nuovo gruppo che si vuole aggiungere (name). Questo parametro viene a suo volta passato alla funzione addGroup() di addressBookPanelPresenter.


\item{\method{+ onGroupRemoved(group: object(group)): void}}\\
Funzione di \textit{callback} richiamata dai pulsanti di SearchResultPanel che comunica all'AddressBookPanelPresenter di rimuovere un gruppo. Il metodo riceve come parametro il gruppo che si vuole rimuovere (\textit{group}). Questo parametro viene a suo volta passato alla funzione \texttt{removeGroup()} di addressBookPanelPresenter.


\item{\method{+ onContactAddeddInGroup(contact: Object(contact), group: Object(group)): void}}\\
Funzione di \textit{callback} richiamata dai pulsanti di SearchResultPanel che comunica all'AddressBookPanelPresenter di aggiungere un contatto ad un gruppo. Il metodo riceve come parametro il contatto che si vuole aggiungere (\textit{contact}) e il gruppo a cui aggiungere il contatto (\textit{group}). Questi parametri vengono a suo volta passati alla funzione \texttt{addContactInGroup()} di addressBookPanelPresenter.


\item{\method{+ onContactRemovedInGroup(contact: Object(contact), group: Object(group)): void}}\\
Funzione di \textit{callback} richiamata dai pulsanti di SearchResultPanel che comunica all'AddressBookPanelPresenter di rimuovere un contatto da un gruppo. Il metodo riceve come parametro il contatto che si vuole rimuovere (\textit{contact}) e il gruppo a cui rimuovere il contatto (\textit{group}). Questi parametri vengono a suo volta passati alla funzione \texttt{removeContactFromGroup()} di addressBookPanelPresenter.


\item{\method{+ onBlockedContact(contact: Object(contact)): void}}\\
Funzione di \textit{callback} che comunica all'AddressBookPanelPresenter di bloccare un contatto. Il metodo riceve come parametro il contatto che si vuole bloccare (\textit{contact}), questo parametro viene a suo volta passato alla funzione \texttt{blockUser()} di addressBookPanelPresenter. In caso di errore, viene notificato con un \textit{alert} riportando l'errore relativo.


\item{\method{+ onUnlockContact(contact: Object(contact)): void}}\\
Funzione di \textit{callback} che comunica all'AddressBookPanelPresenter di sbloccare un contatto. Il metodo riceve come parametro il contatto che si vuole sbloccare (\textit{contact}), questo parametro viene a suo volta passato alla funzione \texttt{unlockUser()} di addressBookPanelPresenter. In caso di errore, viene notificato con un \textit{alert} riportando l'errore relativo.


\item{\method{+ displayMessagePanel(): void}}\\
Provoca la creazione del pannello della segreteria e la sua visualizzazione all'interno del MainPanel come elemento figlio. La costruzione del pannello è affidata al metodo \textit{createPanel} che viene reso disponibile da tutti i presenter di secondo livello, viene quindi creato dal metodo \method{createPanel()} del presenter messagePanelPresenter un elemento di tipo DOM\_node che viene poi passato al presenter \textit{main} come parametro del metodo \method{displayChildPanel}.


\item{\method{+ displayAccountSettingsPanel(): void}}\\
Provoca la creazione del pannello delle impostazioni dell'utente e la sua visualizzazione all'interno del MainPanel. Come il metodo sopra citato, viene creato dal metodo \method{createPanel()} del presenter CallHistoryPanelPresenter un elemento di tipo DOM\_node che viene poi passato al presenter \textit{main} come parametro del metodo \method{displayChildPanel}.


\item{\method{+ displayCallHistoryPanel(): void}}\\
Provoca la creazione del pannello dello storico delle chiamate e la sua visualizzazione all'interno del MainPanel. Come il metodo sopra citato, viene creato dal metodo \method{createPanel()} del presenter CallHistoryPanelPresenter un elemento di tipo DOM\_node che viene poi passato al presenter \textit{main} come parametro del metodo \method{displayChildPanel}.


\item{\method{+ onFiltredApplyedByParam(param: String): void}}\\
Funzione di \textit{callback} richiamata dai pulsanti di SearchResultPanel che comunica all'AddressBookPanelPresenter di filtrare la lista dei contatti secondo il parametro ricevuto (param). Viene scatenata l'invocazione del metodo \method{applyFilterByString} del presenter AddressBookPresenter passandogli come parametro \textit{param}.

\item{\method{+ getGroupsWhereContactsIs(contact: Object(contact)): void}}\\
Funzione di \textit{callback} che comunica all'AddressBookPanelPresenter di cercare i gruppi a cui appartiene un utente nella propria rubrica ricevuto come parametro (contact). Viene quindi invocato il metodo \method{getGroupsWhereContactIs()} del presenter AddressBookPanelPresenter.

\item{\method{+ displaySearchResultPanel(): void}}\\
Provoca la creazione del pannello delle impostazioni del proprio account e la sua visualizzazione all'interno del MainPanel. Viene creato dal metodo \method{createPanel()} del presenter AccountSettingsPanelPresenter un elemento di tipo DOM\_node che viene poi passato al presenter \textit{main} come parametro del metodo \method{displayChildPanel}.


\item{\method{+ displayCommunicationPanel(): void}}\\
Provoca la creazione del pannello delle comunicazioni e la sua visualizzazione all'interno del MainPanel. Viene creato dal metodo \method{createPanel()} del presenter CommunicationPanelPanelPresenter un elemento di tipo DOM\_node che viene poi passato al presenter \textit{main} come parametro del metodo \method{displayChildPanel}.

\item{\method{+ displayContact(contact: Object(contact)): void}}\\
L'invocazione di tale metodo provoca la visualizzazione della scheda di un contatto (contact) nel CommunicationpanelPresenter. Viene richiamato il metodo \method{displayCommunicationPanel()} e successivamente il metodo \method{display} passando come contatto il parametro ricevuto precedentemente.

\item{\method{+ contactAlreadyPresent(contact: Object(contact)): boolean}}\\
Metodo che controlla se l'utente ricevuto come parametro del metodo (contact) è gia presente nella rubrica. Viene invocato il metodo \method{contactAlreadyPresent()} di AddressBookPanelPresenter passando come parametro il contatto in questione.

\item{\method{+ onChatStarted(user: Object(contact)): void}}\\
Coordina i presenter nel momento in cui ha inizio una nuova comunicazione testuale e incapsula la collaborazione fra ContactPanelPresenter e CommunicationPanelPresenter. Viene quindi
\begin{itemize}
\item invocato il metodo \method{createPanel()} di CommunicationPanelPresenter;
\item invocato il metodo \method{displayChildPanel()} di MainPanelPresenter passandogli come parametro l'oggetto creato precedentemente;
\item invocato il metodo \method{addChat()} di CommunicationPanelPresenter passando come parametro l'utente interessato;
\item invocato il metodo \method{displayChat()} di CommunicationPanelPresenter passando come parametro l'utente interessato.
\end{itemize} 

\item{\method{+ onCall(contact: Object(contact), onlyAudio: boolean): boolean}}\\
Metodo per gestire la chiamata, riceve come parametri l'utente che si vuole chiamare (\textit{contact}) e un \textit{flag} per segnalare se la chiamata è solo audio (\textit{onlyAudio}).

\end{description}

\classsection{GroupPanelPresenter}

\subsubsection*{Funzione}
Presenter incaricato di gestire i gruppi.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
\item Nessun attributo presente.
\end{description}

\subsubsection*{Metodi}
\begin{description}
\item{\method{- addListItem(list: DOM\_element, group: Object(group)): void}}\\
Aggiunge alla lista ricevuta come parametro (\textit{list}) un gruppo, anch'esso ricevuto come parametro (\textit{group}) creando un listItem (<li>). Il \textit{list item} sarà composto da uno \textit{span} con il nome del gruppo e vicino dovrà apparire un'immagine per l'eliminazione del gruppo stesso. Va quindi gestito il comportamento all'evento ``onclick'' su tale immagine che comporterà l'eliminazione del gruppo. Prima di procedere alla vera e propria eliminazione, dovrà apparire all'utente un messaggio di conferma che chiede se effettivamente vuole cancellare il gruppo: se l'utente accetta, viene richiamato il metodo del MediatorPresenter \method{onGroupRemoved(group)} che procedere ad eliminare il gruppo.

\item{\method{+ createPanel(): DOM\_element}}\\
Costruisce il pannello per la gestione dei gruppi, che deve essere visualizzato all'interno del MainPanel dell'applicazione quando viene richiesta tale operazione. Il GroupPanel è costituito da una semplice lista contenente tanti \textit{list item} quanti sono i gruppi dell'utente.

\item{\method{+ displayGroupList(groups: Object(group)): void}}\\
Metodo che visualizza all'interno del pannello una lista di gruppi, tale metodo demanda la visualizzazione di ogni singolo gruppo richiamando il metodo \method{addListItem(groupList, group}.

\end{description}

\subsection{Package org.softwaresynthesis.mytalk.clientpresenter.kernel}\label{sec:kernel}
\classsection{CommunicationCenter}

\subsubsection*{Funzione}
Classe logica che gestisce tutta la parte della comunicazione lato \textit{client}.

\subsubsection*{Relazioni d'uso}
Nessuna relazione d'uso evidenziata.

\subsubsection*{Classi estese ed interfacce implementate}
Nessuna relazione evidenziata.

\subsubsection*{Attributi}
\begin{description}
\item{\memberdata{+ videoComunication: String[]}}\\
Array che contiene i dati della video-chiamata
\item{\memberdata{+ openChat: DOM\_element[]}}\\
Array che contiene i dati della video-chiamata
\item{\memberdata{- urlServlet: String}}\\
Contiene l'indirizzo della \inglese{servlet} che gestisce la comunicazione
\item{\memberdata{- my: String[]}}\\
Array contenente i dati personali dell'utente
\item{\memberdata{- websocket: Object()}}\\
Oggetto che rappresenta la \textit{websocket} da utilizzare per comunicare con il server. Il costruttore di tale oggetto richiede l'URL della \inglese{servlet}.

\end{description}

\subsubsection*{Metodi}
\begin{description}
\item{\method{- formatBytes(bytes: int): String}}\\
Metodo che formatta i byte ricevuti ed inviati al fine di fornire una visualizzazione sensata delle statistiche.\\
Il metodo riceve un numero rappresentante i \textit{bytes} (\memberdata{bytes} e li converte in KB/s o MB/s a seconda della grandezza.

\item{\method{- formatTime(tempo: int): String}}\\
Metodo che ritorna nel formato ``hh:mm:ss'' il tempo della comunicazione.\\
Il metodo riceve un numero rappresentante il tempo espresso in secondi (\memberdata{tempo}, lo converte nel formalismo descritto prima e lo restituisce.

\item{\method{- stopTimer(): void}}\\
Metodo che ferma l'aggiornamento del timer, viene richiamato quando la chiamata termina.

\item{\method{- stopStats(): void}}\\
Metodo che ferma l'aggiornamento delle statistiche relative alla chiamata in corso, viene richiamato quando la chiamata termina.

\item{\method{- dumpStats(obj: Object()): void}}\\
 Metodo che permette l'estrazione dei dati rappresentanti le statistiche della chiamata, esso riceve come parametro un oggetto (\memberdata{obj}), lo elabora, ed estrae solo i byte ricevuti e inviati. Ricavati questi dati, li visualizza nello \textit{span} corrispondente.
 
\item{\method{- gotDescription(): void}}\\
Metodo utilizzato da WebRTC che imposta la propria descrizione e la invia al \textit{client} chiamato in modo tale da poter instaurare la comunicazione. Verrà quindi prima di tutto utilizzata la funzione proprietaria di WebRTC \method{setLocalDescription} per impostare la propria descrizione e successivamente, mediante la \textit{websocket}, inviata al client \underline{peer} chiamato.
 
\item{\method{+ connect(): void}}\\
Metodo utilizzato per la creazione della connessione con il \textit{server}. Viene inizializzata la variabile \memberdata{websocket} richiamando il costruttore con un parametro (URL della servlet). Successivamente viene specificato il comportamento della \textit{websocket} per determinati eventi quali:
\begin{itemize}
\item \textbf{onopen}: istruzioni da eseguire quando la \textit{websocket} viene aperta. In questo caso, deve essere inviato alla \textit{websocket} il proprio \textit{id} utente in modo tale da identificare univocamente il canale aperto con il server.
\item \textbf{onclose}: istruzioni da eseguire quando la \textit{websocket} viene chiusa per qualsiasi motivo, notificando il server di tale avvenimento.
\item \textbf{onerror}: istruzioni da eseguire quando avviene un errore con la \textit{websocket}. Tale evento verrà notificato all'utente con un messaggio d'errore che descrive l'errore e l'atteggiamento da seguire.
\item \textbf{onmessage}: metodo più corposo in quanto gestisce l'unico evento richiamato mentre avviene una comunicazione dal server verso il \textit{client}. Per diversificare i messaggi ricevuti, si è deciso di rappresentare il messaggio come un \textit{array} nel quale il primo elemento identifica il tipo di richiesta. In questo modo, avremo tre tipi:
\begin{itemize}
\item type 2: riceve e gestisce una richiesta di chiamata. Imposta quindi con il metodo nativo di WebRTC \method{setRemoteDescription} la descrizione del \underline{peer} chiamante (secondo elemento dell'\textit{array} ricevuto) e la comunicazione può iniziare.
\item type 3: riceve una richiesta con l'\textit{id} del chiamante come dato. Viene memorizzato nel \textit{client} in modo tale da conoscere il canale che il chiamante ha aperto con il server per future comunicazioni.
\item type 5: notifica il cambiamento di stato degli amici. I dati ricevuti contengono l'\textit{id} dell'utente e relativo nuovo stato, si procede quindi a modificare lo stato dell'utente nella rubrica.
\end{itemize}
\end{itemize}
 
\item{\method{+ disconnect(): void}}\\
Metodo utilizzato per disconnettersi dal sistema, tale evento deve essere notificato al \textit{server} tramite la \textit{websocket} inviando un messaggio di tipo 4 contenente il proprio \textit{id}.

\item{\method{+ call(isCaller: boolean, contact: Object(contact)): void}}\\
Metodo che gestisce la vera e propria chiamata tramite WebRTC.\\
Inizialmente, si inizializza la variabile \memberdata{pc} che è di tipo RTCPeerConnection, oggetto reso disponibile dalle librerie di WebRTC, successivamente si definiscono i comportamenti associati agli eventi di RTCPeerConnection, ossia:
\begin{itemize}
\item onicecandidate: evento scatenato quando un nuovo \underline{peer} si ``candida'' per poter chiamare, viene quindi inviata la propria ``descrizione'' all'altro \underline{peer}.
\item onaddstream: evento scatenato quando viene aggiunto uno \textit{stream} nell'oggetto RTCPeerConnection. In questa situazione, il chiamato riceve lo \textit{stream} del chiamante e lo visualizza nell'apposito tag video. In contemporanea, vengono richiamati i metodi che fanno partire la visualizzazione delle statistiche di chiamata.
\item onremovestream: evento scatenato quando viene rimosso uno \textit{stream} nell'oggetto RTCPeerConnection. In questa situazione, colui che effettua questa operazione vuole terminare la chiamata e deve quindi re-inviare la propria descrizione (attraverso il metodo \method{gotDescription()} in modo tale che l'altro \underline{peer} possa aggiornare la descrizione remota. Vengono richiamati alla fine i metodi che fermano la visualizzazione delle statistiche di chiamata e chiudono il canale di comunicazione tramite la chiamata del metodo \method{close()} dell'oggetto \memberdata{pc}.
\end{itemize}

\item{\method{+ webkitGetUserMedia(audio: boolean, video: boolean): void}}\\
Metodo richiamato nel momento in cui un utente vuole iniziare una chiamata. Il metodo, fornito dalle librerie native di \textit{Google Chrome}, cattura lo \textit{stream} della propria videocamera/microfono. Riceve due parametri che indicano se deve essere catturato audio e/o video. Procedendo, viene aggiunto lo \textit{stream} all'oggetto RTCPeerConnection tramite il metodo \method{addStream(localstream)} fornito dalle librerie di WebRTC.

\item{\method{+ endCall(): void}}\\
Metodo richiamato per terminare una chiamata, a cascata viene richiamato il metodo \method{removeStream(localstream)} e inviata la nuova descrizione al \underline{peer} remoto.
 
 \end{description}

\clearpage

\section{Specifica sotto-architettura \texttt{clientview}}\label{sec:clientviewarchitecture}
Il sistema dispone di dodici viste, ognuna associata al relativo \inglese{presenter}. Tali viste vengono create e modificate all'occorrenza in base alle chiamate di metodo effettuate da parte dei relativi \inglese{presenter}.

La descrizione delle viste, oltre alla funzione e ai metodi che essa mette a disposizione del relativo \inglese{presenter}, è corredata dalla struttura degli elementi che la compongono.

\subsection{Package \texttt{org.softwaresynthesis.mytalk.clientview}}

\classsection{LoginView}
\subsubsection*{Funzione}
Vista associata al \inglese{presenter} \classname{LoginPanelPresenter} utilizzata per effettuare il login nel sistema.

\subsubsection*{Metodi}
\begin{description}
  \item{\method{+ destroy(): void}}\\
  Tale metodo ha il compito di eliminare il pannello dall'interfaccia grafica visualizzata. A tal fine, deve essere rimosso il nodo che corrisponde al pannello nell'albero DOM della UI\@.
  
  \item{\method{+ errorLogin(): void}}\\
  Il metodo ha lo scopo di segnalare visivamente all'utente il fatto che si è verificato un errore nell'elaborazione delle credenziali di autenticazione inserite nel \inglese{form}. Tale effetto dovrà essere ottenuto aggiungendo al valore dell'attributo \verb+class+ il valore \verb+error+.
  
  \item{\method{+ correctAnswer(): void}}\\
	Metodo usato per modificare il nodo DOM salvato in \memberdata{thisPanel} per comunicare all'utente che la risposta da lui inserita per il recupero password è corretta. 
	
Il metodo deve rimuovere il figlio con identificativo uguale a \textit{passwordretrieval} dalla vista, quindi aggiunge un nuovo elemento \verb'<p>' contenente il messaggio:
\begin{verbatim}
	Recupero password avvenuto correttamente.
	Ti è stata inviata un'email contenente i dati richiesti.
\end{verbatim}
il messaggio sopracitato è temporaneo e dovrà essere rimosso allo scadere di un \inglese{timeout} della durata di due secondi utilizzando la funzione \verb'window.setTimeout(funtion() {...}, 2000)'.

Il corpo della funzione anonima passata a \verb'setTimeout' avrà il compito di rimuovere dall'elemento \verb'thisPanel' il paragrafo creato in precedenza.

	\item{\method{+ incorrectAnswer(): void}}\\
	Metodo che In caso di inserimento della risposta non corretta alla domanda segreta visualizza un messaggio di avvertimento all'utente per due secondi quindi lascia il controllo al \inglese{form} di inserimento della risposta alla domanda segreta.
	
	Il metodo deve cercare un elemento \verb'<p>' per la visualizzazione del messaggio, contenente il testo
\begin{verbatim}
	Dati non corretti. Inserire nuovamente la risposta.
\end{verbatim}
	
	Quindi si visualizza il messaggio con una procedura identica a quella di \method{correctAnswer()}.
	
	\item{\method{+ buildRetrievePasswordForm(): HTMLElement}}\\
	Metodo usato per costruire il \inglese{form} per il recupero della password, che ha il compito di costruire un elemento \verb'fieldset', che contiene al suo interno:
	\begin{itemize}
	  \item[] un \verb'<label>' contenente la domanda segreta;
	  \item[] un elemento \verb'<input>' per inserire il testo della risposta;
	  \item[] un \verb'<input>' di tipo \verb'submit'.
	\end{itemize}
Alla pressione di quest'ultimo, la vista provvede ad invocare il metodo \method{hasAnsweredCorrectly} del \inglese{presenter} associato a questa vista e, in base al risultato positivo o negativo ottenuto, visualizza il messaggio corrispondente tramite i metodi \verb'correctAnswer()' e \verb'incorrectAnswer()' rispettivamente.

Infine, il metodo restituisce il nodo DOM radice della nuova porzione di interfaccia grafica creata, vale a dire il \verb'<fieldset>'.

	\item{\method{+ initialize(view: HTMLElement): void}}\\
	Il metodo ha il compito di inizializzare il pannello di login dopo che è stato caricato il relativo \inglese{template} che crea di tutti i \inglese{widget} grafici contenuti al suo interno.
	
	Il metodo ha il compito di aggiungere all'interfaccia grafica il sotto-albero DOM che riceve come parametro in ingresso, quindi configurare il pannello assegnando ai pulsanti le funzioni di \inglese{callback} corrispondenti.
	
	In particolare, alla pressione del pulsante di login deve essere eseguita una funzione che recupera il nome utente e la password inseriti dall'utente (con i metodi \method{getUsername()} e \method{getPassword()} rispettivamente), quindi invocare il metodo \method{login} del \inglese{presenter} per la valutazione dei dati.
	
	Alla pressione del pulsante di registrazione deve essere sollevato un evento che provoca la visualizzazione del pannello di registrazione, vale a dire un evento con stringa identificativa uguale a \verb'showRegistrationPanel'.
	
	Infine, alla pressione del pulsante per il recupero della password deve essere costruito il \inglese{form} corrispondente, mediante una chiamata al metodo \method{buildRetrievePasswordForm()}, aggiungendo l'elemento restituito all'interfaccia grafica finale.
\end{description}

\subsubsection*{Elementi}
Il pannello contiene un elemento \verb'<div>' con identificativo uguale a \verb'LoginPanel' il quale a sua volta ha come figlio un \verb'<fieldSet>' con identificativo uguale a \verb'loginForm' che contiene:
  \begin{itemize}
    \item[--] un elemento \verb'<div>' per il logo;
    \item[--] un elemento \verb'<ul>' contenente i seguenti elementi:
    \begin{itemize}
      \item[-] un elemento \verb'<li>' per il nome utente, con all'interno un elemento \verb'<label>' e il relativo campo di inserimento \verb'<input>';
      \item[-] un elemento \verb'<li>' per la password, con all'interno un elemento \verb'<label>' e il relativo campo di inserimento \verb'<input>';
      \item[-] \verb'<li>' per i pulsanti contenente al suo interno:
      \begin{itemize}
        \item[$\cdot$] un elemento \verb'<button>' per effettuare il login;
        \item[$\cdot$] un elemento \verb'<button>' per effettuare la registrazione al sistema;
        \item[$\cdot$] un elemento \verb'<button>' per recuperare i dati dimenticati.
      \end{itemize}
    \end{itemize}
  \end{itemize}

\classsection{RegisterView}
\subsubsection*{Funzione}
Vista associata al \inglese{presenter} \classname{RegisterPanelPresenter} utilizzata per effettuare la registrazione al sistema.

\subsubsection*{Metodi}
\begin{description}
  \item{\method{+ destroy(): void}}\\
  Tale metodo ha il compito di eliminare il pannello dall’interfaccia grafica visualizzata. A tal fine, deve essere rimosso il nodo che corrisponde al pannello nell’albero DOM della UI\@.
  
  \item{\method{+ initialize(view: HTMLElement): void}}\\
  	Il metodo ha il compito di inizializzare il pannello di registrazione al sistema una volta caricato il relativo \inglese{template} che crea di tutti i \inglese{widget} grafici contenuti al suo interno.
	
	Il metodo ha il compito di aggiungere all'interfaccia grafica il sotto-albero DOM che riceve come parametro in ingresso, quindi configurare il pannello assegnando ai pulsanti le funzioni di \inglese{callback} corrispondenti.
	
	In particolare, alla pressione del pulsante ``indietro'' deve essere sollevato un evento avente come nome identificativo la stringa \verb'showLoginPanel'.
	
  Alla pressione del pulsante per la registrazione, invece, devono essere recuperati i valori di tutti i campi dati del form mediante i metodi \method{getUsername()}, \method{getPassword()}, \method{getQuestion()}, \method{getAnswer()}, \method{getName()}, \method{getSurname()}, \method{getPicturePath()} e, in un secondo momento, deve essere richiamato il metodo \method{register} del \inglese{presenter}.

\end{description}

\subsubsection*{Elementi}
Il pannello è costituito da n elemento di tipo \verb'<div>' con identificativo uguale a \verb'LoginPanel' che contiene un elemento \verb'<form>' con al proprio interno:
\begin{itemize}
  \item[--] un elemento \verb'<ul>' il quale contiene:
  \begin{itemize}
    \item[-] un \verb'<li>' per il nome utente, costituito a sua volta da una \verb'<label>' e dal relativo campo \verb'<intput>' avente attributo \verb'type' uguale a \verb'email';
    \item[-] un \verb'<li>' per la password, costituito a sua volta da una \verb'<label>' e dal relativo campo \verb'<intput>' avente attributo \verb'type' uguale a \verb'password';
    \item[-] un \verb'<li>' per la domanda segreta, costituito a sua volta da una \verb'<label>' e dal relativo campo \verb'<intput>';
    \item[-] un \verb'<li>' per la risposta, costituito a sua volta da una \verb'<label>' e dal relativo campo \verb'<intput>';
    \item[-] un \verb'<li>' per il nome, costituito a sua volta da una \verb'<label>' e dal relativo campo \verb'<intput>';
    \item[-] un \verb'<li>' per il cognome, costituito a sua volta da una \verb'<label>' e dal relativo campo \verb'<intput>';
    \item[-] un \verb'<li>' per l'immagine del profilo, costituito a sua volta da una \verb'<label>' e dal relativo campo \verb'<intput>' avente attibuto \verb'type' uguale a \verb'file';
    \item[-] un \verb'<li>' che contiene un avviso relativo all'obbligatorietà dei campi dati nome utente, password, domanda e risposta;
  \end{itemize}
  \item[--] un \verb'<div>' per i pulsanti che ha al proprio interno:
  \begin{itemize}
    \item[-] un elemento \verb'<button>' per tornare al pannello di login;
    \item[-] un elemento \verb'<button>' per portare a termine la registrazione al sistema.
  \end{itemize}
\end{itemize}

\classsection{CallHistoryView}
\subsubsection*{Funzione}
Vista associata al \inglese{presenter} \classname{CallHistoryPanelPresenter} utilizzata per la visualizzazione dello storico chiamate.

\subsubsection*{Metodi}
\begin{description}
  \item{\method{+ display(): void}}\\
  Tale metodo ha il compito di inizializzare il pannello della vista con i dati corretti popolando la lista delle chiamate in base ai dati ricevuti dal \inglese{presenter}.
  
  \item{\method{+ addListItem(call: Object): void}}\\
  Metodo che aggiunge alla lista delle chiamate visualizzata nel pannello una nuova voce che corrisponde alla chiamata passata come parametro.
  
  Ogni voce della lista contiene i dati relativi alla chiamata vale a dire l'altro utente coinvolto e la data della chiamata. Poiché a partire da questo pannello non è possibile effettuare alcuna azione, non è presente alcuna funzione di \inglese{callback} associata alle voci della lista.
  
\end{description}

\subsubsection*{Elementi}
Il pannello è costituito da un elemento \verb'<div>' avente come identificativo il valore \verb'CallHistoryPanel' il quale, a sua volta, contiene:
\begin{itemize}
  \item[--] un elemento \verb'<div>' avente attributo \verb'class' uguale al valore \verb'panelHeader' e con all'interno un elemento \verb'<h1>' contenente il titolo \textsc{<<storico chiamate>>};
  \item[--] un elemento \verb'<ul>' avente come identificativo la stringa \verb'ulHistory'.
\end{itemize}

\classsection{SearchResultView}
\subsubsection*{Funzione}
Vista associata al \inglese{presenter} \classname{SearchResultPanelPresenter} utilizzata per visualizzare i risultati di una ricerca fra gli utenti registrati al sistema.

\subsubsection*{Metodi}
\begin{description}
  \item{\method{-- getImageSrc(contact: Object): String}}\\
  Il metodo ha il compito di fornire l'indirizzo sul server dell'immagine corrispondente a uno stato utente. In base al valore della proprietà \verb'state' del contatto passato come parametro, il metodo dovrà restituire una fra le stringhe:
  \begin{itemize}
    \item[-] \verb'img/stateavailable.png';
    \item[-] \verb'img/stateoccupied.png';
    \item[-] \verb'img/stateoffline.png'.
  \end{itemize}
  
  \item{\method{-- addListItem(contact: Object): void}}\\
  Provoca la visualizzazione nel pannello di una nuova voce della lista contenente i dati del contatto passato come parametro. L'elemento \verb'<li>' che dovrà essere aggiunto in coda alla lista deve avere al proprio interno un nodo di testo corrispondente al nome del contatto, un elemento \verb'<img>' corrispondente allo stato del contatto e un elemento \verb'<img>' corrispondente all'immagine dello stesso.
  
  Inoltre, all'evento \verb'click' sollevato sul \verb'<li>' dovrà essere associato un gestore che a sua volta avrà il compito di procurarsi un riferimento a un evento con identificativo uguale a \verb'showContactPanel', assegnare alla proprietà \verb'contact' di quest'ultimo il contatto passato come parametro del metodo e sollevare l'evento corrispondente.
  
  \item{\method{+ display(): void}}\\
  Il metodo configura il comportamento della vista per la visualizzazione dei risultati di una ricerca. In particolare, deve creare un gestore per l'evento identificato dalla stringa \verb'click' associato al pulsante di ricerca che avvii una ricerca in base al contenuto inserito nell'\verb'<input>' del pannello e visualizzi i risultati mediante il metodo \method{displayResult}.
  
  \item{\method{+ displayResult(contacts: Object): void}}\\
  Il metodo riceve in input in array associativo indicizzato in base agli identificativi dei contatti che in ogni posizione contiene l'oggetto contatto corrispondente alla chiave.
  
  Il compito del metodo è azzerare il contenuto della lista di utenti visualizzati (se era non vuota), quindi richiamare per ognuno dei contatti contenuti nell'array richiamare il metodo \method{addListItem} passando il contatto come parametro.
  
\end{description}

\subsubsection*{Elementi}
Il pannello è costituito da un elemento \verb'<div>' avente come identificativo \verb'SearchResultPanel' il quale contiene:
\begin{itemize}
  \item[--] un elemento \verb'<div>' avente l'attributo \verb'class' uguale a \verb'panelHeader', che contiene a sua volta al proprio interno un elemento \verb'<h1>' con il titolo \textsc{<<ricerca utenti>>};
  \item[--] un elemento \verb'<input>' con identificativo uguale a \verb'searchInputField';
  \item[--] un elemento \verb'<button>' avente l'attributo \verb'class' uguale a \verb'searchInputButton' e identificativo \verb'searchInputButton';
  \item[--] un elemento \verb'<ul>' per presentare i risultati della ricerca, avente come identificativo il valore \verb'userlList'.
\end{itemize}

\classsection{MainView}
\subsubsection*{Funzione}
Vista associata al \classname{MainPanelPresenter} che contiene il pannello principale ed è responsabile del suo aggiornamento e della sua visualizzazione.

\subsubsection*{Metodi}
\begin{description}
  \item{\method{+ destroy(): void}}\\
  Metodo che ha il compito di rimuovere il pannello dall'interfaccia grafica visualizzata rimuovendo il nodo DOM corrispondente al pannello principale dalla sua posizione all'interno dell'albero DOM\@.
  
  \item{\method{+ initialize(view: HTMLElement): void}}\\
  Tale metodo ha il compito di visualizzare del pannello principale, che viene passato tramite il parametro in ingresso \verb'view', aggiungendolo nella posizione corretta dell'albero DOM dell'interfaccia grafica in modo che venga ad occupare la posizione centrale.
  
  \item{\method{+ displayChildPanel(node: HTMLElement): void}}\\
  Provoca la visualizzazione di un pannello secondario all'interno della \classname{MainView} aggiungendo la sua radice, vale a dire il nodo DOM ricevuto come parametro in ingresso, come elemento figlio del \verb'div' che rappresenta il pannello principale.
  
\end{description}

\subsubsection*{Elementi}
Il pannello è costituito da un solo elemento \verb'<div>' avente come attributo identificativo la stringa \verb'MainPanel' all'interno del quale sarà visualizzata, di volta in volta, una delle sette viste di secondo livello, vale a dire:
\begin{itemize}
  \item[--] \classname{AccountSettingsView};
  \item[--] \classname{CallHistoryView};
  \item[--] \classname{CommunicationView};
  \item[--] \classname{ContactView};
  \item[--] \classname{GroupView};
  \item[--] \classname{MessageView};
  \item[--] \classname{SearchResultView}.
\end{itemize}

\classsection{ToolsView}
\subsubsection*{Funzione}
Vista associata al \inglese{presenter} \classname{ToolsPanelPresenter} utilizzata per visualizzare gli strumenti disponibili all'utente.

\subsubsection*{Metodi}
\begin{description}
  \item{\method{-- initializeSelectState(): HTMLElement}}\\
  Il metodo ha il compito di inizializzare l'elemento \verb'<select>' per il cambio di stato presente sul pannello degli strumenti aggiungendo ad esso, se non sono già presenti, le opzioni che corrispondono allo stato ``disponibile'' e ``occupato'' utilizzando una sintassi del tipo:
  \begin{verbatim}
    var availableOption = new Option("Disponibile", "available");
    selectState.add(availableOption, null);
  \end{verbatim}
  
  È importante, inoltre, associare all'evento \verb'change' associato all'elemento \verb'<select>' una funzione anonima che provoca l'invocazione del metodo \method{updateStateValue()} della vista stessa.
  
  Infine, l'elemento \verb'<select>' che è stato manipolato da questo metodo dovrà essere restituito al chiamante.
  
  \item{\method{+ destroy(): void}}\\
  Tale metodo ha il compito di provocare la rimozione del pannello degli strumenti governato da questa vista, rimuovendo in maniera definitiva dall'albero DOM il nodo che corrisponde alla radice del pannello.
  
  \item{\method{+ initialize(view: HTMLElement): void}}\\
  Il metodo ha la funzione di aggiungere nel punto corretto dell'albero DOM che rappresenta l'interfaccia utente il nodo passato come parametro, vale a dire il pannello degli strumenti, quindi di configurare il comportamento quest'ultimo assegnando a tutti i \inglese{list item} delle funzionalità i gestori di eventi corrispondenti.
  
  In particolare:
  \begin{itemize}
    \item[--] alla pressione della voce con identificativo \verb'liAnswering' deve essere sollevato un evento con nome \verb'showMessagePanel';
    \item[--] alla pressione della voce con identificativo \verb'liSetting' deve essere sollevato un evento con nome \verb'showAccountSettingPanel';
    \item[--] alla pressione della voce con identificativo \verb'liCallList' deve essere sollevato un evento con nome \verb'showCallHistoryPanel';
    \item[--] alla pressione della voce con identificativo \verb'liGroup' deve essere sollevato un evento con nome \verb'showGroupPanel';
    \item[--] alla pressione della voce con identificativo \verb'liSearch' deve essere sollevato un evento con nome \verb'showSearchResultPanel';
    \item[--] alla pressione della voce con identificativo \verb'liLogout' deve essere visualizzata una finestra di dialogo che richiede conferma all'utente sulla reale intenzione di uscire e, in caso di risposta affermativa, solleva sia l'evento \verb'logout' che \verb'showLoginPanel'.
  \end{itemize}
  
  Infine, prima di ritornare deve essere inizializzato l'elemento \verb'<select>' per la gestione dello stato utente, mediante l'opportuno metodo privato \method{initializeSelectState()}.
  
  \item{\method{+ addCommunicationFunction(): void}}\\
  Questo metodo dovrà provocare l'aggiunta di un nuovo elemento alla lista degli strumenti per permettere di ritornare al pannello delle comunicazioni. Dovrà pertanto creare un nuovo elemento \verb'<li>', assegnare alla sua proprietà identificativa il valore \verb'CallFunction', configurarne il comportamento alla pressione del mouse facendo in modo che sia sollevato un evento con nome \verb'showCommunicationPanel' quindi procurarsi un riferimento al nodo DOM che corrisponde alla lista delle funzionalità e aggiungere in coda il nuovo \inglese{list item} creato con il metodo \verb'appendChild'.
  
  \item{\method{+ removeCommunicationFunction(): void}}\\
  Il metodo ha il compito di rimuovere il pulsante per ritornare al pannello della comunicazione dalle opzioni disponibili nel momento in cui non sussiste più alcuna comunicazione (audio, audio/video o testuale) attiva per il client. Il metodo dovrà pertanto ottenere un riferimento al nodo DOM che rappresenta la lista delle funzioni, uno a quello del \inglese{list item} corretto e quindi utilizzare il metodo \verb'removeChild' per operare la rimozione.
  
  \item{\method{+ updateStateValue(): HTMLElement}}\\
  Questo metodo ha il compito di ottenere un riferimento all'elemento \verb'<select>' utilizzato per il cambio di stato, estrarre il valore associato all'opzione selezionata mediante un'istruzione del tipo
  \begin{verbatim}
    var state = select.options[selectedIndex].value;
  \end{verbatim}
  quindi sollevare un opportuno evento avente come identificativo la stringa \verb'changeMyState' e come proprietà \verb'state' il valore dello stato recuperato in precedenza.
  
  Il metodo, infine, dovrà restituire al chiamante un riferimento all'elemento \verb'<select>' che è stato manipolato.
\end{description}

\subsubsection*{Elementi}
Il pannello è costituito da un elemento \verb'<div>' avente come identificativo la stringa \verb'ToolsPanel', il quale contiene al proprio interno:
\begin{itemize}
  \item[--] un elemento \verb'<div>' avente attributo \verb'class' uguale a \verb'panelHeader';
  \item[--] un \verb'<div>' che contiene un elemento \verb'<select>' con identificativo uguale a \verb'selectState';
  \item[--] un terzo \verb'<div>' con all'interno:
  \begin{itemize}
    \item[-] un elemento \verb'<ul>' con identificativo uguale a \verb'ToolsList' per la lista degli strumenti, contenente:
      \begin{itemize}
        \item[$\cdot$] un \verb'<li>' con identificativo uguale a \verb'liAnswering' contenente il nodo di testo <<Segreteria>>;
        \item[$\cdot$] un \verb'<li>' con identificativo uguale a \verb'liSetting' contenente il nodo di testo <<Impostazioni>>;
        \item[$\cdot$] un \verb'<li>' con identificativo uguale a \verb'liCallList' contenente il nodo di testo  <<Lista chiamate>>;
        \item[$\cdot$] un \verb'<li>' con identificativo uguale a \verb'liGroup' contenente il nodo di testo <<Gruppi>>;
        \item[$\cdot$] un \verb'<li>' con identificativo uguale a \verb'liSearch' contenente il nodo di testo <<Ricerca>>;
      \end{itemize}
    \item[-] un elemento \verb'<ul>' con all'interno un solo \verb'<li>' avente come identificativo \verb'liLogout' e contenente come unico figlio il nodo di testo \verb'Logout'.
  \end{itemize}
\end{itemize}

\classsection{AccountSettingsView}
\subsubsection*{Funzione}
Vista associata al \inglese{presenter} \classname{AccountSettingsPanelPresenter} che ha il compito di permettere la visualizzazione e la modifica dei dati dell'utente.

\subsubsection*{Metodi}
\begin{description}
\item{\method{+ display(): void}}\\
Tale metodo ha il compito di inizializzare la vista, ovvero l'insieme dei \inglese{widget} grafici che costituiscono il pannello per la visualizzazione delle impostazioni e dei dati dell'utente.

In particolare, la vista ha il compito di ottenere i dati relativi a nome, cognome e immagine del profilo dell'utente e popolare le apposite regioni del pannello con le informazioni corrispondenti, quindi configurare il comportamento del pulsante per la modifica dei dati alla cui pressione deve corrispondere un'invocazione del metodo \method{onChangeButtonPressed()}.

\item{\method{+ onChangeButtonPressed(): void}}\\
Gestisce la pressione del pulsante ``Modifica dati'' trasformando l'elemento \verb'<div>' che contiene l'immagine del profilo e la lista di elementi testuali in un \textit{form} da compilare per apportare i cambiamenti i propri dati di registrazione. È importante che quest'ultimo abbia per l'attributo \verb'enctype' il valore \verb'multipart/form-data'.

Il \inglese{form} è costituito da una lista i cui tre elementi \verb'<li>' contengono rispettivamente:
\begin{itemize}
  \item[--] una \verb'<label>' e il relativo campo \verb'<input>' per il nome, che inizialmente visualizza il nome precedentemente impostato nel client;
  \item[--] una \verb'<label>' e il relativo campo \verb'<input>' per il cognome dell'utente, che inizialmente visualizza il valore precedentemente impostato nel client;
  \item[--] una \verb'<label>' e il relativo campo \verb'<input>' per l'immagine del profilo (quest'ultimo dovrà avere l'attributo \verb'type' uguale a \verb'file').
\end{itemize}

Inoltre, il \inglese{form} presenta un pulsante per l'invio dei dati inseriti al server alla cui pressione deve essere attivato un gestore di evento che raccoglie i dati inseriti e li trasmette invocando il metodo \method{sendUserData} del \inglese{presenter} e quindi solleva un evento con identificativo \verb'showAccountSettingPanel' per ricaricare il pannello.

\end{description}

\subsubsection*{Elementi}
Il pannello è costituito da un elemento \verb'<div>' con identificativo uguale a \verb'AccountSettingsPanel' che contiene al proprio interno:
\begin{itemize}
  \item[--] un \verb'<div>' con attributo \verb'class' uguale a \verb'panelHeader' con all'interno un elemento \verb'<h1>' avente come figlio il solo nodo testo \textsc{<<dati personali>>};
  \item[--] un elemento \verb'<img>' con identificativo uguale alla stringa \verb'picture';
  \item[--] un elemento \verb'<ul>' contenente:
  \begin{itemize}
    \item[-] un \verb'<li>' con identificativo uguale a \verb'name';
    \item[-] un \verb'<li>' con identificativo uguale a \verb'surname';
  \end{itemize}
  \item[--] un elemento \verb'<button>' contenente il testo ``Modifica dati''.
\end{itemize}

\classsection{MessageView}
\subsubsection*{Funzione}
Vista associata al \inglese{presenter} \classname{MessagePanelPresenter} utilizzata per visualizzare i messaggi presenti nella propria segreteria.

\subsubsection*{Metodi}
\begin{description}
  \item{\method{+ display(): void}}\\
  Il metodo ha il compito di inizializzare la vista, ovvero l'insieme dei \inglese{widget} grafici che costituiscono il pannello per la visualizzazione della segreteria telefonica dell'utente. Il metodo ha quindi il compito di popolare la lista dei messaggi della segreteria con i dati corretti che sono stati scaricati dal server.
  
  \item{\method{-- addListItem(message: Object): void}}\\
  Tale metodo riceve in input un oggetto che corrisponde a un messaggio della segreteria, caratterizzato dalle proprietà \verb'sender', \verb'date', \verb'status', \verb'video' e \verb'src'.
  
  Sulla base delle proprietà del messaggio, il metodo ha il compito di creare un nuovo \verb'<li>' e aggiungere ad esso:
  \begin{itemize}
    \item[--] un elemento \verb'<img>' che corrisponde allo stato letto/non letto del messaggio impostato tramite una chiamata al metodo privato \method{getStatusSrc} della vista;
    \item[--] un nodo di testo con il nome dell'utente che ha inviato il messaggio;
    \item[--] un nodo di testo contenente la data del messaggio;
    \item[--] un elemento \verb'<img>' per l'eliminazione del messaggio, che deve avere attributo \verb'src'
  \end{itemize}
  
  Prima di aggiungere il nuovo \inglese{list item} in coda alla lista dei messaggi, il metodo dovrà configurare il comportamento delle parti dell'interfaccia. In particolare, un click sulla voce della lista marchi il messaggio come letto tramite il metodo \method{setStatus} del \inglese{presenter} e inizializzi l'elemento \verb'<video>' per la visualizzazione dello stesso.
  
  Un click sull'immagine per l'eliminazione del messaggio deve invece chiamare l'apposito metodo \method{deleteMessage} messo a disposizione dal \inglese{presenter} e, infine, un click sull'immagine per cambiare lo stato deve invertire lo stato del messaggio tramite il metodo \method{setStatus} del \inglese{presenter} e cambiare l'immagine nel pannello che rappresenta lo stato letto/non letto del messaggio.
  
  \item{\method{-- getStatusSrc(message: Object): String}}\\
  Il metodo ha il compito di restituire la stringa corretta che rappresenta il percorso relativo dell'immagine associata allo stato del messaggio. Se il messaggio è nuovo (non letto) il risultato dovrà essere \verb'img/unreadmessage.png', in caso contrario  \verb'img/readmessage.png'.
  
\end{description}

\subsubsection*{Elementi}
Il pannello è costituito da un elemento \verb'<div>' con identificativo uguale a \verb'MessagePanel' che contiene al proprio interno:
\begin{itemize}
  \item[--] un \verb'<div>' con attributo \verb'class' uguale a \verb'panelHeader' con al proprio interno un \verb'<h1>' con il solo nodo di testo \textsc{<<segreteria>>};
  \item[--] un elemento \verb'<video>' con identificativo uguale a \verb'messageVideo' e attributo \verb'controls' uguale a \verb'controls', contenente un elemento \verb'<source>';
  \item[--] un \verb'<div>' con identificativo uguale a \verb'divMessage' contenente un elemento \verb'<ul>' con identificativo uguale a \verb'messageList'.
\end{itemize}

%********************************************************************
%     QUESTO È IL CONFINE FRA BENE E MALE - SIETE AVVERTITI!
%********************************************************************

\subsection{AddressBookView}
\subsubsection*{Funzione}
Vista associata al presenter \classname{AddressBookPresenter}. Utilizzata per la visualizzazione della rubrica personale.
\subsubsection*{Elementi}
\begin{itemize}
\item \textit{div} contenente un elemento di tipo \textit{text} e un \textit{button} per una ricerca veloce nella propria rubrica;
\item \textit{div} contenente un \textit{ul} dove verranno visualizzati tutti i contatti della rubrica;
\item \textit{div} contenente una \textit{select} utilizzata per ordinare la rubrica in base ai parametri dati;
\item \textit{div} contenente una \textit{select} dove sono elencati i gruppi della propria rubrica.
\end{itemize}

\subsection{CommunicationView}
\subsubsection*{Funzione}
Vista associata al presenter \classname{CommunicationPresenter}. Utilizzata inizialmente durante una chiamata.
\subsubsection*{Elementi}
\begin{itemize}
\item \textit{div} contenente un elemento di tipo \textit{text} e un \textit{button} per una ricerca veloce nella propria rubrica;
\item \textit{div} contenente due elementi \textit{video} rispettivamente utilizzati per visualizzare lo stream della propria fotocamera e dell'altro client;
\item \textit{div} contenente 3 \textit{span} utilizzati per visualizzare le statistiche, ossia i dati inviati, i dati ricevuto e il tempo di comunicazione;
\item \textit{button} per terminare la chiamata.
\end{itemize}

\subsection{ContactView}
\subsubsection*{Funzione}
Vista associata al presenter \classname{ContactPresenter}. Utilizzate per visualizzare il profilo di un utente.
\subsubsection*{Elementi}
\begin{itemize}
\item \textit{div} contenente un elemento di tipo \textit{ul} con 4 \textit{li}:
\begin{itemize}
\item nome;
\item cognome;
\item email;
\item gruppi a cui appartiene se il contatto è presente nella mia rubrica.
\end{itemize}
\item \textit{button} per avviare una chiamata audio;
\item \textit{button} per avviare una video chiamata;
\item \textit{button} per avviare una chat;
\item \textit{button} per lasciare un messaggio in segreteria;
\item \textit{button} per aggiungere il contatto nella propria rubrica se non presente;
\item \textit{button} per rimuovere il contatto dalla propria rubrica se presente;
\item \textit{button} per bloccare il contatto se presente nella propria rubrica e non bloccato;
\item \textit{button} per sbloccare il contatto se presente nella propria rubrica e bloccato.
\end{itemize}

\subsection{GroupView}
\subsubsection*{Funzione}
Vista associata al presenter \classname{GroupPresenter}. Utilizzata per la visualizzazione dei gruppi della propria rubrica.
\subsubsection*{Elementi}
\begin{itemize}
\item \textit{div} contenente un \textit{ul} dove verranno inseriti tanti \textit{li} quanti i gruppi presenti nella proria rubrica.
\end{itemize}

\clearpage

\section{Tracciamenti}

Al fine di rendere evidente l'associazione di necessità e sufficienza che intercorre tra i requisiti (emersi in attività di analisi) e le classi predisposte per soddisfarli, riportiamo di seguito due tabulati di tracciamento. Il primo, requisiti-classi, mostra il soddisfacimento di ogni requisito identificato. Il secondo, classi-requisiti, evidenzia l'utilità delle classi e dimostra che ogni una di esse è stata creata con uno scopo ben preciso.

\subsection{Requisiti - classi}

\subsection{Classi - requisiti}

\end{document}
