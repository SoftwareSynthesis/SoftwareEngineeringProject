% **************************************************
% Macro specifiche per il documento corrente
% **************************************************
% Nome
\newcommand{\docName}{Specifica tecnica}
% Nome file
\newcommand{\docFileName}{specifica\_tecnica.1.0.pdf}
% Versione
\newcommand{\docVers}{1.0}
% Data creazione
\newcommand{\creationDate}{2013-01-23}
% Data ultima modifica
\newcommand{\modificationDate}{2013-01-30}
% Stato in {Approvato, Non approvato}
\newcommand{\docState}{Approvato}
% Uso in {Interno, Esterno}
\newcommand{\docUsage}{Esterno}
% Destinatari da specificare come nome1\\ &nome2\\ ecc.
\newcommand{\docDistributionList}{Prof. Tullio Vardanega\\&Prof. Riccardo Cardin\\&Dott. Gregorio Piccoli\\&Team SoftwareSynthesis}
% Redattori da specificare come nome1\\ &nome2\\ ecc.
\newcommand{\docAuthors}{Diego Beraldin\\&Elena Zecchinato\\&Marco Schivo}
% Approvato da
\newcommand{\approvedBy}{Riccardo Tresoldi}
% Verificatori
\newcommand{\verifiedBy}{Andrea Meneghinello\\&Stefano Farronato}
% Perscorso (relativo o assoluto) che punta alla directory contenente shared/
% come sua sottodirectory (per comodità chiamiamola 'doc root').
\newcommand{\docRoot}{..}
% definire se si vuole l'indice delle tabelle
\def\INDICETABELLE{false}
% definire se si vuole l'indice delle figure
\def\INDICEFIGURE{true}

% importa il preambolo condiviso da tutti i documenti
\input{\docRoot/shared/preamble.tex}

% Fine del preambolo e inizio del documento
\begin{document}

% Inclusione della prima pagina
\input{\docRoot/shared/firstpage.tex}

%---------------------------RUOLI----------------------------
%FASE 1:
%Progettisti: TRES, STEFANO, SCHIVO;
%FASE 2:
%Progettisti: DIEGO, ELENA, RIZZI

%Verificatore: Andrea Meneghinello
%Responsabile finale TRES
%------------------------------------------------------------

% Storico delle modifiche
\section*{Storia delle modifiche}
\begin{center}
\begin{longtable}{lp{.32\textwidth}lll}
\toprule
Versione & Descrizione intervento & Membro & Ruolo & Data\\
\midrule
1.1 & Modifica architettura del database & Elena Zecchinato & Progettista & 2012-02-08\\
1.0 & Approvazione documento & Riccardo Tresoldi & Responsabile & 2012-01-30\\
0.19 & Correzione errori ortografici e di forma presenti nel documento in base alle segnalazioni del verificatore&Marco Schivo & Progettista & 2013-01-29\\
0.18 & Correzione diagrammi presenti nel documento in base alle segnalazioni del verificatore&Elena Zecchinato & Progettista & 2013-01-29\\
0.17 & Verifica lessico ortografica del documento & Andrea Meneghinello & Verificatore & 2013-01-28\\
0.16 & Verifica correttezza e corrispondenza dei diagrammi presenti nel documento & Stefano Farronato & Verificatore & 2013-01-27\\
0.15 & Inserimento tabelle di tracciamento prodotte nel capitolo 12&Diego Beraldin & Progettista & 2013-01-28\\
0.14 & Inserimento diagrammi delle attività e dei package prodotti nel capitolo 11&Diego Beraldin & Progettista & 2013-01-28\\
0.13 & Inserimento diagrammi delle classi nel capitolo 6, 7, 8, 9&Marco Schivo & Progettista & 2013-01-28\\
0.12 & Inserimento diagrammi relativi ai design pattern evidenziati&Marco Schivo & Progettista & 2013-01-28\\
0.11 & Inizio stesura capitolo relativo alla descrizione delle classi&Diego Beraldin & Progettista & 2013-01-27\\
0.10 & Stesura della sezione relativa all'architettura mytalk.clientview stilando i componenti evidenziati&Elena Zecchinato & Progettista & 2013-01-27\\
0.9 & Stesura della sezione relativa all'architettura mytalk.clientpresenter stilando i componenti evidenziati&Marco Schivo & Progettista & 2013-01-27\\
0.8 & Stesura della sezione relativa all'architettura mytalk.server stilando i componenti evidenziati&Marco Schivo & Progettista & 2013-01-26\\
0.7 & Stesura della sezione relativa alla progettazione logica &Diego Beraldin  & Progettista & 2013-01-26\\
0.6 & Completata la sezione relativa alla progettazione concettuale &Elena Zecchinato & Progettista & 2013-01-25\\
0.5 & Inizio stesura della sezione relativa alla progettazione concettuale con classi evidenziate in fase di progettazione &Elena Zecchinato& Progettista & 2013-01-24\\
0.4 & Descrizione dei design pattern evidenziati nella fase di progettazione. &Diego Beraldin & Progettista & 2013-01-24\\
0.3 & Aggiunto capitolo relativo agli strumenti utilizzati.& Marco Schivo & Progettista & 2013-01-23\\
0.2 & Stesura dell'introduzione ai design pattern. Stesura dell'introduzione ai tracciamenti. &Elena Zecchinato & Progettista & 2013-01-23\\
0.1 & Creazione del documento e stesura della sezione ``Introduzione''. &Diego Beraldin & Progettista & 2013-01-23\\
\bottomrule
\end{longtable}
\end{center}
\newpage

% inclusione dell'indice
\input{\docRoot/shared/toc.tex}

% Alcuni aggiustamenti per le pagine
\pagenumbering{arabic}
\setcounter{page}{1}
\pagestyle{normal}

% Qui ha inizio il documento vero e proprio...
\clearpage

\begin{abstract}
Il presente documento illustra l'architettura del sistema ad alto livello e comprende una suddivisione di quest'ultima in sotto-architetture logiche, l'enumerazione e la descrizione dei componenti funzionali che le costituiscono nonché la decomposizione dei componenti nei package e, in ultima istanza, nelle classi. Vengono presentati inoltre gli elementi di riuso architetturale (\inglese{pattern}) utilizzati, motivandone la scelta. Infine, il documento è corredato da sei tabelle riepilogative inerenti al tracciamento componenti-requisiti, componenti-design pattern e componenti-classi.
\end{abstract}
\clearpage

\section{Introduzione}
\subsection{Scopo del prodotto}
\purpose

\subsection{Scopo del documento}
Il presente documento è stato redatto al fine di produrre le specifiche sulla progettazione ad alto livello, del prodotto \caName. A tal fine il documento presenterà:
\begin{itemize}
    \item una descrizione degli strumenti e dei \underline{framework} su cui si basa l'architettura;
	\item un elenco con le specifiche dei \underline{design pattern} utilizzati;
	\item l'architettura di alto livello del sistema;
	\item una descrizione dettagliata dei componenti rilevati in fase di progettazione indicando relativamente a ciascuno di essi il tipo, la funzione e l'obiettivo;
	\item i diagrammi UML per definire i flussi principali di controllo dell'applicativo;
	\item il tracciamento dei requisiti e dei componenti, negli schemi: requisiti-componenti e componenti-requisiti;
	\item il tracciamento di componenti e \underline{design pattern};
	\item il tracciamento di classi e componenti.
\end{itemize}

\subsection{Glossario}
\glossaryIntro

\clearpage
\section{Riferimenti}

\subsection{Normativi}
\begin{itemize}
\item[] \textit{piano\_di\_qualifica.3.0.pdf} allegato.
\item[] \textit{norme\_di\_progetto.3.0.pdf} allegato.
\item[] \textit{analisi\_dei\_requisiti.3.0.pdf} allegato
\end{itemize}

\subsection{Informativi}
\begin{itemize}
\item[] Capitolato d'appalto: \caName{}, v1.0, redatto e rilasciato dal proponente Zucchetti s.r.l. reperibile all'indirizzo \url{http://www.math.unipd.it/~tullio/IS-1/2012/Progetto/C1.pdf};
\item[] testo di consultazione: \textit{Software Engineering (8th edition) Ian Sommerville, Pearson Education | Addison Wesley};
\item[] manuale all'utilizzo dei design pattens: \textit{Design Patterns, Elementi per il riuso di software a oggetti -- (1/Ed. italiana) Eric Gamma, Richard Helm, Ralph Johnson, John Vlissides, Pearson Education};
\item[] manuale di basi di dati: \textit{Sistemi di basi di dati-fondamenti} -- (6° edizione) Ramez Elmasri / Shamkant B. Navathe
\item[] \textit{glossario.3.0.pdf} allegato.
\end{itemize}
\clearpage

\section{Strumenti utilizzati}
\subsection{Java}
L'utilizzo del linguaggio \underline{Java} è richiesto dal proponente esclusivamente per la realizzazione della componente \underline{server}.

\subsubsection*{Vantaggi}
\begin{itemize}
\item[-] è un linguaggio predisposto nativamente alla gestione parallela di thread e questo applicato ad un \underline{server} dà la possibilità di gestire parallelamente richieste da parte di più utenti allo stesso tempo;
\item[-] essendo un linguaggio orientato agli oggetti e fortemente tipizzato si presta all'applicazione di \underline{design pattern} e alla costruzione di un'architettura robusta, fortemente modulare e al contempo flessibile, in accordo con i principi del paradigma di programmazione OO;
\item[-] permette la generazione automatica della documentazione con l'ausilio di JavaDoc;
\item[-] garantisce la portabilità del codice (a livello di bytecode), l'indipendenza dalla piattaforma fisica di esecuzione grazie alla JVM e l'integrazione nell'ambiente di esecuzione del proponente (\underline{TomCat}).
\end{itemize}

\subsection{Hibernate}
Hibernate è un \underline{framework} \underline{Java} utilizzato per facilitare l'utilizzo di un \underline{database} da parte del \underline{server} realizzando la mappatura fra oggetti intesi in senso OOP ed ennuple del modello relazionale (Object-Relational Mapping).

\subsubsection*{Vantaggi}
\begin{itemize}
\item[-] Hibernate permette di utilizzare le tabelle di un \underline{database} relazionale come se fossero degli oggetti mappando il \underline{database} su di opportune classi strutturate ad-hoc svincolando la gestione della persistenza dei dati dalla logica di business;
\item[-] con questo \underline{framework} \underline{Java} riesce a lavorare su un \underline{database} rendendo trasparenti al programmatore le vere e proprie query e mostrando esclusivamente classi e metodi;
\item[-] essendo rilasciato sotto licenza LGPL può essere utilizzato senza restrizioni (copyleft) e vincoli di licenza delle opere derivate. 
\end{itemize}
\clearpage

\section{Design Pattern utilizzati}
In questa sezione discuteremo i \underline{design pattern} utilizzati nella progettazione dei componenti architetturali. Ogni \underline{design pattern} sarà proposto con la seguente forma:
\begin{itemize}
	\item \textbf{Scopo}: verrà proposto lo scopo generico del pattern, al fine di evidenziare subito la sua utilità.
	\item \textbf{Diagramma esemplificativo}: si riporterà lo schema UML, rappresentante un implementazione generica del \underline{design pattern} in esame.
	\item \textbf{Vantaggi derivanti}: si darà un elenco dei vantaggi apportati dall'utilizzo del pattern, in particolare sotto il profilo della manutenzione e del riuso del codice.
	\item \textbf{Componenti che lo implementano}: infine verranno elencati i componenti dell'architettura di sistema, che implementano il pattern descritto.
\end{itemize}

Per una visione d'insieme dei componenti utilizzati da un pattern, e dei pattern utilizzati da un componente, rimandiamo alle sottosezioni ``Tracciamenti Componenti-Design Pattern'' e ``Tracciamenti Design Pattern-Componenti'' della sezione \vref{sec:tracciamenti}.

\subsection{Composite}

\subsubsection{Scopo}
Il pattern Composite ha lo scopo di comporre oggetti in strutture ad albero al fine di rappresentare gerarchie parte-tutto e consentire ai \underline{client} di trattare oggetti singoli e composizioni in modo uniforme. Permette inoltre di gestire strutture dati gerarchicizzate con elementi ``foglie'' ed elementi ``contenitori'', l'ideale per la struttura ``gruppo'' e ``utente''.

\subsubsection{Diagramma esemplificativo}
\begin{figure}[H]
\centering
\includegraphics[width=.8\textwidth]{composite}
\caption{Diagramma ad alto livello del pattern Composite}\label{fig:composite}
\end{figure}

\subsubsection{Componenti che lo implementano}
\begin{description}
\item{\bfseries\scshape Gestione rubrica}\\
Composite permette di trattare in maniera omogenea singoli oggetti e oggetti composti, come gli utenti e gruppi di utenti della rubrica. Inoltre, dal momento che rende più semplice l'aggiunta di componenti, permetterebbe in futuro l'integrazione di nuove tipologie di utenti senza la necessità di modificare la struttura preesistente.

Lo svantaggio principale che comporta l'uso di Composite è la mancanza di limiti nell'aggiunta di nuove tipologie di componenti. Per far fronte a questo rischio si è introdotta la classe \texttt{org.softwaresynthesis.mytalk.server.abook.AddressBook} che controlla l'accesso alla struttura dati corrispondente alla rubrica.
\end{description}

\subsection{Data Access Object (DAO)}

\subsubsection{Scopo}
Il pattern DAO ha lo scopo di disaccoppiare la logica di business dalla logica di accesso ai dati. Questo si ottiene spostando la logica di accesso ai dati dai componenti di business ad una classe DAO rendendo i componenti che implementano la logica di business indipendenti dalla natura del dispositivo di persistenza. Questo approccio garantisce che un eventuale cambiamento del dispositivo di persistenza non comporti modifiche sui componenti di business.

\subsubsection{Diagramma esemplificativo}
\begin{figure}[H]
\centering
\includegraphics[width=.8\textwidth]{dao}
\caption{Diagramma ad alto livello del pattern Data Access Object}\label{fig:dao}
\end{figure}

\subsubsection{Componenti che lo implementano}
\begin{description}
\item{\scshape\bfseries Gestione database}\\
Le classi DAO consentono di isolare l'accesso alle tabelle del \underline{database} dalla parte di business logic facendo corrispondere alle invocazioni di metodo le opportune operazioni sui record del \underline{database}.

L'utilizzo di tale pattern crea inoltre un maggiore livello di astrazione e mantiene una rigida separazione tra le sotto-architetture corrispondenti a model e presenter.
\end{description}

\subsection{Façade}

\subsubsection{Scopo}
Fornire un'interfaccia unificata per un insieme di interfacce o classi presenti in una sotto-architettura. Façade definisce inoltre un'interfaccia di livello più alto che rende la sotto-architettura più semplice da utilizzare.

\subsubsection{Diagramma esemplificativo}
\begin{figure}[H]
\centering
\includegraphics[width=.8\textwidth]{facade}
\caption{Diagramma ad alto livello del pattern Façade}\label{fig:façade}
\end{figure}

\subsubsection{Componenti che lo implementano}
\begin{description}
  \item{\scshape\bfseries Façade del server}\\
L'uso di Façade permette di esporre verso i \underline{client} una sorta di interfaccia semplificata nascondendo i componenti della sotto-architettura \underline{server}, fornendo un punto di accesso centralizzato e riducendo il numero di dipendenze funzionali fra le classi del \underline{server} e i componenti appartenenti a sotto-architetture esterne.
  \item{\scshape\bfseries Façade del presenter}\\
Tramite questo \underline{design pattern} si introduce un livello di astrazione fra le sotto-architetture clientpresenter e clientview, che risultano dunque indipendenti.
  \item{\scshape\bfseries Façade della vista}\\
Data la forte bidirezionalità delle interazioni fra componenti delle sotto-architettura clientpresenter e clientview, è stata introdotta una sorta di facciata anche alla vista in modo da facilitare il tracciamento delle dipendenze fra i componenti del presenter e quelli della view.
\end{description}

\subsection{Factory Method}

\subsubsection{Scopo}
Definisce un'interfaccia per la creazione di un oggetto, lasciando alle sottoclassi la decisione sulla classe concreta che deve essere istanziata e consente di deferire l'istanziazione di una classe alle sottoclassi.

\subsubsection{Diagramma esemplificativo}
\begin{figure}[H]
\centering
\includegraphics[width=.8\textwidth]{factory_method}
\caption{Diagramma ad alto livello del pattern Factory Method}\label{fig:factory_method}
\end{figure}

\subsubsection{Componenti che lo implementano}
\begin{description}
  \item{\scshape\bfseries Façade del server}\\
Factory Method permette ai \underline{client} di ottenere con facilità degli oggetti proxy che specializzano le interfacce \texttt{server.dao.IAudioMessage}, \texttt{server.dao.IAudioVideoMessage} e \texttt{server.dao.IUserData}.

Questo permette di ridurre il traffico di rete in quanto oggetti potenzialmente di grandi dimensioni rimangono sul \underline{server} e vengono scaricati solo quando se ne presenta l'effettiva necessità.
  \item{\scshape\bfseries Gestione connessione}\\
Gli oggetti che rappresentano connessioni, sottotipi di \texttt{server.connection.IConnection} sono ottenuti mediante un Factory Method nelle classi concrete che implementano l'interfaccia \texttt{server.connectionICommunicationHandler}.

Ciò garantisce maggiore flessibilità in quanto permette in futuro di gestire più categorie di handler che restituiscono diversi tipi connessione.
\end{description}

\subsection{Model-View-Presenter}

\subsubsection{Scopo}
Il pattern architetturale \foreignlanguage{english}{Model-View-Presenter} similmente a quanto accade per \foreignlanguage{english}{Model-View-Controller} (MVC), ha lo scopo di mantenere separata la \inglese{business logic}, cioè la gestione dei dati secondo le regole di un determinato dominio e la loro memorizzazione in forma persistente, dalla presentazione e manipolazione mediante interfaccia utente.

\subsubsection{Diagrammi esemplificativi}
\begin{figure}[H]
\centering
\includegraphics[width=.8\textwidth]{mvpHLdiagram}
\caption{Diagramma ad alto livello del pattern MVP}\label{fig:mvpHL}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{diagrammasequenzaMVP}
\caption{Diagramma di sequenza che illustra le collaborazioni in MVP}\label{fig:mvpSD}
\end{figure}

Come si evince dal diagramma riportato in figura \ref{fig:mvpSD} le interazioni avvengono solo tra view e presenter oppure tra presenter e model, senza che avvenga mai uno scambio di dati diretto fra model e view.

Ciò si deve al fatto che la business logic e il modello dei dati risiedono nel \underline{server} mentre il presenter e la view sono situati nel \underline{client}. Quando un utente richiede un servizio tramite l'interfaccia grafica, la richiesta viene inoltrata dalla view al presenter.

Qualora quest'ultimo fosse in grado di soddisfare tale richiesta con le risorse di cui dispone, i dati sono restituiti immediatamente alla view senza alcun bisogno di richiedere l'intervento del \underline{server}. Nel caso, invece, in cui il presenter non fosse in grado di servire autonomamente la view, interrogherebbe il \underline{server} al fine di ottenere i dati da restituire alla componente grafica.

Il vantaggio di un simile schema di interazione consiste nella riduzione del traffico di rete e nel conseguente incremento delle prestazioni in termini di velocità e, di conseguenza, dell'esperienza utente in generale.

\subsubsection{Componenti che lo implementano}
MVP viene utilizzato come il pattern più ad alto livello del nostro sistema. La distinzione fra model, presenter e view è infatti rispecchiata dalla suddivisione del sistema nelle tre sotto-architetture server, clientpresenter e clientview.

In generale, l'utilizzo di MVP riduce l'accoppiamento tra le sotto-architetture minimizzando le modifiche richieste a ognuno di essi come conseguenza di cambiamenti all'interno degli altri.

Inoltre, i componenti di questa sotto-architettura non sono vincolati a utilizzare la rete per accedere alle informazioni che sono memorizzate sul \underline{server} quando queste sono già disponibili (e possono essere elaborate) sul \underline{client}, migliorando quindi l'esperienza utente.

In particolare, le parti del sistema che usano questo pattern corrispondono alle sotto-architetture:
\begin{itemize}[noitemsep,nolistsep]
  \item server
  \item clientpresenter
  \item clientview
\end{itemize}

\subsection{Observer}

\subsubsection{Scopo}
Definire una dipendenza uno a molti fra oggetti, in modo tale che se un oggetto cambia il suo stato tutti gli oggetti dipendenti da questo siano notificati e aggiornati automaticamente.

\subsubsection{Diagramma esemplificativo}
\begin{figure}[H]
\centering
\includegraphics[width=.7\textwidth]{observer}
\caption{Diagramma ad alto livello del pattern Observer}\label{fig:observer}
\end{figure}

\subsubsection{Componenti che lo implementano}
\begin{description}
  \item{\scshape\bfseries Gestione stato}\\
Il pattern Observer è utile in quanto permette agli utenti di osservare lo stato degli altri, ricevendo in modo automatico e trasparente una notifica nel caso in cui uno di questi ultimi subisse variazioni, essendo ogni utente sia osservato che osservatore.

Al momento della connessione, infatti, ogni utente si registra come osservatore sui suoi contatti che sono online e, al contempo, li aggiunge tra i propri osservatori. In tal modo gli utenti notificano in broadcast le loro variazioni di stato e sono sempre aggiornati sullo stato dei contatti della loro rubrica.
\end{description}

\subsection{Proxy}

\subsubsection{Scopo}
Fornisce un placeholder per un altro oggetto in modo da controllarne l'accesso e consentire un uso ottimizzato della memoria.

\subsubsection{Diagramma esemplificativo}
\begin{figure}[H]
\centering
\includegraphics[width=.8\textwidth]{proxy}
\caption{Diagramma ad alto livello del pattern Proxy}\label{fig:proxy}
\end{figure}

\subsubsection{Componenti che lo implementano}
\begin{description}
  \item{\bfseries\scshape Gestione rubrica}\\
L'utilizzo di un proxy al posto di un utente permette di raggiungere una maggiore efficienza limitando l'utilizzo della rete evitando all'utente di percepire una eccessiva lentezza che comprometterebbe la sua esperienza.

Inoltre, tramite un proxy è possibile controllare l'accesso ai dati (che risiedono nel server) garantendo dunque un migliore livello di protezione.
  \item{\bfseries\scshape Gestione segreteria}\\
Poiché i messaggi audio e, soprattutto, i messaggi audio/video possono essere di grandi dimensioni, i proxy permettono di ottimizzare il consumo della memoria e di evitare l'attesa da parte dell'utente se non strettamente necessario.
\end{description}

\subsection{Singleton}

\subsubsection{Scopo}
Il pattern creazionale Singleton, garantisce che una determinata classe possa essere istanziata una sola volta, e di fornirne un punto di accesso globale. Questo pattern va utilizzato negli ambiti in cui si ha la necessità che l'accesso ad una determinata entità sia unico, in modo da permettere la gestione ottimale della risorsa stessa.

\subsubsection{Diagramma esemplificativo}
\begin{figure}[H]
\centering
\includegraphics[width=.5\textwidth]{singleton}
\caption{Diagramma ad alto livello del pattern Singleton}\label{fig:singleton}
\end{figure}

\subsubsection{Componenti che lo implementano}
\begin{description}
  \item{\scshape\bfseries Façade del server}\\
Il pattern Singleton pone un limite superiore stretto al numero di istanze che possono esistere di una determinata classe e perciò è utile utilizzarlo per poter controllare il numero di oggetti \texttt{server.StandardServerFacade} che in questo caso è pari a uno. L'unicità dell'oggetto façade garantisce la presenza di un solo punto di accesso alle funzionalità dell sotto-architettura server.
  \item{\scshape\bfseries Façade del presenter}\\
Il pattern Singleton è altresì utile per controllare il numero di istanze attive della classe \texttt{clientpresenter.StandardPresenterFacade} per gli stessi motivi evidenziati in precedenza, ossia l'unicità del punto di accesso alle funzionalità della sotto-architettura clientpresenter.
  \item{\scshape\bfseries Gestione connessione}\\
La classe \texttt{server.connection.StandardConnectionHandler} è implementata come Singleton in modo da centralizzare la responsabilità di creare nuove connessioni in risposta alle esigenze dei \underline{client}.
  \item{\scshape\bfseries Façade della vista}\\
La classe \texttt{clientview.StandardViewFacade} è progettata in accordo con il \underline{design pattern} Singleton in modo da assicurare che in ogni momento ve ne sia una sola istanza attiva, responsabile di ricevere le richieste che giungono dal presenter.
  \item{\scshape\bfseries Gestione GUI}\\
Anche la classe \texttt{clientview.gui.GUIHandler} è implementata come Singleton in quanto permette di centralizzare la gestione delle collaborazioni fra le varie istanze attive delle classi grafiche.
\end{description}

\subsection{State}

\subsubsection{Scopo}
Permette ad un oggetto di cambiare il suo comportamento al variare del suo stato interno, quindi a run-time. L'oggetto si comporterà come se avesse cambiato la sua classe.

\subsubsection{Diagramma esemplificativo}
\begin{figure}[H]
\centering
\includegraphics[width=.7\textwidth]{state}
\caption{Diagramma ad alto livello del pattern State}\label{fig:state}
\end{figure}

\subsubsection{Componenti che lo implementano}
\begin{description}
\item{\scshape\bfseries Gestione dello Stato}\\
Il pattern State permette di gestire gli utenti del sistema determinando un comportamento diverso per questi ultimi a seconda del loro stato.

È stata definita un'apposita gerarchia di stati che permette quindi di specializzare nella maniera più adatta alle necessità del sistema le operazioni sugli utenti senza bisogno di condizionali annidati.
\end{description}
\clearpage

\section{Introduzione all'architettura di sistema}
Per introdurre l'architettura proposta è essenziale mettere in evidenza le seguenti considerazioni:
\begin{itemize}
	\item il sistema poggia su un \underline{database} nel quale sono contenuti i dati d'interesse per gli utenti (dati anagrafici, lista dei messaggi audio, lista dei messaggi audio e video, e la rubrica dei contatti);
	\item il sistema proposto dal team è dotato di una parte \underline{server} ed una parte \underline{client};
	\item dopo un'analisi preliminare il team ha stabilito che la progettazione del \underline{server} non deve essere vincolata da quella del \underline{client} in modo tale da evitare che il progetto dell'applicativo lato \underline{server} abbia la cognizione di come funziona il \underline{client}. Ciò permetterà un futuro riutilizzo del codice (e.g. se si desiderasse creare un nuovo applicativo di tipo \underline{VoIP} si potrà riutilizzare il \underline{server} già creato);
	\item per quanto riguarda il lato \underline{client}, al fine di garantire un alto livello di riutilizzo del codice e la possibilità di eseguire manutenzioni nel minor tempo possibile, si vuole che la logica d'implementazione del \underline{client} sia svincolata dalla rappresentazione grafica del medesimo.
\end{itemize}

Tali considerazioni di base, hanno portato il team a suddividere l'architettura in tre sotto-architetture, intese anche come package, più una quarta architettura inerente la struttura del \underline{database}:
\begin{itemize}
	\item il \underline{database};
	\item il \underline{server} (org.softwaresynthesis.mytalk.server);
	\item il clientpresenter (org.softwaresynthesis.mytalk.clientpresenter);
	\item il clientview (org.softwaresynthesis.mytalk.clientview).
\end{itemize}

Le specifiche di ogni sotto-architettura saranno definite in seguito, nelle relative sezioni.

Inoltre si fa presente che l'architettura generale, intesa come agglomerato delle tre sotto-architetture precedentemente elencate, fa uso del pattern MVP\@.

Sotto tale ottica la sotto-architettura \underline{server} ricopre il ruolo di model, il clientpresenter costituisce invece il presenter, mentre clientview è la vista definita per questo progetto. Tra le considerazioni più interessanti che hanno portato alla scelta di questo pattern, va messa in evidenza la seguente.

Assegnando ad ogni sotto-architettura un ruolo specifico, si garantisce un alto livello di riutilizzo del codice (e.g. clientview comunica con il presenter poiché non conosce la logica di business del sistema).

Quindi in un futuro di potrebbe riprendere la vista oggi definita, e riutilizzarla in un altro progetto, andando solo a ridefinire, se necessario, un presente che riproponga una nuovo adattamento della parte logica.

Di seguito verranno proposte le sotto-architetture evidenziate. Di ogni una sarà dato un elenco dettagliato dei componenti che lo interessano. Si sottolinea che per componenti non si intende i sottopackage, ma gli agglomerati di classi (potenzialmente prese da package diversi) che concorrono ad un fine comune: la definizione delle funzionalità del componente trattato.
\begin{figure}[H]
\begin{center}
\includegraphics[width=.8\textwidth]{DiagrammaPackage}
\caption{Diagramma dei Package - Generale}\label{fig:package_generale}
\end{center}
\end{figure}


\clearpage

\section{Architettura del database}

Come già citato nella parte introduttiva all'architettura, il \underline{server} si appoggia ad un \underline{database} dove sono registrati i dati del sistema. La progettazione di tale \underline{database} passa per due fasi (come appreso dal manuale ``Sistemi di basi di dati''): la progettazione concettuale e la progettazione logica.

\subsection{Progettazione concettuale}
Con la progettazione concettuale definiremo una struttura ``concettuale'' della base di dati. Tale struttura non rappresenta quella finale pronta per la creazione su DBMS, ma bensì un modello in grado di rappresentare il problema, svincolato da come esso debba essere logicamente rappresentato.

\subsubsection{Lista delle classi}

\begin{description}
	\item{\scshape\bfseries UserData}: è l'entità le cui istanze rappresentano gli utenti registrati nel sistema. UserData è caratterizzata dai seguenti attributi:

\begin{center}
\rowcolors{2}{lightblue}{llightblue}
\begin{tabular}{lccc}
\toprule
Nome attributo & Tipo & Opzionale & Vincoli\\
\midrule % inserire qui il contenuto della tabella
E-Mail & Varchar(100) & NO & PrimaryKey\\
Password & Password & NO &\\
Question & Varchar(100) & NO &\\
Answer & Varchar(100) & NO &\\
Name & Varchar(100) & SI &\\
Cognome & Varchar(100) & SI &\\
Picture & Varchar(150) & SI &\\
\bottomrule
\end{tabular}
\end{center}

	\item{\scshape\bfseries Calls}: è l'entità le cui istanze rappresentano le chiamate effettuate attraverso il sistema software \caName. Calls è caratterizzata dai seguenti attributi:

\begin{center}
\rowcolors{2}{lightblue}{llightblue}
\begin{tabular}{lccc}
\toprule
Nome attributo & Tipo & Opzionale & Vincoli\\
\midrule % inserire qui il contenuto della tabella
ID & int & NO & PrimaryKey\\
Start\_date & Datetime & NO & \\
End\_date & Datetime & SI & \\
\bottomrule
\end{tabular}
\end{center}

	\item{\scshape\bfseries Groups}: è l'entità le cui istanze rappresentano un gruppo della rubrica di un utente. Tale entità è costituita dagli attributi:

\begin{center}
\rowcolors{2}{lightblue}{llightblue}
\begin{tabular}{lccc}
\toprule
Nome attributo & Tipo & Opzionale & Vincoli\\
\midrule % inserire qui il contenuto della tabella
Group\_ID & int & NO & PrimaryKey\\
Name & Varchar(100) & NO &\\
\bottomrule
\end{tabular}
\end{center}	
	
	\item{\scshape\bfseries Messages}: è l'entità che rappresenta le informazioni basilari di un messaggio della segreteria dell'utente. Gli attributi che la compongono sono:

\begin{center}
\rowcolors{2}{lightblue}{llightblue}
\begin{tabular}{lccc}
\toprule
Nome attributo & Tipo & Opzionale & Vincoli\\
\midrule % inserire qui il contenuto della tabella
Path & Varchar(150) & NO & PrimaryKey\\
Sender & Varchar(100) & NO & \\
Receiver & Varchar(100) & NO & \\
New & Boolean & NO & \\
\bottomrule
\end{tabular}
\end{center}	
	
	\item{\scshape\bfseries AudioMessages}: è un entità che specializza Messages e rappresenta i messaggi audio lasciati nella segreteria di un utente. L'entità non è caratterizzata da alcun attributo proprio.
	
	\item{\scshape\bfseries AudioVideoMessages}: è un entità che specializza Messages e rappresenta i messaggi audio/video lasciati nella segreteria di un utente.  L'entità non è caratterizzata da alcun attributo proprio.	
	
\end{description}

\subsubsection{Gerarchia tra classi}

\begin{description}
	\item{\scshape\bfseries Messages(AudioMessages e AudioVideoMessages)}: i messaggi si suddividono logicamente in due categorie, i messaggi dotati solamente di traccia audio e quelli aventi anche una traccia video. Gli attributi contenuti in queste entità sono gli stessi. Infatti la necessità di mostrare la separazione deriva dalla volontà del team di evidenziare la distinzione tra i due oggetti, motivata dalla possibilità di gestire le istanze delle due entità in modo diverso.
\end{description}

\subsubsection{Associazione tra classi}

\begin{description}
	\item{\scshape\bfseries UserData - Calls (molti a molti)}: tale associazione rappresenta il legame che intercorre tra gli utenti e le chiamate. Tale associazione è del tipo molti a molti, con totalità parziale verso Calls e totalità totale verso UserData.
	\item{\scshape\bfseries UserData - Groups (molti a molti)}: tale associazione rappresenta il legame che intercorre tra gli utenti ed i gruppi, per la quale si è deciso di usare un associazione molti a molti con totalità parziale solo da Groups a UserData. Ciò significa che: un utente può comparire in zero o più gruppi (in ragione del fatto che potrebbe esserci più di qualcuno che registra un dato utente nella propria rubrica), ed un utente può possedere uno o più gruppi.
	\item{\scshape\bfseries UserData - Groups (uno a molti)}: tale associazione rappresenta il legame che intercorre tra il proprietario del gruppo e il gruppo stesso. L'associazione è del tipo uno a molti, a rappresentare come un gruppo sia visualizzabile unicamente dal proprietario, mentre un utente può avere (e di conseguenza visualizzare) più gruppi.
	\item{\scshape\bfseries UserData - Messages (uno a molti)}: tale associazione rappresenta il legame che intercorre tra gli utenti ed i messaggi registrati nella sua segreteria. L'associazione è del tipo uno a molti verso Messages, con totalità parziale verso Messages e totalità totale verso UserData. L'idea alla base è che un utente può avere nella propria segreteria uno o più messaggi, così come può non averne nessuno, mentre ogni messaggio della segreteria è ``visionabile'' da un unico utente, il destinatario del messaggio.
	\item{\scshape\bfseries Groups - Groups (uno a molti)}: tale associazione rappresenta il legame che intercorre tra oggetti di tipo gruppo, ovvero che un gruppo può possedere zero o più sottogruppi mentre un sottogruppo ha un gruppo ``padre'' che lo contiene.
\end{description}

\subsection{Progettazione logica}
Con la progettazione logica intendiamo costruire la struttura definitiva del \underline{database} sulla base della progettazione concettuale. Quindi si deciderà come trasformare le gerarchie e in seguito le associazioni, al fine di restituire una struttura chiara e pronta per la creazione sul DBMS\@. La lista delle classi proposta, e lo schema associato, rappresentano tale struttura.

\subsubsection{Rappresentazione delle gerarchie}

\begin{description}
	\item{\scshape\bfseries Messages(AudioMessages e AudioVideoMessages)}: al fine di evidenziare la suddivisione logica tra le due tipologie di messaggi, è stato deciso di trasformare la specializzazione di Messages con una tabella unica contenente un discriminante. È rimasta esclusivamente l'entità Messages a cui è stato aggiunto l'attributo ``Audio'' con la funzione di discriminare le due tipologie di messaggi.
\end{description}

\subsubsection{Rappresentazione delle associazioni}

\begin{description}
	\item{\scshape\bfseries UserData - Calls}: tale associazione si è risolta attraverso l'introduzione dell'entità CallLists. Tale entità contiene l'attributo User come chiave esterna verso l'entità UserData e l'attributo Call\_ID come chiave esterna verso l'entità Calls. È dotata inoltre dell'attributo Caller che identifica colui che ha per primo avviato la chiamata; per ogni gruppo di ennuple aventi lo stesso Call\_ID si avrà soltanto una ennupla contrassegnata con il campo Caller a vero.
	\item{\scshape\bfseries UserData - Groups}: tale associazione si è risolta con la creazione di una terza entità denominata AddressBooks, che contiene una chiave esterna verso UserData e una chiave esterna verso Groups.
	\item{\scshape\bfseries UserData - Groups}: tale associazione si è risolta trasformando l'attributo Owner in una chiave esterna verso UserData.
	\item{\scshape\bfseries UserData - Messages}: tale associazione si è risolta inserendo una chiave esterna verso UserData, all'interno dell'entità Messages.
\end{description}

\subsubsection{Lista delle classi}

\begin{center}

UserData

\rowcolors{2}{lightblue}{llightblue}
\begin{center}
\begin{tabular}{lccc}
\toprule
Nome attributo & Tipo & Opzionale & Vincoli\\
\midrule % inserire qui il contenuto della tabella
E-Mail & Varchar(100) & NO & PrimaryKey\\
Password & Password & NO &\\
Question & Varchar(100) & NO &\\
Answer & Varchar(100) & NO &\\
Name & Varchar(100) & SI &\\
Surname & Varchar(100) & SI &\\
Picture & Varchar(150) & SI &\\
\bottomrule
\end{tabular}
\end{center}

Calls

\begin{center}
\rowcolors{2}{lightblue}{llightblue}
\begin{tabular}{lccc}
\toprule
Nome attributo & Tipo & Opzionale & Vincoli\\
\midrule % inserire qui il contenuto della tabella
ID & int & NO & PrimaryKey\\
Start\_date & Datetime & NO & \\
End\_date & Datetime & SI &\\
\bottomrule
\end{tabular}
\end{center}

CallLists

\begin{center}
\rowcolors{2}{lightblue}{llightblue}
\begin{tabular}{lccc}
\toprule
Nome attributo & Tipo & Opzionale & Vincoli\\
\midrule % inserire qui il contenuto della tabella
Call\_ID & int & NO & PrimaryKey e ForeignKey verso Calls\\
User & Varchar(100) & NO & PrimaryKey e ForeignKey verso UserData \\
Caller & Boolean & NO &\\
\bottomrule
\end{tabular}
\end{center}

AddressBooks

\begin{center}
\rowcolors{2}{lightblue}{llightblue}
\begin{tabular}{lccc}
\toprule
Nome attributo & Tipo & Opzionale & Vincoli\\
\midrule % inserire qui il contenuto della tabella
User\_ID & Varchar(100) & NO & PrimaryKey e ForeignKey verso UserData\\
Group\_ID & int & NO & PrimaryKey e ForeignKey verso Groups\\
\bottomrule
\end{tabular}
\end{center}

Groups

\begin{center}
\rowcolors{2}{lightblue}{llightblue}
\begin{tabular}{lccc}
\toprule
Nome attributo & Tipo & Opzionale & Vincoli\\
\midrule % inserire qui il contenuto della tabella
Group\_ID & int & NO & PrimaryKey\\
Name & Varchar(100) & NO & \\
Owner & Varchar(100) & NO & ForeignKey verso UserData\\
Father & int & NO & ForeignKey verso Groups\\
\bottomrule
\end{tabular}
\end{center}	

Messages

\begin{center}
\rowcolors{2}{lightblue}{llightblue}
\begin{tabular}{lccc}
\toprule
Nome attributo & Tipo & Opzionale & Vincoli\\
\midrule % inserire qui il contenuto della tabella
Path & Varchar(150) & NO & PrimaryKey\\
Sender & Varchar(100) & NO & ForeignKey verso UserData \\
Receiver & Varchar(100) & NO & ForeignKey verso UserData\\
New & Boolean & NO & \\
Audio & Boolean & NO & \\
\bottomrule
\end{tabular}	
\end{center}

\end{center}

\subsubsection{Diagramma delle classi}
\begin{figure}[H]
\begin{center}
\includegraphics[width=.9\textwidth]{Database_logico}
\caption{Diagramma delle classi - Schema logico Database}\label{fig:database_logico}
\end{center}
\end{figure}

\clearpage

\section{Architettura mytalk.server}
Tale sotto-architettura definisce le specifiche e le funzionalità dell'applicativo lato \underline{server}. In esso saranno definiti i seguenti componenti:
\begin{itemize}[noitemsep,nolistsep]
	\item[-] Gestione database.
	\item[-] Gestione connessione.
	\item[-] Gestione rubrica.
	\item[-] Gestione stato.
	\item[-] Gestione segreteria.
	\item[-] Façade del server.
\end{itemize}

I componenti sopracitati verranno definiti di seguito. Si sottolinea sin da ora che il \underline{server} è l'unico in grado di comunicare con il \underline{database} su cui regge l'applicativo.

Infine, si fa notare che i nomi di tutte le classi riportate nella sezione sono implicitamente parte del package \texttt{org.softwaresynthesis.mytalk.server} pertanto tale prefisso sarà omesso nella loro denominazione.

\subsection{Componenti evidenziati}

\subsubsection{Gestione database}
\begin{description}
\item{\scshape\bfseries Descrizione:}\\
Gestione database è il componente che si occupa di rappresentare la struttura del \underline{database} relazionale su cui poggia l'applicativo. Le singole classi in esso definite rappresentano quindi le tabelle del \underline{database}. In termini tecnici le classi interne al componente Gestione database implementa il \underline{design pattern} DAO\@.

Tramite questo componente, il sistema potrà quindi effettuare operazione di lettura e scrittura di entità all'interno del \underline{database}. Le classi che costituiscono il componente dovranno quindi essere dotate di:

\begin{itemize}
	\item metodi get per restituire i singoli attributi dell'istanza;
	\item metodi set per garantire un corretto inserimento dei dati prima di registrare l'istanza nel \underline{database}.
\end{itemize}

Si informa inoltre che le classi di tale componente dovranno interagire con il \underline{framework} Hibernate, al fine di ottenere lo scopo precisato.

\item{\scshape\bfseries Diagramma delle classi:}
\begin{figure}[H]
\begin{center}
\includegraphics[width=.5\textwidth]{class_gestione_database}
\caption{Diagramma delle classi - Gestione database}\label{fig:gestione_database}
\end{center}
\end{figure}
	
	\item{\scshape\bfseries Classi utilizzate:}
	\begin{itemize}[nolistsep, noitemsep]
	  \item[-] \texttt{dao.AudioMessage}
	  \item[-] \texttt{dao.AudioVideoMessage}
	  \item[-] \texttt{dao.IAudioMessage}
	  \item[-] \texttt{dao.IAudioVideoMessage}
	  \item[-] \texttt{dao.IGroup}
	  \item[-] \texttt{dao.IUserData}
	  \item[-] \texttt{dao.StandardGroup}
	  \item[-] \texttt{dao.StandardUserData}
	\end{itemize}
\end{description}

\subsubsection{Gestione connessione}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Tale componente ingloba le classi destinate a stabilire le routine di connessione. A tal fine è stata definita l'interfaccia di una classe Singleton \texttt{connection.ICommunicationHandler}, implementata da \texttt{connection.StandardCommunicationHandler} che ha il compito di creare oggetti connessione.

Le specifiche di tali oggetti sono descritte dall'interfaccia \texttt{connection.IConnection}, con la relativa implementazione \texttt{connection.WebRTCInfo}.
	\item{\scshape\bfseries Diagramma delle classi:}
	\begin{figure}[H]
\begin{center}
\includegraphics[width=.8\textwidth]{class_gestione_connessione}
\caption{Diagramma delle classi - Gestione connessione}\label{fig:gestione_connessione}
\end{center}
\end{figure}
	
	\item{\scshape\bfseries Classi utilizzate:}
	\begin{itemize}[nolistsep, noitemsep]
	  \item[-] \texttt{connection.ICommunicationHandler}
	  \item[-] \texttt{connection.StandardCommunicationHandler}
	  \item[-] \texttt{connection.IConnection}
	  \item[-] \texttt{connection.WebRTCInfo}
	\end{itemize}
\end{description}

\subsubsection{Gestione rubrica}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
La rubrica è organizzata in gruppi e sono previste due categorie di default: la \textit{blacklist} e la \textit{whitelist}.

L'utente può aggiungere ulteriori gruppi in base alle sue esigenze ma esclusivamente all'interno della \textit{whitelist}. Per trattare in maniera omogenea i gruppi di contatti e i singoli contatti si è utilizzato il \underline{design pattern} Composite.

In particolare, \texttt{abook.IContact} rappresenta l'interfaccia principale comune a ogni tipologia di contatto e viene estesa dalle due interfacce \texttt{dao.IUserData} e \texttt{dao.IGroup}.

Il componente comprende anche l'interfaccia \texttt{abook.IAddressBook} e la relativa implementazione \texttt{abook.AddressBook}. Nell'implementazione specificata \texttt{abook.Addressbook} vincola il sistema a garantire che ogni utente abbia i due gruppi di default sopra descritti, come richiesto dai requisiti.

Infine, la classe \texttt{abook.UserDataProxy} viene utilizzata come proxy per lo scambio di dati fra la sotto-architettura \underline{server} e la sotto-architettura clientpresenter.
	\item{\scshape\bfseries Diagramma delle classi:}
	\begin{figure}[H]
\begin{center}
\includegraphics[width=.8\textwidth]{class_gestione_rubrica}
\caption{Diagramma delle classi - Gestione rubrica}\label{fig:gestione_rubrica}
\end{center}
\end{figure}
	
	\item{\scshape\bfseries Classi utilizzate:}\\
	\begin{itemize}[nolistsep, noitemsep]
	  \item[-] \texttt{abook.AddressBook}
	  \item[-] \texttt{abook.IAddressBook}
	  \item[-] \texttt{abook.IContact}
	  \item[-] \texttt{abook.UserDataProxy}
	  \item[-] \texttt{dao.IGroup}
	  \item[-] \texttt{dao.IUserData}
	\end{itemize}
\end{description}

\subsubsection{Gestione stato}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Le classi di tale componente sono utilizzate per gestire lo stato degli utenti, permettendo un comportamento diverso delle istanze di \texttt{dao.StandardUserData} a seconda dello stato in cui si trova l'utente corrispondente. Gli stati possibili sono in prima istanza ``online'' e ``offline'', rappresentati dalle classi \texttt{state.StateOnline} e \texttt{state.StateOffline} rispettivamente.

Gli utenti che si trovano nello stato online possono trovarsi in due situazioni: ``occupato'' o ``disponibile'', rappresentati a loro volta dalle classi \texttt{state.StateOccupied} e \texttt{state.StateAvailable}.

Se l'utente è impegnato in una conversazione con uno o più utenti, allora lo stato in cui si trova è ``occupato''. Tuttavia, un utente può anche impostare manualmente il proprio stato ad ``occupato'' anche per segnalare di non essere disponibile a ricevere chiamate in ingresso.
	
La chiamata viene inoltre trattata in modo differente a seconda che l'utente si trovi nello stato ``disponibile'' o ``occupato''/``offline'', dal momento che nel primo caso la chiamata va a buon fine mentre nel secondo verrà attivato il meccanismo di segreteria telefonica.
	
Inoltre, i cambiamenti di stato vengono notificati a tutti gli utenti presenti in rubrica tali che si trovano nello stato online.
	\item{\scshape\bfseries Diagramma delle classi:}
	\begin{figure}[H]
\begin{center}
\includegraphics[width=.9\textwidth]{class_gestione_stato}
\caption{Diagramma delle classi - Gestione stato}\label{fig:gestione_stato}
\end{center}
\end{figure}
	
	\item{\scshape\bfseries Classi utilizzate:}\\ 
	\begin{itemize}[noitemsep,nolistsep]
		\item[-] \texttt{dao.StandardUserData}
	    \item[-] \texttt{state.IState}
	    \item[-] \texttt{state.StateAvailable}
	    \item[-] \texttt{state.StateOccupied}
	    \item[-] \texttt{state.StateOffline}
	    \item[-] \texttt{state.StateOnline}
	\end{itemize}
\end{description}

\subsubsection{Gestione segreteria}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Il sistema di segreteria telefonica corrisponde all'interfaccia \texttt{message.IMessageBox} e alla relativa implementazione \texttt{message.StandardMessageBox} che permettono un accesso centralizzato all'insieme di messaggi che un determinato utente ha ricevuto.

I messaggi audio e audio/video sul \underline{server} sono rappresentati dalle classi \texttt{dao.IAudioMessage} (implementata da \texttt{dao.AudioMessage}) e \texttt{dao.IAudioVideoMessage} (implementata da \texttt{dao.AudioVideoMessage}) rispettivamente.

L'onere di caricare in memoria e gestire l'interno contenuto del messaggio è posticipato al momento di effettiva necessità mediante l'utilizzo dei \textit{virtual proxy} corrispondenti alle classi \texttt{message.AudioMessageProxy} e \texttt{message.AudioVideoMessageProxy}.
	\item{\scshape\bfseries Diagramma delle classi:}
\begin{figure}[H]
\begin{center}
\includegraphics[width=.6\textwidth]{class_gestione_segreteria}
\caption{Diagramma delle classi - Gestione segreteria}\label{fig:gestione_segreteria}
\end{center}
\end{figure}	
	
	\item{\scshape\bfseries Classi utilizzate:}
	\begin{itemize}[noitemsep,nolistsep]
	  \item[-] \texttt{dao.AudioMessage}
	  \item[-] \texttt{dao.AudioVideoMessage}
	  \item[-] \texttt{dao.IAudioMessage}
	  \item[-] \texttt{dao.IAudioVideoMessage}
	  \item[-] \texttt{message.AudioMessageProxy}
	  \item[-] \texttt{message.AudioVideoMessageProxy}
	\end{itemize}
\end{description}

\subsubsection{Façade del server}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
L'interfaccia \texttt{IServerFacade} e la relativa implementazione \texttt{StandardServerFacade}, nella quale si è scelto di applicare il \underline{design pattern} Singleton, forniscono una sorta di interfaccia alle funzionalità offerte dalla sotto-architettura \underline{server} ai componenti che risiedono nel \underline{client}.

Le funzionalità esposte consentono di gestire i messaggi presenti in segreteria, le richieste di comunicazione con altri utenti il login/registrazione degli utenti.
	\item{\scshape\bfseries Diagramma delle classi:}
\begin{figure}[H]
\begin{center}
\includegraphics[width=.8\textwidth]{class_facade_server}
\caption{Diagramma delle classi - Façade del server}\label{fig:facade_server}
\end{center}
\end{figure}	
	
	\item{\scshape\bfseries Classi utilizzate:}\\
	\begin{itemize}[noitemsep,nolistsep]
	  \item[-] \texttt{IServerFacade}
	  \item[-] \texttt{StandardServerFacade}
	\end{itemize}
\end{description}


\subsection{Diagramma delle classi}
\begin{figure}[H]
\begin{center}
\includegraphics[width=1\textwidth]{server_generale}
\caption{Diagramma delle classi - Architettura mytalk.server}\label{fig:server_generale}
\end{center}
\end{figure}
\clearpage

\section{Architettura mytalk.clientpresenter}
La sotto-architettura clientpresenter, nasce con lo scopo di imporre una separazione tra la logica di gestione di un \underline{client} e l'interfaccia grafica usata da quest'ultimo.

Tale considerazione è conforme a l'utilizzo del \underline{design pattern} MVP, già citato nella sezione ``Design pattern'', e alla quale rimandiamo per le specifiche tecniche del medesimo.

La sotto-architettura clientpresenter è per l'appunto la parte ``presenter'' dell'applicativo. I componenti che lo costituiscono devono quindi garantire una logica stabile di comunicazione con il \underline{server}. Essi dovranno anche stabilire le procedure per interrogare il \underline{server} (attraverso il suo façade) al fine di ottenere:
\begin{itemize}
	\item i vari dati contenuti nel \underline{database};
	\item le ``informazioni'' necessarie per stabilire una connessione \underline{client}-\underline{client}.
\end{itemize}

In sintesi la sotto-architettura clientpresenter dispone dei seguenti componenti:
\begin{itemize}[noitemsep,nolistsep]
	\item[-] Gestione comunicazione;
	\item[-] Façade del presenter.
\end{itemize}
Si rimanda alla sottosezione successiva per maggiori dettagli.

Si fa notare che i nomi di tutte le classi riportate nella sezione sono implicitamente parte del package \texttt{org.softwaresynthesis.mytalk.clientpresenter} pertanto tale prefisso sarà omesso nella loro denominazione.

\subsection{Logica di rete}
La rete che viene a crearsi sotto l'architettura di \caName{} è suddivisa in ``comunicazioni'', ovvero gruppi di due o più utenti che comunicano tra di loro. Ogni comunicazione è formata dalle singole ``connessioni'' tra i vari \underline{client}.

Questo capitolo serve a spiegare quale è la logica che governa la rete. Iniziamo definendo i tipi di \underline{client} che la popolano.
\begin{description}
	\item{\scshape\bfseries Nodo}\\
	Il Nodo è rappresentato da un semplice \underline{client} che si trova all'interno di una comunicazione e che ha una unica connessione attiva verso un altro \underline{client}.
	\item{\scshape\bfseries Supernodo}\\
	Il Supernodo è un \underline{client} con funzione di \underline{server}. È usato nelle comunicazioni tra tre o più utenti per smistare le connessioni di tutti facendosi carico del traffico dei \underline{client}.
\end{description}

Vediamo nel dettaglio come avviene una comunicazione. Essa nasce sempre tra due utenti, nel momento in cui uno desidera iniziarla effettua una richiesta verso il \underline{server} che la inoltra al destinatario.
La comunicazione nasce così come un'unica connessione tra due \underline{client} in modalità \underline{peer-to-peer} dove entrambi gli utenti hanno il ruolo di Nodo. Una comunicazione potrà iniziare solo attraverso tale metodologia, in quanto non vengono aperte comunicazioni iniziali tra più di due utenti.

Da questa situazione uno dei due utenti può richiederne l'aggiunta di un ulteriore soggetto. Dopo questa richiesta, il Nodo che la ha eseguita diventa un Supernodo con attive sia la connessione con il vecchio Nodo sia quella con il nuovo Nodo appena aggiunto.

Questa operazione crea una connessione fra tre Nodi estendibile dal Supernodo e dagli altri Nodi attraverso una richiesta al Supernodo stesso. 
%Solo il Supernodo può richiedere nuove connessioni al Server. Con ulteriori richieste i nuovi nodi si collegano al Supernodo con una connessione estendendo la comunicazione.

Ogni Nodo può togliersi dalla comunicazione chiudendo la connessione con il Supernodo. Se è il Supernodo stesso a volersi togliere dalla comunicazione, l'intera comunicazione cade e tutti gli utenti vendono disconnessi.

\subsubsection{L'idea iniziale}
La logica di gestione della rete scelta dal team può rendere poco stabile le comunicazioni. Tale problematica è stata analizzata a lungo, e al fine di rendere le comunicazioni più stabili e solide era stata presa in considerazione un ulteriore soluzione alternativa sempre basata sul modello concettuale di Nodi e Supernodi, tuttavia è stata scartata dopo una breve analisi preliminare.

La differenza principale di tale soluzione rispetto a quella adottata è nella gestione dinamica del Supernodo, che viene scelto in base alla sua capacità di banda e alla possibilità di mantenere attive, con la massima qualità, tutte le connessioni con i Nodi della comunicazione.

Questa soluzione avrebbe richiesto un test di qualità della rete per ogni Nodo verso il nuovo possibile Supernodo, operazione di difficile progettazione e con complessità elevata, pari a $\omega(n-1)$ con n Nodi attivi nella comunicazione.

Al fine di garantire sempre la migliore qualità di connessione era stata presa inoltre in considerazione l'idea di controllare periodicamente la qualità del Supernodo e degli altri Nodi in modo da sostituire il Supernodo se necessario. Purtroppo anche questa soluzione richiederebbe dei calcoli di complessità $\omega(n*n-1)$ con n Nodi attivi nella comunicazione.

Con una corretta implementazione questa soluzione avrebbe permesso una migliore qualità del prodotto \caName, il gruppo ha tuttavia optato per la prima implementazione presentata in quanto le risorse disponibili non erano sufficienti per terminare la seconda.

\subsection{Componenti evidenziati}

\subsubsection{Gestione comunicazione}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
È il componente che definisce i \underline{client} con cui sta comunicando o con cui desidera comunicare l'utente. Tale componente è costituito da un'interfaccia \texttt{clientpresenter.IClient} che rappresenta un modello di \underline{client} con cui interagire (possibilità di stabilire una connessione, possibilità di
estendere una comunicazione e possibilità di verificare se il \underline{client} è Supernodo).

In pratica nel momento in cui l'utente A desidera stabilire una comunicazione con l'utente B, questi si farà restituire dal \underline{server} le informazioni necessarie. Con tali informazioni, quindi, sarà creata un istanza di \texttt{clientpresenter.StandardClient} (implementazione dell'interfaccia \texttt{clientpresenter.IClient}), dalla quale potrà essere abilitata la comunicazione.
	\item{\scshape\bfseries Diagramma delle classi:}
	\begin{figure}[H]
\begin{center}
\includegraphics[width=.8\textwidth]{gestione_comunicazione}
\caption{Diagramma delle classi - Gestione comunicazione}\label{fig:gestione_comunicazione}
\end{center}
\end{figure}
	\item{\scshape\bfseries Classi utilizzate:} 
	\begin{itemize}[noitemsep,nolistsep]
		\item[-] \texttt{IClient}
		\item[-] \texttt{StandardClient}
	\end{itemize}  
\end{description}

\subsubsection{Façade del presenter}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Rappresenta l'interfaccia d'accesso verso la sotto-architettura clientpresenter. Tale componente svincola l'interfaccia grafica dal dover conoscere l'esatta sequenza di chiamata dei metodi per portare a conseguimento una determinata procedura.

I metodi del componente Façade del presenter hanno la cognizione dell'iter di chiamate a metodo per portare a termine correttamente la procedura. Il componente in esame richiede la definizione di un'interfaccia e una sua implementazione standard. Rimandiamo a tali classi per un approfondimento sul comportamento da seguire.
	\item{\scshape\bfseries Diagramma delle classi:}
\begin{figure}[H]
\begin{center}
\includegraphics[width=.8\textwidth]{facade_presenter}
\caption{Diagramma delle classi - Façade del presenter}\label{fig:facade_presenter}
\end{center}
\end{figure}
	\item{\scshape\bfseries Classi utilizzate:} 
	\begin{itemize}[noitemsep,nolistsep]
		\item[-] \texttt{IPresenterFacade}
		\item[-] \texttt{StandardPresenterFacade}
	\end{itemize}
\end{description}

\subsection{Diagramma delle classi}
\begin{figure}[H]
\begin{center}
\includegraphics[width=.8\textwidth]{package_presenter}
\caption{Diagramma delle classi - Architettura mytalk.clientpresenter}\label{fig:package_presenter}
\end{center}
\end{figure}
\clearpage

\section{Architettura mytalk.clientview}
Come già accennato in precedenza, nella sezione introduttiva all'architettura e nella sezione del clientpresenter, clientview ha il compito di definire la logica di visualizzazione dei dati costituendo la GUI del sistema lato \underline{client}.

Le motivazioni che hanno portato a separare tale sotto-architettura dalla parte logica sono da ricercare nei vantaggi di riutilizzo del codice e semplificazione della manutenzione:
\begin{itemize}
 	\item \textbf{future espansioni}: innanzitutto tale scelta permetterà ai progettisti di sviluppare (in futuro) molteplici tipologie di ``viste'', implementabili liberamente svincolando i programmatori dal conoscere al dettaglio la logica sottostante per la gestione delle comunicazioni. Va comunque ricordato che in tal caso, gli sviluppatori dovranno avere un idea chiara del significato delle varie funzioni del Façade del presenter.
 	\item \textbf{semplificare la manutenzione}: cosi come scrivere da zero una nuova vista, anche modificare quelle già presenti risulta essere più facile, per gli stessi motivi descritti al punto precedente.
\end{itemize}

La sotto-architettura clientview rappresenta quindi una vista di default fornita dal team, con lo scopo di rappresentare in modo chiaro ed organizzato le possibilità di iterazione, da parte dell'utente finale, con l'applicativo \caName{}.

Nell'utilizzare tale vista l'utente non avrà la percezione di come sia stata progettata l'architettura totale del sistema, svincolandolo cosi dal dover conoscere le procedure necessarie all'esecuzione di una determinata operazione.

Per quanto riguarda la componentistica, la sotto-architettura clientview è dotata di:
\begin{itemize}[noitemsep,nolistsep]
	\item[-] Façade della vista
	\item[-] Gestione GUI
\end{itemize}

Per le specifiche dei componenti sopra citati, si rimanda alla sezione successiva.

Infine si fa notare che i nomi di tutte le classi riportate nella sezione sono implicitamente parte del package \texttt{org.softwaresynthesis.mytalk.clientview} pertanto tale prefisso sarà omesso nella loro denominazione.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{GUI}
\caption{Rappresentazione ad alto livello della GUI}\label{fig:gui}
\end{figure}

In figura \ref{fig:gui} si riporta un abbozzo dell'interfaccia grafica utente realizzata mediante le classi di questa sotto-architettura. In conformità con quanto stabilito dai requisiti (RSDO10.0.0) l'interfaccia si sviluppa in un'unica pagina.

In particolare, la parte denominata AddressBookPanel conterrà la lista degli utenti nella rubrica, mentre ToolsPanel conterrà i componenti grafici che rappresentano tutte le funzionalità offerte dal sistema. 

Il contenuto del MainPanel, invece, varia in relazione alla funzionalità scelta dall'utente in quel momento. Ad esempio, qualora l'utente selezioni un contatto presente nella rubrica, verrà visualizzato il profilo corrispondente al contatto scelto.

\subsection{Componenti evidenziati}

\subsubsection{Façade della vista}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Il compito di questo componente è rappresentare l'intera sotto-architettura clientview, per come viene vista dalle classi del presenter. In tal modo è possibile rendere indipendenti le classi concrete della sotto-architettura clientview in quanto le dipendenze funzionali provenienti dall'esterno sono accentrate nel Façade.

In particolare, tramite le operazioni che sono dichiarate nell'interfaccia \texttt{IViewFacade} si rende possibile l'aggiornamento dinamico a tempo di esecuzione della vista e, di conseguenza, di quello che viene visualizzato dall'utente finale del sistema.
	\item{\scshape\bfseries Diagramma delle classi:}
\begin{figure}[H]
\begin{center}
\includegraphics[width=.8\textwidth]{componenti_clientview}
\caption{Diagramma delle classi - Façade della vista}\label{fig:facade_vista}
\end{center}
\end{figure}
	\item{\scshape\bfseries Classi utilizzate:} 
	\begin{itemize}[noitemsep,nolistsep]
		\item[-] \texttt{IViewFacade}
		\item[-] \texttt{StandardViewFacade}
	\end{itemize}  
\end{description}

\subsubsection{Gestione GUI}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Questo componente si occupa della gestione dell'interfaccia grafica presentata all'utente finale. Le classi in esso contenute servono pertanto per la rappresentazione delle funzionalità offerte dal sistema all'utente.

Si noti che questo componente demanda tutta la logica al presenter, tramite il Façade del presenter, e quindi è relativo solo ed esclusivamente alla grafica. Inoltre l'interazione con esso è centralizzata all'interno della classe \texttt{gui.GUIHandler}, ciò significa che tutte le altre classi del package \texttt{gui} non interagiscono direttamente con il presenter.
	\item{\scshape\bfseries Diagramma delle classi:}
	
\begin{figure}[H]
\begin{center}
\includegraphics[width=.8\textwidth]{componenti_clientview_gui}
\caption{Diagramma delle classi - Gestione GUI}\label{fig:gestione_gui}
\end{center}
\end{figure}	
	
	\item{\scshape\bfseries Classi utilizzate:} 
	\begin{itemize}[noitemsep,nolistsep]
		\item[-] \texttt{gui.GUIHandler}
		\item[-] \texttt{gui.MainPanel}
		\item[-] \texttt{gui.ToolsPanel}
		\item[-] \texttt{gui.AddressBookPanel}
		\item[-] \texttt{gui.ContactPanel}
		\item[-] \texttt{gui.SearchResultPanel}
		\item[-] \texttt{gui.MessagePanel}
		\item[-] \texttt{gui.LanguagePanel}
		\item[-] \texttt{gui.AccountSettingsPanel}
		\item[-] \texttt{gui.CallHistoryPanel}
	\end{itemize}  
\end{description}

\subsection{Diagramma delle classi}
\begin{figure}[H]
\begin{center}
\includegraphics[width=1\textwidth]{Package_view}
\caption{Diagramma delle classi - Architettura mytalk.clientview}\label{fig:package_client_presenterview}
\end{center}
\end{figure}
\clearpage

\section{Descrizione delle classi}

\subsection{Package org.softwaresynthesis.mytalk.server.dao}

\subsubsection{IAudioMessage}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Interfaccia per i messaggi audio della segreteria telefonica che viene implementata dalle classi \texttt{AudioMessage} e dal relativo proxy \texttt{server.message.AudioMessageProxy}.
% contiene operazione astratta play() per riprodurre il messaggio (se presente) o scaricarlo e avviarne la riproduzione
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	  \begin{itemize}[noitemsep,nolistsep]
	  \item[-] Gestione database
	  \item[-] Gestione segreteria
	  \end{itemize}
\end{description}

\subsubsection{IAudioVideoMessage}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Interfaccia per i messaggi audio/video della segreteria telefonica, a sua volta implementata dalle classi \texttt{AudioVideoMessage} e dal suo proxy \texttt{server.message.AudioVideoMessageProxy}.
% contiene operazione astratta play() per riprodurre il messaggio (se presente) o scaricarlo e avviarne la riproduzione
	\item{\scshape\bfseries Componenti che ne fanno uso:} 
	  \begin{itemize}[noitemsep,nolistsep]
	    \item[-] Gestione database
	    \item[-] Gestione segreteria
	  \end{itemize}
\end{description}

\subsubsection{AudioMessage}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Classe che rappresenta un messaggio audio nella segreteria telefonica di un utente, implementa l'interfaccia \texttt{IAudioMessage}.
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	  \begin{itemize}[noitemsep,nolistsep]
	    \item[-] Gestione database
	    \item[-] Gestione segreteria
	  \end{itemize}
\end{description}

\subsubsection{AudioVideoMessage}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Classe che rappresenta un messaggio audio/video nella segreteria telefonica di un utente, implementa l'interfaccia \texttt{IAudioVideoMessage}.
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	  \begin{itemize}[noitemsep,nolistsep]
	    \item[-] Gestione database
	    \item[-] Gestione segreteria
	  \end{itemize}
\end{description}

\subsubsection{IGroup}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Interfaccia per i gruppi interni alla rubrica, prevede un'operazione astratta \texttt{add(IUserData)} per l'aggiunta di un nuovo contatto al gruppo e un'operazione \texttt{remove(IUserData)} per la sua rimozione.

Estende inoltre l'interfaccia \texttt{server.abook.IContact} comune a tutti i contatti della rubrica e richiesta per l'applicazione del \underline{design pattern} Composite.
	\item{\scshape\bfseries Componenti che ne fanno uso:} 
	  \begin{itemize}[noitemsep,nolistsep]
	    \item[-] Gestione database
	    \item[-] Gestione rubrica
	  \end{itemize}
\end{description}

\subsubsection{StandardGroup}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Implementazione dell'interfaccia \texttt{IGroup}, ogni gruppo è dotato di un nome e raccoglie in sé zero o più istanze di classi sottotipo di \texttt{server.abook.IContact}.
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	  \begin{itemize}[noitemsep,nolistsep]
	    \item[-] Gestione database
	  \end{itemize}
\end{description}

\subsubsection{IUserData}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Interfaccia per le classi che rappresentano gli utenti, è dotata di operazioni get/set per accedere ai dati degli utenti registrati sul sistema.
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	\begin{itemize}[noitemsep,nolistsep]
	  \item[-] Gestione database
	  \item[-] Gestione rubrica
	  \item[-] Gestione connessione
	\end{itemize}
\end{description}

\subsubsection{StandardUserData}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Classe che implementa l'interfaccia \texttt{IUserData} le cui istanze corrispondono ai record della tabella degli utenti nel \underline{database}.
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	\begin{itemize}[noitemsep,nolistsep]
	  \item[-] Gestione database
	  \item[-] Gestione stato
	\end{itemize}
\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.connection}

\subsubsection{ICommunicationHandler}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Interfaccia per la gestione delle richieste per ottenere le informazioni necessarie a un \underline{client} per stabilire una comunicazione con altri \underline{client}. In particolare le operazioni in essa dichiarate dovranno ritornare un istanza di un oggetto che implementa \texttt{IConnection}.
	\item{\scshape\bfseries Componenti che ne fanno uso:}
		\begin{itemize}[noitemsep,nolistsep]
			\item[-] Gestione connessione
		\end{itemize}
\end{description}

\subsubsection{StandardCommunicationHandler}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Implementazione che si fornisce dell'interfaccia \texttt{ICommunicationHandler}. In tale classe, le informazioni ritornate al \underline{client} sono informazioni necessarie a stabilire una connessione di tipo WebRTC (ritorna un istanza di \texttt{WebRTCInfo}).
	\item{\scshape\bfseries Componenti che ne fanno uso:}
		\begin{itemize}[noitemsep,nolistsep]
			\item[-] Gestione connessione
		\end{itemize}
\end{description}

\subsubsection{IConnection}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Interfaccia mediante la quale è possibile recuperare  i dati necessari a un \underline{client} al fine di stabilire una connessione con un altro \underline{client}.
	\item{\scshape\bfseries Componenti che ne fanno uso:}
		\begin{itemize}[noitemsep,nolistsep]
			\item[-] Gestione connessione
			\item[-] Gestione comunicazione
		\end{itemize}
\end{description}

\subsubsection{WebRTCInfo}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Implementazione dell'interfaccia \texttt{IConnection} che rappresenta le informazioni usate da un \underline{client} per stabilire una connessione WebRTC con un altro \underline{client}.
	\item{\scshape\bfseries Componenti che ne fanno uso:}
		\begin{itemize}[noitemsep,nolistsep]
			\item[-] Gestione connessione
		\end{itemize}
\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.abook}

\subsubsection{IContact}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Interfaccia condivisa da tutti i contatti della rubrica di un utente, permette di trattare in modo uniforme gli utenti singoli e i gruppi secondo quando previsto dal \underline{design pattern} Composite.

Dichiara la presenza di operazioni astratte per recuperare l'accesso alle informazioni sottostanti (ad esempio il nome di un utente o di un gruppo).
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	\begin{itemize}[nolistsep, noitemsep]
	  \item[-] Gestione rubrica
	\end{itemize}
\end{description}

\subsubsection{IAddressBook}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Interfaccia che raccoglie le operazioni sulla rubrica e permette di controllare l'accesso alle strutture dati che la implementano.
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	\begin{itemize}[noitemsep,nolistsep]
	  \item[-] Gestione rubrica
	\end{itemize}
\end{description}

\subsubsection{UserDataProxy}
\begin{description}
  \item{\scshape\bfseries Descrizione:}\\
La classe implementa l'interfaccia \texttt{server.dao.IUserData} e rappresenta un proxy per i dati degli utenti che risiedono sul \underline{server}.

Le istanze di questa classe vengono restituite da un opportuno Factory Method dichiarato nell'interfaccia \texttt{server.ServerFacade} e hanno il ruolo di rappresentare sui \underline{client} degli oggetti che risiedono in un diverso spazio di indirizzamento (sul \underline{server}) nonché di controllare gli accessi per esigenze di protezione.
  \item{\scshape\bfseries Componenti che ne fanno uso:}
  \begin{itemize}[noitemsep,nolistsep]
    \item[-] Gestione rubrica
  \end{itemize}
\end{description}

\subsubsection{AddressBook}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Classe che implementa l'interfaccia \texttt{IAddressBook} e rappresenta quindi la rubrica di un determinato utente. Contiene un riferimento a \texttt{IContact} che corrisponde al nodo padre della struttura dati ad albero contenente la rubrica.
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	\begin{itemize}[noitemsep,nolistsep]
	  \item[-] Gestione rubrica
	\end{itemize}
\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.state}
\subsubsection{IState}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Interfaccia padre della gerarchia di stati che gli utenti possono assumere nel corso dell'interazione con il sistema. La composizione delle istanze di \texttt{server.dao.StandardUserData} con oggetti sottotipo di \texttt{IState} cui inoltrano le richieste ricevute dall'esterno permette di cambiare dinamicamente il comportamento degli oggetti che rappresentano gli utenti.
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	\begin{itemize}[noitemsep,nolistsep]
	  \item[-] Gestione stato
	  \item[-] Gestione connessione
	\end{itemize}
\end{description}

\subsubsection{StateOnline}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Classe astratta che implementa l'interfaccia \texttt{IState} e viene estesa da tutti gli stati che corrispondono alla presenza ``online'' dell'utente. È ulteriormente specializzata dalle sottoclassi concrete \texttt{StateAvailable} e \texttt{StateOccupied}, le quali hanno facoltà di determinare il reale comportamento degli utenti online.
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	\begin{itemize}[noitemsep,nolistsep]
	  \item[-] Gestione stato
	\end{itemize}
\end{description}

\subsubsection{StateOffline}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Classe concreta della gerarchia degli stati che implementa l'interfaccia \texttt{IState} e corrisponde alla mancata presenza online dell'utente che la possiede. Un utente che si trova nello stato ``offline'' non può essere contattato direttamente ma solo attraverso la segreteria telefonica.
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	\begin{itemize}[noitemsep,nolistsep]
	  \item[-] Gestione stato
	\end{itemize}
\end{description}

\subsubsection{StateAvailable}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Classe concreta della gerarchia degli stati che corrisponde alla presenza online di un utente e alla sua disponibilità ad accettare comunicazioni in ingresso.
	\item{\scshape\bfseries Componenti che ne fanno uso:}
    \begin{itemize}[noitemsep,nolistsep]
      \item[-] Gestione stato
    \end{itemize}
\end{description}

\subsubsection{StateOccupied}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Classe concreta della gerarchia degli stati che corrisponde alla mancata disponibilità di un utente a ricevere ulteriori comunicazioni in ingresso dal momento che si trova impegnato in un'altra conversazione. Gli utenti che si trovano in questo stato non possono essere contattati direttamente ma solo attraverso la possibilità di lasciare un messaggio in segreteria.
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	\begin{itemize}[noitemsep,nolistsep]
	  \item[-] Gestione stato
	\end{itemize}
\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server.message}
\subsubsection{IMessageBox}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Interfaccia che rappresenta, ad alto livello, la segreteria telefonica dell'utente cui è associata. Tramite opportune operazioni permette di accedere all'elenco dei messaggi audio o audio/video che l'utente ha ricevuto nel periodo in cui era in linea o non era disponibile perché impegnato in una conversazione.
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	\begin{itemize}
	  \item[-] Gestione segreteria
	\end{itemize}
\end{description}

\subsubsection{StandardMessageBox}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Classe concreta che implementa l'interfaccia \texttt{IMessageBox} e rappresenta dunque la rubrica associata a un determinato utente.
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	\begin{itemize}[noitemsep,nolistsep]
	  \item[-] Gestione segreteria
	\end{itemize}
\end{description}

\subsubsection{AudioMessageProxy}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Proxy virtuale ad uso dei \underline{client} per i messaggi audio lasciati ad un utente in segreteria. La classe implementa l'interfaccia \texttt{server.dao.IAudioMessage} ogni sua istanza è costruita per composizione con un riferimento a  \texttt{server.dao.AudioMessage}, cui inoltra le richieste dopo aver eventualmente scaricato il messaggio dal \underline{server}.
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	\begin{itemize}[noitemsep,nolistsep]
	  \item[-] Gestione segreteria
	\end{itemize}
\end{description}

\subsubsection{AudioVideoMessageProxy}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Proxy virtuale ad uso dei \underline{client} per i messaggi audio/video in segreteria. La classe implementa l'interfaccia \texttt{server.dao.AudioVideoMessage} ed è costruita, similmente a \texttt{AudioMessageProxy} con un'istanza di \texttt{server.dao.AudioVideoMessage} per limitare il traffico di rete e ottimizzare il consumo di memoria del \underline{client}.
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	\begin{itemize}[noitemsep,nolistsep]
	  \item[-] Gestione segreteria
	\end{itemize}
\end{description}

\subsection{Package org.softwaresynthesis.mytalk.server}
\subsubsection{IServerFacade}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Interfaccia che contiene tutte le operazioni richieste dai componenti della sotto-architettura clientpresenter inerenti alla registrazione, all'autenticazione,  alla gestione della rubrica e della segreteria nonché delle connessioni con altri utenti.

In quest'ultimo caso le operazioni richieste vengono a loro volta inoltrate al componente responsabile della gestione della connessione (\texttt{server.connection.IConnectionHandler}).
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	\begin{itemize}[noitemsep,nolistsep]
	  \item[-] Façade del server
	  \item[-] Façade del presenter
	  \item[-] Gestione comunicazione
	\end{itemize}
\end{description}

\subsubsection{StandardServerFacade}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Questa classe Singleton è l'implementazione dell'interfaccia \texttt{IServerFacade} e contiene, in particolare, i metodi che rendono concrete le operazioni corrispondenti ai Factory Method dichiarati nell'interfaccia citata (per la gestione dei messaggi in segreteria e degli utenti nella rubrica).
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	\begin{itemize}[noitemsep,nolistsep]
	  \item[-] Façade del server
	\end{itemize}
\end{description}

\subsection{Package org.softwaresynthesis.mytalk.clientpresenter}
\subsubsection{IClient}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Interfaccia che raccoglie le operazioni astratte che è possibile invocare su un \underline{client} astratto del sistema corrispondenti, ad esempio, alla ricezione di una chiamata in ingresso oppure all'interrogazione sullo stato (nodo semplice o Supernodo) di un determinato \underline{client}.
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	\begin{itemize}[noitemsep,nolistsep]
	  \item[-] Gestione comunicazione
	\end{itemize}
\end{description}

\subsubsection{StandardClient}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Implementazione dell'interfaccia \texttt{IClient} che incapsula al suo interno la logica di eventuale ritrasmissione dei dati in ingresso (nel caso in cui il \underline{client} sia un Supernodo) e di invio dei dati prodotti in locale ai \underline{client} con cui è stata instaurata una connessione. 
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	\begin{itemize}[noitemsep,nolistsep]
	  \item[-] Gestione comunicazione
	\end{itemize}
\end{description}

\subsubsection{IPresenterFacade}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Interfaccia che raccoglie la dichiarazione di tutte le operazioni astratte con cui si suppone che la vista realizzi lo scambio di messaggi con il presenter. Tramite queste operazioni deve dunque essere possibile, ad esempio, gestire l'autenticazione di un utente, interrogare la segreteria telefonica, modificare lo stato e le informazioni personali e scaricare la rubrica.
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	\begin{itemize}[noitemsep,nolistsep]
	  \item[-] Façade del presenter
	  \item[-] Gestione GUI
	\end{itemize}
\end{description}

\subsubsection{StandardPresenterFacade}
\begin{description}
	\item{\scshape\bfseries Descrizione:}\\
Questa classe rappresenta un'applicazione del \underline{design pattern} Singleton e implementa inoltre l'interfaccia \texttt{IPresenterFacade}. Fornisce pertanto dei metodi concreti utilizzati per la comunicazione fra la vista e il \underline{server}, elaborando qualora necessario i dati ricevuti in input e inoltrando le richieste al componente Façade del server.
	\item{\scshape\bfseries Componenti che ne fanno uso:}
	\begin{itemize}[noitemsep,nolistsep]
	  \item[-] Façade del presenter
	\end{itemize}
\end{description}

\subsection{Package org.softwaresynthesis.mytalk.clientview}
\subsubsection{IViewFacade}
\begin{description}
  \item{\scshape\bfseries Descrizione}\\
Interfaccia che dichiara le operazioni astratte che possono essere richiamate sulla vista a partire dai componenti della sotto-architettura clientpresenter.
  \item{\scshape\bfseries Componenti che ne fanno uso:}
  \begin{itemize}[noitemsep,nolistsep]
    \item[-] Façade della vista
    \item[-] Façade del presenter
  \end{itemize}
\end{description}

\subsubsection{StandardViewFacade}
\begin{description}
  \item{\scshape\bfseries Descrizione}\\
Implementazione dell'interfaccia \texttt{IViewFacade} che contiene la definizione concreta dei metodi in essa dichiarati.
  \item{\scshape\bfseries Componenti che ne fanno uso:}
  \begin{itemize}[noitemsep,nolistsep]
    \item[-] Façade della vista
  \end{itemize}
\end{description}

\subsection{Package org.softwaresynthesis.clientview.gui}
\subsubsection{GUIHandler}
\begin{description}
  \item{\scshape\bfseries Descrizione}\\
L'istanza di questa classe ha il compito di inoltrare ai componenti delle diverse sotto-architetture le richieste provenienti dalle altre classi di questo package, in quanto unico possessore di un riferimento di tipo \texttt{IServerFacade}.

Inoltre, tale classe ha la responsabilità di controllare l'attivazione e gli aggiornamenti dinamici nel corso dell'esecuzione di tutti gli oggetti di classi grafiche istanziate.
  \item{\scshape\bfseries Componenti che ne fanno uso:}
  \begin{itemize}[noitemsep,nolistsep]
    \item[-] Gestione GUI
  \end{itemize}
\end{description}

\subsubsection{AddressBookPanel}
\begin{description}
  \item{\scshape\bfseries Descrizione}\\
Pannello che permette la visualizzazione della rubrica dell'utente connesso al sistema, e di accedere alle funzionalità di amministrazione della rubrica stessa (come l'aggiunta o la rimozione di utenti/gruppi, lo spostamento di un utente da un gruppo a un altro oppure l'ordinamento).
  \item{\scshape\bfseries Componenti che ne fanno uso:}
  \begin{itemize}[noitemsep,nolistsep]
    \item[-] Gestione GUI
  \end{itemize}
\end{description}

\subsubsection{MainPanel}
\begin{description}
  \item{\scshape\bfseries Descrizione}\\
Classe padre della gerarchia di oggetti grafici che possono comparire nella sezione principale dell'interfaccia utente. La parte comune a tutte le sottoclassi permette all'utente di impostare il proprio stato e di uscire dall'applicazione. Ogni sua specializzazione si rivolge a \texttt{GUIHandler} per inoltrare i comandi verso il componente Façade del presenter.
  \item{\scshape\bfseries Componenti che ne fanno uso:}
  \begin{itemize}[noitemsep,nolistsep]
    \item[-] Gestione GUI
  \end{itemize}
\end{description}

\subsubsection{ToolsPanel}
\begin{description}
  \item{\scshape\bfseries Descrizione}\\
Classe che rappresenta il pannello degli strumenti della home screen dell'applicativo, mediante il quale è possibile accedere alle funzionalità di ricerca, di segreteria telefonica, selezione della lingua, modifica dei dati dell'utente e storico delle chiamate.
  \item{\scshape\bfseries Componenti che ne fanno uso:}
  \begin{itemize}[noitemsep,nolistsep]
    \item[-] Gestione GUI
  \end{itemize}
\end{description}

\subsubsection{SearchResultPanel}
\begin{description}
  \item{\scshape\bfseries Descrizione}\\
Componente grafica che estende la classe \texttt{MainPanel} e visualizza i risultati della ricerca di un utente. La sua visualizzazione avviene in seguito all'uso della componente grafica di ricerca presente nel pannello degli strumenti.
  \begin{itemize}[noitemsep,nolistsep]
    \item[-] Gestione GUI
  \end{itemize}
\end{description}

\subsubsection{ContactPanel}
\begin{description}
  \item{\scshape\bfseries Descrizione}\\
Sottoclasse di \texttt{MainPanel} utilizzata per rappresentare il profilo di un utente. Solo accedendo quest'ultimo sarà possibile avviare una comunicazione con l'utente. Il contatto viene visualizzato selezionando l'utente dalla rubrica oppure tra i risultati di una ricerca.
  \item{\scshape\bfseries Componenti che ne fanno uso:}
  \begin{itemize}[noitemsep,nolistsep]
    \item[-] Gestione GUI
  \end{itemize}
\end{description}

\subsubsection{MessagePanel}
\begin{description}
  \item{\scshape\bfseries Descrizione}\\
Questa sottoclasse di \texttt{MainPanel} permette di accedere all'elenco dei messaggi in segreteria di un determinato utente e ne permette la gestione. La visualizzazione si attiva quando viene premuto il relativo pulsante mostrato dall'istanza di \texttt{ToolsPanel}.
  \item{\scshape\bfseries Componenti che ne fanno uso:}
  \begin{itemize}[noitemsep,nolistsep]
    \item[-] Gestione GUI
  \end{itemize}
\end{description}

\subsubsection{LanguagePanel}
\begin{description}
  \item{\scshape\bfseries Descrizione}\\
Questa sottoclasse di \texttt{MainPanel} è impiegata per permettere da parte dell'utente finale la selezione della lingua desiderata. La visualizzazione del pannello avviene in seguito all'attivazione del pulsante corrispondente situato nel pannello degli strumenti.
  \item{\scshape\bfseries Componenti che ne fanno uso:}
  \begin{itemize}[noitemsep,nolistsep]
    \item[-] Gestione GUI
  \end{itemize}
\end{description}

\subsubsection{AccountSettingsPanel}
\begin{description}
  \item{\scshape\bfseries Descrizione}\\
Questa classe è utilizzata per rappresentare il \underline{form} che si presenta all'utente per la modifica dei propri dati. Costituisce inoltre una sottoclasse di \texttt{MainPanel} e viene visualizzata quando l'utente preme il relativo pulsante nel pannello degli strumenti.
  \item{\scshape\bfseries Componenti che ne fanno uso:}
  \begin{itemize}[noitemsep,nolistsep]
    \item[-] Gestione GUI
  \end{itemize}
\end{description}

\subsubsection{CallHistoryPanel}
\begin{description}
  \item{\scshape\bfseries Descrizione}\\
Questa classe estende \texttt{MainPanel} e viene impiegata per rappresentare lo storico delle chiamate visualizzato quando l'utente attiva il pulsante corrispondente presente nel \texttt{ToolsPanel}.
  \item{\scshape\bfseries Componenti che ne fanno uso:}
  \begin{itemize}[noitemsep,nolistsep]
    \item[-] Gestione GUI
  \end{itemize}
\end{description}
\clearpage

\section{Conclusioni sull'architettura}

\subsection{Diagrammi delle attività}
In questa sezione saranno descritti i diagrammi di attività che rappresentano il flusso di utilizzo dei vari servizi messi a disposizione dal prodotto \caName.

\begin{figure}[H]
\centering
\includegraphics[width=.8\textwidth]{home}
\caption{Diagramma di attività generale che descrive l'interazione con il sistema}\label{fig:ADhome}
\end{figure}

Il diagramma in figura \vref{fig:ADhome} rappresenta il flusso principale dell'applicazione \caName. Da tale punto è possibile autenticarsi al sistema per poi poter usufruire di tutti i servizi messi a disposizione dal prodotto. Nei successivi diagrammi, figura \ref{fig:ADregistrazione} e \ref{fig:ADrecuperopassword}, vengono descritti rispettivamente le specializzazioni delle attività presenti nella schermata di login: registrazione (se non si ha ancora a disposizione un account utente) e recupero password (nel caso la password sia stata smarrita).

\begin{figure}[H]
\centering
\includegraphics[width=.8\textwidth]{autenticazione}
\caption{Diagramma di attività relativo all'autententicazione}\label{fig:ADautenticazione}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=.8\textwidth]{registrazione}
\caption{Diagramma di attività relativo alla registrazione}\label{fig:ADregistrazione}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=.8\textwidth]{recupero_pass}
\caption{Diagramma di attività relativo al recupero della password}\label{fig:ADrecuperopassword}
\end{figure}


Dal diagramma principale (ricordiamo in figura \vref{fig:ADhome}) una volta autenticati è possibile raggiungere ogni funzionalità del software, come ad esempio la gestione della rubrica (figura \ref{fig:ADgestionerubrica}), la gestione del proprio account(figura \ref{fig:ADgestioneaccount}) o della segreteria (figura \ref{fig:ADgestionesegreteria}).

\begin{figure}[H]
\centering
\includegraphics[width=.8\textwidth]{gestione_rub_pers}
\caption{Diagramma di attività relativo alla gestione della rubrica personale}\label{fig:ADgestionerubrica}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=.8\textwidth]{gestione_account_pers}
\caption{Diagramma di attività relativo alla gestione dei dati dell'account personale}\label{fig:ADgestioneaccount}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=.8\textwidth]{gestione_segreteria}
\caption{Diagramma di attività relativo alla gestione della segretria}\label{fig:ADgestionesegreteria}
\end{figure}


\`{E} infine data la possibilità di connettersi con altri utenti tramite l'attività connessione illustrata nel dettaglio in figura \ref{fig:ADconnessione}.

\begin{figure}[H]
\centering
\includegraphics[width=.8\textwidth]{connessione}
\caption{Diagramma di attività relativo alla connessione}\label{fig:ADconnessione}
\end{figure}

La connessione può essere di tipo audio (figura \ref{fig:ADcomaudio}), audio/video (figura \ref{fig:ADcomaudiovideo}) o testuale (figura \ref{fig:ADcomtestuale}). In tutte e tre le tipologie di connessione è possibile effettuare una condivisione di risorse, come specificato in figura \ref{fig:ADcondrisorse}, o registrare una chiamata (tranne nel caso di comunicazione testuale) figura \ref{fig:ADregistrachiamata}.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{com_audio}
\caption{Diagramma di attività relativo alla comunicazione audio}\label{fig:ADcomaudio}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=.8\textwidth]{com_audiovideo}
\caption{Diagramma di attività relativo alla comunicazione audio/video}\label{fig:ADcomaudiovideo}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=.8\textwidth]{com_testuale}
\caption{Diagramma di attività relativo alla comunicazione testuale}\label{fig:ADcomtestuale}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=.8\textwidth]{condividi_ris}
\caption{Diagramma di attività relativo alla condivisione di risorse}\label{fig:ADcondrisorse}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=.8\textwidth]{registrazione_chiamata}
\caption{Diagramma di attività relativo alla registrazione della chiamata}\label{fig:ADregistrachiamata}
\end{figure}

In conclusione si ricorda che è possibile lasciare un messaggio nella segreteria di un determinato contatto se non presente in linea nel momento in cui desideriamo comunicare con lui \ref{fig:ADmessegreteria}.

\begin{figure}[H]
\centering
\includegraphics[width=.8\textwidth]{mes_segreteria}
\caption{Diagramma di attività relativo alla memorizzazione di un messaggio in segreteria}\label{fig:ADmessegreteria}
\end{figure}

\clearpage

\section{Tracciamenti}\label{sec:tracciamenti}
Nella seguente sezione vengono proposti tutti i tracciamenti eseguiti mediante il sistema Synthsis Requirment Manager. I tracciamenti proposti sono giustificati dalle seguenti due motivazioni:

\begin{itemize}
	\item Dimostrare il soddisfacimento per necessarietà e sufficienza della corrispondenza tra gli elementi tracciati (e.g. un componente deve rispondere necessariamente alle esigenze di uno o più requisiti, tali insomma che ne giustifichino l'esistenza. D'altro canto è richiesto che ogni requisito definito in fase d'analisi sia soddisfatto e risolto da almeno un componente).
	\item dare una lettura generale delle varie: componenti, requisiti, \underline{design pattern} e classi.
\end{itemize}

\input{tracciamenti.tex}

\end{document}
